<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingwen&#39;s blog</title>
  
  <subtitle>没有输出的输入是不完整的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-27T01:39:38.236Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李庆文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer-序列化二叉树</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-序列化二叉树/</id>
    <published>2020-01-27T00:57:21.000Z</published>
    <updated>2020-01-27T01:39:38.236Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十八篇。<br>主要知识点为二叉树，针对于一棵给定的二叉树进行编码和解码。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先就是按照正常的先序遍历的思路对原来的二叉树进行存储，用,来隔离每个节点，用#来表示空节点。用递归的思路来进行编码。<br>解码的时候操作反过来，针对于之前编码生成的字符串，从头到尾依次遍历，通过<strong>,</strong>来对节点进行分离，通过#来判定当前节点为空，通过递归的方式生成之前的二叉树。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char* Serialize(TreeNode *root) &#123;   </span><br><span class="line">        if(!root) return &quot;#&quot;;</span><br><span class="line">        string r = to_string(root-&gt;val);</span><br><span class="line">        r.push_back(&apos;,&apos;);</span><br><span class="line">        char *left = Serialize(root-&gt;left);</span><br><span class="line">        char *right = Serialize(root-&gt;right);</span><br><span class="line">        char *ret = new char[strlen(left) + strlen(right) + r.size()];</span><br><span class="line">        strcpy(ret, r.c_str());</span><br><span class="line">        strcat(ret, left);</span><br><span class="line">        strcat(ret, right);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* Deserialize(char *str) &#123;</span><br><span class="line">        return decode(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    TreeNode* decode(char *&amp;str) &#123;</span><br><span class="line">        if(*str==&apos;#&apos;)&#123;</span><br><span class="line">            str++;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        int num = 0;</span><br><span class="line">        while(*str != &apos;,&apos;)</span><br><span class="line">            num = num*10 + (*(str++)-&apos;0&apos;);</span><br><span class="line">        str++;</span><br><span class="line">        TreeNode *root = new TreeNode(num);</span><br><span class="line">        root-&gt;left = decode(str);</span><br><span class="line">        root-&gt;right = decode(str);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十八篇。&lt;br&gt;主要知识点为二叉树，针对于一棵给定的二叉树进行编码和解码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-把二叉树打印成多行</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-把二叉树打印成多行/</id>
    <published>2020-01-26T10:58:48.000Z</published>
    <updated>2020-01-26T13:47:33.980Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十七篇。<br>主要知识点为二叉树，就是简单的层序遍历而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是简单的层序遍历。<br>用队列保存每一层的结果，方便遍历下一层，<br>同时本层的结果放到一个数组中进行存储。<br>所有层数组的集合就是我们的最终结果。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* root) &#123;</span><br><span class="line">            if(!root) return &#123;&#125;;</span><br><span class="line">            vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">            queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">            while(!q.empty())&#123;</span><br><span class="line">                vector&lt;int&gt; level;</span><br><span class="line">                for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                    auto a = q.front(); q.pop();</span><br><span class="line">                    level.push_back(a-&gt;val);</span><br><span class="line">                    if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                    if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(level);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十七篇。&lt;br&gt;主要知识点为二叉树，就是简单的层序遍历而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-按之字形顺序打印二叉树</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-按之字形顺序打印二叉树/</id>
    <published>2020-01-26T10:42:46.000Z</published>
    <updated>2020-01-26T10:57:29.949Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十六篇。<br>主要知识点为二叉树，就是层序遍历的变形而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>层序遍历的思路。<br>通过队列来保存每一层的节点，方便下一层的遍历,同时本层的结果要放在本层的数组中，<br>由于要之字形进行保存，也就是说奇数层和偶数层要分别处理，所以要记录层数,用于之后的判断。</p><ul><li>单数层添加的时候插入到本层数组的后面，实现从左到右依次添加的效果;</li><li>双数层添加的时候每次插入到数组的头部，实现类似从右往左添加的效果。</li></ul><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        int levelnum = 1;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; level;</span><br><span class="line">            for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                auto a = q.front(); q.pop();</span><br><span class="line">                if(levelnum%2 == 1)&#123;</span><br><span class="line">                   level.push_back(a-&gt;val);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                   level.insert(level.begin(),a-&gt;val);   </span><br><span class="line">                &#125;</span><br><span class="line">                if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">            levelnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十六篇。&lt;br&gt;主要知识点为二叉树，就是层序遍历的变形而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-对称的二叉树</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-对称的二叉树/</id>
    <published>2020-01-26T10:25:39.000Z</published>
    <updated>2020-01-26T10:41:28.309Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十五篇。<br>主要知识点为二叉树，就是简单的判断一棵树是不是对称二叉树。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>什么时候一棵树是对称的呢？<br>首先，根节点相同；<br>其次，如果左右子树都不存在，肯定是对称的；如果左右子树只存在一个，那么肯定是不对称的。<br>如果左右子树都存在，那么左子树是对称的，右子树也是对称的。<br>最后，通过辅助函数，递归调用，问题就可以得到解决。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetrical(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        return helper(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    bool helper(TreeNode* root1,TreeNode* root2)&#123;</span><br><span class="line">        if(!root1 &amp;&amp; !root2) return true;</span><br><span class="line">        if(!root1 || !root2) return false;</span><br><span class="line">        if(root1-&gt;val != root2-&gt;val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return helper(root1-&gt;left,root2-&gt;right) &amp;&amp; helper(root1-&gt;right,root2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十五篇。&lt;br&gt;主要知识点为二叉树，就是简单的判断一棵树是不是对称二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉树的下一个节点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-二叉树的下一个节点/</id>
    <published>2020-01-26T09:52:05.000Z</published>
    <updated>2020-01-26T10:24:39.244Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十四篇。<br>主要知识点为二叉树，查找二叉树中序遍历给定节点的下一个节点。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于给定的节点，</p><ol><li>如果存在右子树，那么给定节点中序遍历的下一个节点就是右子树的最左侧节点。</li><li>如果不存在右子树，那么就可能存在两种情况，<ol><li>当前节点是根节点的左子树，那么它中序遍历的下一个节点就是它的根节点。</li><li>当前节点是根节点的右子树，那么它中序遍历的下一个节点是当前所在左子树的根节点。</li></ol></li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeLinkNode *left;</span><br><span class="line">    struct TreeLinkNode *right;</span><br><span class="line">    struct TreeLinkNode *next;</span><br><span class="line">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeLinkNode* res;</span><br><span class="line">        // 当前节点存在右子树</span><br><span class="line">        if(pNode &amp;&amp; pNode-&gt;right)&#123;</span><br><span class="line">            TreeLinkNode* temp = pNode-&gt;right;</span><br><span class="line">            while(temp-&gt;left)&#123;</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = temp;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">         // 当前节点不存在右子树，</span><br><span class="line">           TreeLinkNode* par = pNode-&gt;next;</span><br><span class="line">           while(pNode-&gt;next &amp;&amp; par-&gt;right == pNode)&#123;</span><br><span class="line">               pNode = pNode-&gt;next;</span><br><span class="line">               par  = pNode-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           res = par;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十四篇。&lt;br&gt;主要知识点为二叉树，查找二叉树中序遍历给定节点的下一个节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-删除链表中重复的结点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-删除链表中重复的结点/</id>
    <published>2020-01-26T09:12:58.000Z</published>
    <updated>2020-01-26T09:49:24.987Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十三篇。<br>主要知识点为链表的遍历，去除重复元素。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>将整个链表进行遍历，通过map来保存每个节点出现的次数。之后再重建链表，链表结点的值仅仅对应于出现一次的元素。返回新链表即可。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>可以直接在原来的链表上进行操作，具体的思路如下：<br>首先在头节点之前建立一个帮助结点，帮助结点之后的就是我们真正的没有重复结点的链表。<br>然后我们从head结点开始向后遍历，如果碰到有相同元素，那么一直向后遍历，越过这些重复元素。如果元素值没有重复，那么就都向后遍历一个节点。直到遍历结束。</p><p>下面以1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5为例进行详细说明，<br>我们开始创建辅助节点将原来的链表变成-1-&gt;1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5,<br>然后有两个指针一个指针p指向之前的头节点1，一个指针last指向辅助节点-1，开始遍历。提醒一下，他们两个操作的可是同一个链表。</p><ol><li>1!=2,所以1不重复，所以p前移指向2，last前移指向1；</li><li>2!=3,所以2不重复，所以p前移指向3，last前移指向2；</li><li>3==3，所以3是重复的，这个时候p继续前移，直到指向第一个不是3的节点，也就是4，last的next指向4.（这样的话所有的3就已经被删除了）</li><li>4==4，所以4也是重复的，这个时候p继续前移，直到指向第一个不是4的节点，也就是5，last的next指向5，(这样的话所有的4就已经被删除了)</li><li>5已经没有后继节点了，所有结束。</li></ol><p>然后整个的链表就变成了-1-&gt;1-&gt;2-&gt;5,最后结果返回-1的next即可。<br>相比于前一种思路可以极大的提高空间同时提升效率。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>本题目的目标是1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5变成1-&gt;2-&gt;5，题目等同于<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">leetcode-83-RemoveDuplicatesfromSortedListII</a><br>但是也有类似的题目是从1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5变成1-&gt;2-&gt;3-&gt;4-&gt;5。比如<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">leetcode-82-RemoveDuplicatesfromSortedList</a></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* first = new ListNode(-1);</span><br><span class="line">        first-&gt;next = head;</span><br><span class="line">        ListNode* last = first;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">           if(p-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">               //如果有重复元素，那么就跳过。</span><br><span class="line">               int val = p-&gt;val;</span><br><span class="line">               while(p &amp;&amp; p-&gt;val == val)&#123;</span><br><span class="line">                   p = p-&gt;next;</span><br><span class="line">               &#125;   </span><br><span class="line">               //此时p指向不是之前相等值的第一个元素，但是不能保证这个值也不重复，</span><br><span class="line">               //所以此时继续进入到循环之中进行判断。</span><br><span class="line">               //通过last-&gt;next = p 删除了中间值为val的所有值。</span><br><span class="line">               last-&gt;next = p;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               // 如果不重复，那就直接链接到last上。p继续后移</span><br><span class="line">               last= p;</span><br><span class="line">               p = p-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        return first-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><h3 id="扩展代码"><a href="#扩展代码" class="headerlink" title="扩展代码"></a>扩展代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        // 去掉重复元素,重复元素保留一次</span><br><span class="line">        if(!head) return NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">            if(p-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十三篇。&lt;br&gt;主要知识点为链表的遍历，去除重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-链表中环的入口节点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-链表中环的入口节点/</id>
    <published>2020-01-26T06:32:54.000Z</published>
    <updated>2020-01-26T09:11:24.060Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十二篇。<br>主要知识点为链表的遍历，同样的使用一个set就可以解决问题。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路非常清晰，从头开始遍历，遍历的时候先判断当前节点是否在set中，如果已经在，那么这个节点肯定就是那个入口节点。如果不在，继续向后遍历。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;ListNode*&gt; mset;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            if(mset.count(p)) return p;</span><br><span class="line">            mset.insert(p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十二篇。&lt;br&gt;主要知识点为链表的遍历，同样的使用一个set就可以解决问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-字符流中第一个不重复的字符</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-字符流中第一个不重复的字符/</id>
    <published>2020-01-26T06:26:41.000Z</published>
    <updated>2020-01-26T06:31:29.225Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十一篇。<br>主要知识点为字符串中每个字符的出现次数，同样的题目其实已经出现很多次了，相信大家都已经可以做到手到擒来了。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>输出描述:<br>如果当前字符流没有存在出现一次的字符，返回#字符。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于插入的每个字符都进行一次保存，然后对于每个字符出现的次数都可以通过map来保存出现次数，最后遍历一遍map找到第一个出现次数为1的字符就可以了。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string s = &quot;&quot;;</span><br><span class="line">    map&lt;char,int&gt; mmap;</span><br><span class="line">  //Insert one char from stringstream</span><br><span class="line">    void Insert(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">       s += ch;</span><br><span class="line">       if(mmap[ch])&#123;</span><br><span class="line">           mmap[ch]++;</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           mmap[ch] = 1;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //return the first appearence once char in current stringstream</span><br><span class="line">    char FirstAppearingOnce()</span><br><span class="line">    &#123;</span><br><span class="line">        for(char a:s)&#123;</span><br><span class="line">            if(mmap[a] == 1)</span><br><span class="line">               return a;</span><br><span class="line">        &#125;</span><br><span class="line">        return &apos;#&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十一篇。&lt;br&gt;主要知识点为字符串中每个字符的出现次数，同样的题目其实已经出现很多次了，相信大家都已经可以做到手到擒来了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-表示数值的字符串</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-表示数值的字符串/</id>
    <published>2020-01-26T06:11:42.000Z</published>
    <updated>2020-01-26T06:23:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十篇。<br>主要知识点为字符串，重点在于细心，认真的去判断成为数值的条件，然后再去做题就比较快。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目主要要考虑以下的问题</p><ol><li>小数点，正负号，指数标志可能会出现多次的问题。解决方式是设置一个标志，用来记录它们之前是否已经出现。</li><li>直接以小数点或者指数标志或者正负号结尾：解决方式在每个条件结束的时候进行一次是否到结尾的判断</li><li>string以‘\0’为标志结束。可以用来结束循环。</li><li>非法字符的问题。 对于前面没有处理的其他的非法情况都直接返回false</li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumeric(char* string)</span><br><span class="line">    &#123;</span><br><span class="line">        if(string == NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 应对仅仅只有+或者-的情况</span><br><span class="line">        if(*string == &apos;+&apos; || *string == &apos;-&apos;)&#123;</span><br><span class="line">            string++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //标记小数点、整数部分、指数部分是否存在，</span><br><span class="line">        bool point = false, numint = false, nume = false;</span><br><span class="line">        while(*string != &apos;\0&apos;)&#123;</span><br><span class="line">            //处理小数</span><br><span class="line">            if(*string == &apos;.&apos;)&#123;</span><br><span class="line">                if( point || nume) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                string++;</span><br><span class="line">                point = true;</span><br><span class="line">                if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //处理科学计数法</span><br><span class="line">            else if(*string == &apos;E&apos; || *string == &apos;e&apos;)&#123;</span><br><span class="line">                if(numint == false || nume)&#123;</span><br><span class="line">                     return false;</span><br><span class="line">                &#125;</span><br><span class="line">                string++; </span><br><span class="line">                nume = true;</span><br><span class="line">                if(*string == &apos;+&apos; || *string == &apos;-&apos;)&#123;</span><br><span class="line">                    string++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //处理正常数据</span><br><span class="line">            else if(*string &gt;= &apos;0&apos; &amp;&amp; *string &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                numint = true;</span><br><span class="line">                string++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十篇。&lt;br&gt;主要知识点为字符串，重点在于细心，认真的去判断成为数值的条件，然后再去做题就比较快。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-正则表达式匹配</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-正则表达式匹配/</id>
    <published>2020-01-26T05:50:50.000Z</published>
    <updated>2020-01-26T06:05:32.779Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十九篇。<br>这个题目比较难，甚至我觉得是整个剑指offer里面最难的一道题目了，<br>也是参考了网上的答案加上自己的理解来解决这道题目，no more talk, show you code!</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题目其实关注的点比较多，下面一个一个来说</p><ol><li>匹配串或者模式串为空的情况</li><li>字符串是以’\0’为标志结束的</li><li><strong>.</strong>的处理，可以表示任何一个字符,要注意此时匹配串是不是已经到了结尾</li><li><em>号的处理，由于</em>可以表示它前面的字符出现0次，1次，甚至多次，所以这个时候就会让模式串和匹配串进行不同的后续的比较。</li></ol><p>代码里面的注释写的非常清楚了，所以直接看代码吧。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool match(char* str, char* pattern)</span><br><span class="line">    &#123;</span><br><span class="line">        // 两者任意一个为空，则返回空。</span><br><span class="line">        if(str == NULL || pattern == NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return matchCore(str, pattern);</span><br><span class="line">     &#125;</span><br><span class="line">    //本部分以str = aaa 为例进行说明。</span><br><span class="line">    bool matchCore(char* str, char* pattern)&#123;</span><br><span class="line">        // 字符串和模式串都运行到了结尾，则匹配完成。返回true</span><br><span class="line">        if(*str == &apos;\0&apos; &amp;&amp; *pattern == &apos;\0&apos;)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 字符串没有到结尾，模式串到结尾了，则返回false</span><br><span class="line">        // 模式串没有到结尾，字符串到结尾了，则根据后续判断进行，需要对&apos;*&apos;做处理</span><br><span class="line">        if((*str != &apos;\0&apos; &amp;&amp; *pattern == &apos;\0&apos;))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果模式串的下一个字符是&apos;*&apos;，</span><br><span class="line">        if(*(pattern + 1) == &apos;*&apos;)&#123;</span><br><span class="line">            // 如果字符串和模式串相等，或者模式串是&apos;.&apos;，并且字符串没有到结尾，则继续匹配</span><br><span class="line">            if(*str == *pattern || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;))&#123;</span><br><span class="line">                // 可能存在三种情况。</span><br><span class="line">                // 1. *匹配前面字符0次， 如pattern = a*aaa</span><br><span class="line">                // 2. *匹配前面字符1次， 如pattern = a*aa</span><br><span class="line">                // 3. *匹配前面字符不止一次，如pattern = a*</span><br><span class="line">                return    // *匹配0次</span><br><span class="line">                    matchCore(str, pattern + 2)|| </span><br><span class="line">                          // *匹配1次</span><br><span class="line">                    matchCore(str + 1, pattern + 2) ||</span><br><span class="line">                          // *匹配不止1次</span><br><span class="line">                    matchCore(str + 1, pattern);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果字符串和模式串不相等，则跳过当前模式串的字符和&apos;*&apos;，进入新一轮的匹配</span><br><span class="line">            else&#123;</span><br><span class="line">                // 比如pattern = b*aaa</span><br><span class="line">                return matchCore(str, pattern + 2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果字符串和模式串相等，或者模式串是&apos;.&apos;，并且字符串没有到结尾，则继续匹配</span><br><span class="line">        if(*str == *pattern || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;))&#123;</span><br><span class="line">            return matchCore(str + 1, pattern + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十九篇。&lt;br&gt;这个题目比较难，甚至我觉得是整个剑指offer里面最难的一道题目了，&lt;br&gt;也是参考了网上的答案加上自己的理解来解决这道题目，no more talk, show you code!&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="hard" scheme="http://yoursite.com/tags/hard/"/>
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="正则表达" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-构建乘积数组</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-构建乘积数组/</id>
    <published>2020-01-26T03:37:35.000Z</published>
    <updated>2020-01-26T03:57:30.390Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十八篇。<br>主要知识点为数组，但是可以通过类似于矩阵的方式来进行性能的提升。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>暴力求解，双层循环，对每个结果进行单独的计算即可。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>其实我们在计算的时候可以发现很多计算是重复的，举例来说<br>1, 2, 3, 4, 5<br>计算第一个数字的时候是2*3*4*5,<br>计算第二个数字的时候是1*3*4*5,<br>计算第三个数字的时候是1*2*4*5,<br>计算第四个数字的时候是1*2*3*5,<br>计算第五个数字的时候是1*2*3*4。<br>这样就可以发现很多运算是重复的，比如第一行的3<em>4</em>5和第二行的3<em>4</em>5，<br>如何去掉重复的计算呢？就是我们接下来要考虑的问题。<br>同样以1, 2, 3, 4, 5为例来进行说明，我们可以发现同一行的计算可以分成左右两个部分。<br>计算第一个数字的时候是(1)*(2*3*4*5),<br>计算第二个数字的时候是(1*1)*(3*4*5),<br>计算第三个数字的时候是(1*2*1)*(4*5),<br>计算第四个数字的时候是(1*2*3*1)*(5),<br>计算第五个数字的时候是(1*2*3*4*1)()。<br>左面括号中下一行的数字是上一行的数字再乘上一个数字，<br>右面括号中上一行的数字是下一行的数组再乘上一个数字。<br>而最终的结果就是左边的括号乘上右面的括号。<br>非常优秀的思路。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        //  方法1: 双层遍历 O(n^2)</span><br><span class="line">        vector&lt;int&gt; res ;</span><br><span class="line">        int temp = 1;</span><br><span class="line">        for(int i  = 0;i&lt; A.size();i++)&#123;</span><br><span class="line">            for(int j = 0; j&lt; A.size(); j++)&#123;</span><br><span class="line">                if(i != j)&#123;</span><br><span class="line">                   temp = A[j] *temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            temp = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n^2),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        //  方法2: 巧妙运用一下前一次和后一次的关系</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;int&gt; left = &#123;1&#125;;</span><br><span class="line">        vector&lt;int&gt; right = &#123;1&#125;;</span><br><span class="line">        for(int i = 1; i &lt;= A.size()-1; i++)&#123;</span><br><span class="line">            left.push_back(left.back()* A[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for( int i = A.size()-2; i&gt;=0;i--)&#123;</span><br><span class="line">            right.insert(right.begin(),right.front()*A[i+1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i&lt;A.size();i++)&#123;</span><br><span class="line">            res.push_back(left[i] * right[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十八篇。&lt;br&gt;主要知识点为数组，但是可以通过类似于矩阵的方式来进行性能的提升。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数组中重复的数字</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-数组中重复的数字/</id>
    <published>2020-01-26T03:22:44.000Z</published>
    <updated>2020-01-26T03:35:26.708Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十七篇。<br>主要知识点为数组，找数组中重复的数字，类似于之前找出现一次或者两次的数字。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>找个set来存一下之前出现过的数据，然后在新遍历到数据的时候只要先看一下set中有没有存在，若存在，则直接返回即可，若不存在，将这个数据放到set中，继续向后遍历。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // Parameters:</span><br><span class="line">    //        numbers:     an array of integers</span><br><span class="line">    //        length:      the length of array numbers</span><br><span class="line">    //        duplication: (Output) the duplicated number in the array number</span><br><span class="line">    // Return value:       true if the input is valid, and there are some duplications in the array number</span><br><span class="line">    //                     otherwise false</span><br><span class="line">    bool duplicate(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; mset;</span><br><span class="line">        for(int i = 0; i&lt;length; i++)&#123;</span><br><span class="line">            if(!mset.count(numbers[i]))&#123;</span><br><span class="line">                mset.insert(numbers[i]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十七篇。&lt;br&gt;主要知识点为数组，找数组中重复的数字，类似于之前找出现一次或者两次的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-把字符串转化成整数</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E6%88%90%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-把字符串转化成整数/</id>
    <published>2020-01-26T03:12:36.000Z</published>
    <updated>2020-01-26T03:20:27.806Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十六篇。<br>主要知识点为字符串的判断和边界条件的判定，细心一点就没有问题。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br>输入描述:<br>输入一个字符串,包括数字字母符号,可以为空<br>输出描述:<br>如果是合法的数值表达则返回该数字，否则返回0</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题目需要考虑的边界有以下几个：</p><ol><li>正负号的判定</li><li>数字中间可能有非法字符</li><li>数字结果可能会超出INT类型的范围。<br>考虑好以上几个边界本题目就可以得到解决。</li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int StrToInt(string str) &#123;</span><br><span class="line">       if(str.size() == 0) return 0;</span><br><span class="line">       int flag  = 0; //默认正数</span><br><span class="line">       if(str[0] == &apos;+&apos;)&#123;</span><br><span class="line">           flag = 1;</span><br><span class="line">       &#125;else if(str[0] == &apos;-&apos;)&#123;</span><br><span class="line">           flag = 2;</span><br><span class="line">       &#125;</span><br><span class="line">       int start = flag&gt;0?1:0;</span><br><span class="line">       long res = 0;</span><br><span class="line">       while(start &lt; str.size())&#123;</span><br><span class="line">           if(str[start]&gt;&apos;0&apos; &amp;&amp; str[start] &lt;&apos;9&apos;)&#123;</span><br><span class="line">               res = res*10 + (str[start]-&apos;0&apos;);</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           start++;</span><br><span class="line">       &#125;</span><br><span class="line">       res = (flag == 2)?(-res):res;</span><br><span class="line">       //判断是否出现溢出</span><br><span class="line">       if(res &gt;INT_MAX || res &lt; INT_MIN)&#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十六篇。&lt;br&gt;主要知识点为字符串的判断和边界条件的判定，细心一点就没有问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-不用加减乘除做加法</title>
    <link href="http://yoursite.com/2020/01/25/%E5%89%91%E6%8C%87offer-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
    <id>http://yoursite.com/2020/01/25/剑指offer-不用加减乘除做加法/</id>
    <published>2020-01-25T13:02:14.000Z</published>
    <updated>2020-01-26T03:10:43.389Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十五篇。<br>主要知识点为位运算，思路非常神奇，可以打破我们的思维定势。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="">题目描述</a></h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>当我们计算两个数字之和的时候，实际上一方面我们计算两个数当前位的加法运算，另一方面是计算当前位的进位运算，本题目我们采用同样的思路来对二进制进行计算，当前位的计算用位的异或操作，具体操作为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1^1 = 0; 1^0 = 1; 0^1 = 1; 0^0 = 0;</span><br></pre></td></tr></table></figure><p>而进位运算通过位的与运算来进行计算，具体操作为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&amp;1 = 1; 1&amp;0 = 0; 0&amp;1 = 0; 0&amp;0 = 0;</span><br></pre></td></tr></table></figure><p>下面我们举例来进行说明：<br>比如2+4变成二进制为010和100，<br>这样直接通过位的异或计算当前位就是110，而进位计算010&amp;100 = 0，<br>所以最终计算结果的二进制就是110，也就是6；</p><p>比如2+6，它们的二进制分别为010和110，<br>计算当前位为010^110= 100,计算进位010&amp;110=010。<br>由于是进的位，所以在进行下一步计算的时候，进位结果要左移一位之后再来和之前的计算结果进行计算，<br>所以当前位运算结果变为100^100 = 000,进位结果变为100&amp;100 = 100，<br>进位结果继续左移1位得到1000，和原来当前位数字000进行异或计算得到0000^1000=1000，而进位0000&amp;1000 = 0，运算结束。<br>所以最后结果就是1000也就是8。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Add(int num1, int num2)</span><br><span class="line">    &#123;</span><br><span class="line">        //return num1+num2;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        while(num2 != 0)&#123;</span><br><span class="line">            temp = num1^num2;</span><br><span class="line">            num2 = (num1&amp;num2)&lt;&lt;1;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十五篇。&lt;br&gt;主要知识点为位运算，思路非常神奇，可以打破我们的思维定势。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="位运算" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-扑克牌顺子</title>
    <link href="http://yoursite.com/2020/01/25/%E5%89%91%E6%8C%87offer-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/"/>
    <id>http://yoursite.com/2020/01/25/剑指offer-扑克牌顺子/</id>
    <published>2020-01-25T12:30:55.000Z</published>
    <updated>2020-01-25T13:00:04.249Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十四篇。<br>没有用到啥比较厉害的算法，主要还是学习一下思路,有思路事情就变得的非常简单啦。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=11198&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于大小王可以替代任何牌，所以我们对这次要单独处理。<br>然后我们找到抽到的排面中最小且不为0的数字，<br>然后开始依次找其他四个比它大且构成顺子的四张牌。如果有对应的牌，那么就继续判断下一张；<br>如果没有对应的牌，但是有0，就意味着可以用小王来替换对应的牌，然后继续判断下一张；<br>如果既没有对应的牌，然后也没有大小王可以用来替换，那么肯定就不能构成顺子，就直接返回false即可。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">        int zeros = count(numbers.begin(),numbers.end(),0);</span><br><span class="line">        int mmin = INT_MAX;</span><br><span class="line">        for(int i:numbers)&#123;</span><br><span class="line">            if(i != 0 &amp;&amp; i&lt;mmin)&#123;</span><br><span class="line">                mmin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i&lt;5;i++)&#123;</span><br><span class="line">            if(count(numbers.begin(),numbers.end(),mmin+i))&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;else if(zeros &gt; 0)&#123;</span><br><span class="line">                zeros--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十四篇。&lt;br&gt;没有用到啥比较厉害的算法，主要还是学习一下思路,有思路事情就变得的非常简单啦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-反转单词序列</title>
    <link href="http://yoursite.com/2020/01/24/%E5%89%91%E6%8C%87offer-%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/01/24/剑指offer-反转单词序列/</id>
    <published>2020-01-24T02:18:09.000Z</published>
    <updated>2020-01-24T02:25:57.409Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十三篇。<br>主要知识点依旧是字符串,注意观察题目规律，细心一点就行，也比较简单。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="">题目描述</a></h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>观察题目我们就可以发现，其实每个单词内部的字母都是正序的，然后每个单词都是用空格隔开的，然后单词的顺序是逆序的，所以我们很自然的就可以想到每次按照顺序读取一个单词，然后单词之间按照逆序进行拼接即可。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string ReverseSentence(string str) &#123;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        string temp = &quot;&quot;;</span><br><span class="line">        for(char a:str)&#123;</span><br><span class="line">            if(a != &apos; &apos;)&#123;</span><br><span class="line">                temp.push_back(a);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res = temp+&quot; &quot;+res;</span><br><span class="line">                temp = &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = temp+&quot; &quot;+res;</span><br><span class="line">        return res.substr(0,res.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十三篇。&lt;br&gt;主要知识点依旧是字符串,注意观察题目规律，细心一点就行，也比较简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-左旋转字符串</title>
    <link href="http://yoursite.com/2020/01/24/%E5%89%91%E6%8C%87offer-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/01/24/剑指offer-左旋转字符串/</id>
    <published>2020-01-24T01:36:49.000Z</published>
    <updated>2020-01-24T02:13:09.044Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十二篇。<br>主要知识点为字符串，非常简单，都没啥值得说的。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这里其实有三种情况需要考虑，</p><ol><li>K等于字符串的长度： 这个时候可以直接返回原来的字符串。</li><li>K小于字符串的长度： 这个时候相当于对于原来的字符串进行截取，一段是前面K位，一段是剩下的。然后左右置换重新拼接即可。</li><li>K大于字符串的长度： 这个时候实际上相当于已经左移一圈了，继续左移实际上最后效果相当于左移<br>K = K % len.<br>然后该情况就变成了第二种情况。 </li></ol><p>本题目给的测试用例不是很好，或者说题目意思说的不明确，当循环左移到头之后怎么办呢？是直接返回，还是按照循环左移这个名字来真的循环呢？两种理解都可以过所有样例,感觉题目出的非常不好。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string LeftRotateString(string str, int n) &#123;</span><br><span class="line">        int slen = str.size();</span><br><span class="line">        if(slen == 0) return str;</span><br><span class="line">        //if(slen &lt; n) return str; // 如果左移位数超过字符串长度，直接返回，也可以过测试用例。</span><br><span class="line">        int realn = n%slen;</span><br><span class="line">        string head = str.substr(0,realn);</span><br><span class="line">        string tail = str.substr(realn);</span><br><span class="line">        return tail+head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十二篇。&lt;br&gt;主要知识点为字符串，非常简单，都没啥值得说的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-和为S的两个数字</title>
    <link href="http://yoursite.com/2020/01/24/%E5%89%91%E6%8C%87offer-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/01/24/剑指offer-和为S的两个数字/</id>
    <published>2020-01-24T01:24:51.000Z</published>
    <updated>2020-01-24T01:35:40.147Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十一篇。<br>主要知识点为数组的遍历，找个set存一下想要的元素有没有存在即可，比较简单。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>可以通过两层循环来解决。但是时间复杂度是O(n^2)。或者这里是有序的，可以在内层循环用二分查找，那么时间复杂度将会变为O(nlgn)。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>使用set来保存所有元素，然后重新遍历一遍数组，查找是否存在和当前数值的和为S的数字。<br>如果有多对数字的和等于S，输出两个数的乘积最小的，这个有一个类似于贪心的操作就是如果和一定，那么两个值越接近，那么乘积越大，对应的，我们要求找乘积最小的，所以只要从最小值开始遍历即可。<br>这里扩展一下，之前在leetcode上还有一道题目同样是找两个和为S的数字，但是那个题目要求返回的是两个值的索引，那个地方要用map,对应的key和value分别是值和索引。而本题目中只要求返回两个值即可，所以只要用set来确认有没有对应元素存在即可。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; mset;</span><br><span class="line">        for(auto a:array)&#123;</span><br><span class="line">            mset.insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto a:array)&#123;</span><br><span class="line">            if(mset.count(sum-a))&#123;</span><br><span class="line">                return &#123;a,sum-a&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十一篇。&lt;br&gt;主要知识点为数组的遍历，找个set存一下想要的元素有没有存在即可，比较简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-和为S的连续正数序列</title>
    <link href="http://yoursite.com/2020/01/24/%E5%89%91%E6%8C%87offer-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/01/24/剑指offer-和为S的连续正数序列/</id>
    <published>2020-01-24T01:14:01.000Z</published>
    <updated>2020-01-24T01:23:39.458Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十篇。<br>主要知识点为双指针，通过双指针来定位符合条件的正数序列，从而解决整个问题。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><p>输出描述：<br>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>通过双指针来存储可能符合要求的正数序列。</p><ol><li>当指针范围正数序列大于要求值，当前序列和要减去当前左指针所指的值，然后左指针右移。</li><li>当指针范围正数序列小于要求值，则右指针右移，当前序列和要加上当前右指针所指的值。</li><li>如果等于要求值S,则判断是否符合序列的条件，如果符合，则加入结果中，如果不符合，则继续判断。直到到达边界。<br>如果引申一下，这个题目也可以用在解决有序数组中找和为S的正数序列。</li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int l = 1,r = 1,tsum = 1;</span><br><span class="line">        while(l &lt;= r)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            tsum += r;</span><br><span class="line">            while(tsum &gt; sum)&#123;</span><br><span class="line">                tsum -= l;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(tsum == sum &amp;&amp; l != r)&#123;</span><br><span class="line">                vector&lt;int&gt; temp ;</span><br><span class="line">                for(int i = l;i&lt;=r;i++) temp.push_back(i);</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十篇。&lt;br&gt;主要知识点为双指针，通过双指针来定位符合条件的正数序列，从而解决整个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数组中只出现一次的数字</title>
    <link href="http://yoursite.com/2020/01/23/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/01/23/剑指offer-数组中只出现一次的数字/</id>
    <published>2020-01-23T14:39:13.000Z</published>
    <updated>2020-01-23T14:42:09.219Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第三十九篇。<br>主要知识点为数组的遍历。有两个只出现一次的数字，找出它们。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>找一个map来存储每个数字以及他们出现的次数。<br>遍历整个map，找到那两个出现次数为1的数字即可。 </p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; mmap;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        for(auto a:data)&#123;</span><br><span class="line">            mmap[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto a:mmap)&#123;</span><br><span class="line">            if(a.second == 1)&#123;</span><br><span class="line">                res.push_back(a.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *num1 = res[0];</span><br><span class="line">        *num2 = res[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第三十九篇。&lt;br&gt;主要知识点为数组的遍历。有两个只出现一次的数字，找出它们。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
</feed>
