<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingwen&#39;s blog</title>
  
  <subtitle>没有输出的输入是不完整的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-27T05:49:12.498Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李庆文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer-机器人的运动范围</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-机器人的运动范围/</id>
    <published>2020-01-27T05:34:33.000Z</published>
    <updated>2020-01-27T05:49:12.498Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十三篇。<br>主要知识点为二维数组的遍历和元素的处理，这个题目和前面的那个矩阵中的路径题目是类似的。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题目和矩阵中寻找路径是类似的，<br>我们可以将这个题目要处理的数据范围抽象成为rows*cols的一个矩阵（或者第一象限），然后从一个结点开始出发，判断其四周的数据是不是合法的，类似于深度优先搜索对每个结点进行遍历。<br>同样的为了保证访问的数据不会重复，需要通过一个数组来保存每个数据之前是否已经被处理过。<br>这种处理方式比较经典，要多加锻炼。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int movingCount(int threshold, int rows, int cols)</span><br><span class="line">    &#123;</span><br><span class="line">        if(threshold &lt;= 0 || rows &lt;=0 || cols &lt;= 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bool *flags = new bool[rows*cols];</span><br><span class="line">        for(int i = 0; i &lt; rows * cols; i++)&#123;</span><br><span class="line">             flags[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(threshold,rows,cols,0,0,flags);</span><br><span class="line">    &#125;</span><br><span class="line">    int helper(int threshold,int rows,int cols,int i,int j,bool *flags)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if(checkToGo(threshold,rows,cols,i,j,flags))&#123;</span><br><span class="line">            flags[i*cols+j] = true;</span><br><span class="line">            res = 1+helper(threshold,rows,cols,i+1,j,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i-1,j,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i,j+1,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i,j-1,flags);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool checkToGo(int threshold,int rows,int cols,int i,int j,bool *flags)&#123;</span><br><span class="line">        if(i&gt;=0 &amp;&amp; i&lt;rows &amp;&amp; j&gt;=0 &amp;&amp; j&lt;cols &amp;&amp; checkThreshold(threshold,i,j) &amp;&amp; flags[i*cols+j] == false)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool checkThreshold(int threshold,int i,int j)&#123;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        while(i)&#123;</span><br><span class="line">            temp += i%10;</span><br><span class="line">            i = i/10;</span><br><span class="line">        &#125;</span><br><span class="line">        while(j)&#123;</span><br><span class="line">            temp += j%10;</span><br><span class="line">            j = j/10;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp&lt;=threshold;</span><br><span class="line">    &#125;</span><br><span class="line">    private:</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(cols*rows*lg(max(rows,cols)),空间复杂度为O(cols*rows)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十三篇。&lt;br&gt;主要知识点为二维数组的遍历和元素的处理，这个题目和前面的那个矩阵中的路径题目是类似的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-矩阵中的路径</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-矩阵中的路径/</id>
    <published>2020-01-27T04:55:04.000Z</published>
    <updated>2020-01-27T05:24:58.138Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十二篇。<br>主要知识点为数组，在矩阵中查找对应的字符串序列，类似于走迷宫或者找包围区间的题目。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历矩阵中的每个结点作为起始结点，然后从这个点开始向四周遍历，寻找字符串的下一个字符，如果字符串匹配到最后的结束标志’\0’,那就返回true,反之就返回false.<br>需要注意的一点是之前访问过的就不能访问了，所以需要找一个数组或者矩阵来标志这个节点之前是否已经访问过。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPath(char* matrix, int rows, int cols, char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(rows&lt;=0 || cols&lt;=0 || !str || !matrix) return false;</span><br><span class="line">        vector&lt;bool&gt; flags(rows*cols,0);</span><br><span class="line">        for(int i = 0; i &lt; rows; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; cols; j++)&#123;</span><br><span class="line">                if(helper(matrix,rows,cols,i,j,str,flags)) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool helper(char* matrix,int rows,int cols,int i,int j,char* str,vector&lt;bool&gt; flags)&#123;</span><br><span class="line">        if(*str == &apos;\0&apos;) return true;</span><br><span class="line">        if(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; rows &amp;&amp; j &lt; cols &amp;&amp; matrix[i*cols+j] == *str &amp;&amp; flags[i*cols+j] == false)&#123;</span><br><span class="line">            flags[i*cols+j] = true;</span><br><span class="line">            bool find = false;</span><br><span class="line">            find = helper(matrix,rows,cols,i,j+1,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i,j-1,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i+1,j,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i-1,j,str+1,flags);</span><br><span class="line">            if(find == false)&#123;</span><br><span class="line">                flags[i*cols+j] = false;</span><br><span class="line">            &#125;</span><br><span class="line">            return find;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(rows*cols*logn),空间复杂度为O(rows*cols)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十二篇。&lt;br&gt;主要知识点为数组，在矩阵中查找对应的字符串序列，类似于走迷宫或者找包围区间的题目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-滑动窗口的最大值</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-滑动窗口的最大值/</id>
    <published>2020-01-27T04:45:30.000Z</published>
    <updated>2020-01-27T04:52:29.790Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十一篇。<br>主要知识点为数组，题目看起来很炫酷，但是实际上就是一个给定区间的遍历找最大值而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接使用stl的max_element方法来获得对应区间的最大值。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>朴素算法，自己实现类似于max_element的方法。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">    &#123;</span><br><span class="line">       // 方法1: 直接使用stl中的max_element函数得到对应的窗口</span><br><span class="line">       if(num.size() == 0 || size &lt;=0 ||size&gt;num.size() ) return&#123;&#125;;</span><br><span class="line">       vector&lt;int&gt; res;</span><br><span class="line">       for(int i = 0; i&lt;=num.size()-size; i++)&#123;</span><br><span class="line">            int cur = *max_element(num.begin()+i,num.begin()+i+size);</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">    &#123;</span><br><span class="line">       // 方法2:朴素的方法依次向后比较窗口大小个元素</span><br><span class="line">       if(num.size() == 0 || size &lt;=0 ||size&gt;num.size() ) return&#123;&#125;;</span><br><span class="line">       vector&lt;int&gt; res;</span><br><span class="line">       for(int i = 0; i &lt;= num.size()-size; i++)&#123;</span><br><span class="line">           int temp = num[i];</span><br><span class="line">           for(int j = i+1; j&lt;i+size; j++)&#123;</span><br><span class="line">               if(num[j]&gt;temp)&#123;</span><br><span class="line">                   temp = num[j];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res.push_back(temp);</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十一篇。&lt;br&gt;主要知识点为数组，题目看起来很炫酷，但是实际上就是一个给定区间的遍历找最大值而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数据流中的中位数</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-数据流中的中位数/</id>
    <published>2020-01-27T02:44:08.000Z</published>
    <updated>2020-01-27T04:41:10.183Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十篇。<br>主要知识点为数组，依旧是数组遍历然后分析找中位数，比较简单。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="">题目描述</a></h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>找一个数组，用来存储所有插入的数据，并保持数组内的数据有序（可以用插入排序的方式）。<br>在获得中间数的时候，可以通过奇偶直接从数组中获取处理并返回。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Insert(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        mvec.push_back(num);</span><br><span class="line">        len++;</span><br><span class="line">        //sort(mvec.begin(),mvec.end());</span><br><span class="line">        int i = len;</span><br><span class="line">        for( ; i &gt;= 1; i--)&#123;</span><br><span class="line">            if(num&lt;=mvec[i])&#123;</span><br><span class="line">                mvec[i] = mvec[i-1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mvec[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double GetMedian()</span><br><span class="line">    &#123; </span><br><span class="line">        int mindex = (len-1)/2;</span><br><span class="line">        if(len%2 == 0)&#123;</span><br><span class="line">            return ((mvec[mindex]+(double)mvec[mindex+1])/2);  </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (double)mvec[mindex];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; mvec;</span><br><span class="line">    int len = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十篇。&lt;br&gt;主要知识点为数组，依旧是数组遍历然后分析找中位数，比较简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉搜索树的第k个结点</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-二叉搜索树的第k个结点/</id>
    <published>2020-01-27T01:50:33.000Z</published>
    <updated>2020-01-27T02:39:17.705Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十九篇。<br>主要知识点为二叉搜索树，二叉搜索树由于本身的特性，其中序遍历结果是有序的，<br>针对这一点，经常有题目出现。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。<br>例如（5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>中序遍历，将遍历的节点数据保存到一个数组中，然后返回数组的第K个节点即可。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>找一个全局计数器表示中序遍历到多少个节点，如果到第K个节点就可以直接返回当前结果了。如果没有到第K个节点，那么就返回NULL。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        if(!pRoot || k&lt;=0) return NULL; </span><br><span class="line">        inorder(pRoot,res);</span><br><span class="line">        if(res.size() &lt; k)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return res[k-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;TreeNode*&gt; res;</span><br><span class="line">    void inorder(TreeNode* root,vector&lt;TreeNode*&gt;&amp; res)&#123;</span><br><span class="line">        if(!root) return ;</span><br><span class="line">        if(root-&gt;left) inorder(root-&gt;left,res);</span><br><span class="line">        res.push_back(root);</span><br><span class="line">        if(root-&gt;right) inorder(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        if(!pRoot || k&lt;=0) return NULL; </span><br><span class="line">        inorder(pRoot,k);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    TreeNode* res = NULL;</span><br><span class="line">    void inorder(TreeNode* root,int k)&#123;</span><br><span class="line">        if(!root) return ;</span><br><span class="line">        if(root-&gt;left) inorder(root-&gt;left,k);</span><br><span class="line">        count++;</span><br><span class="line">        if(count == k)&#123;</span><br><span class="line">            res = root;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right) inorder(root-&gt;right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十九篇。&lt;br&gt;主要知识点为二叉搜索树，二叉搜索树由于本身的特性，其中序遍历结果是有序的，&lt;br&gt;针对这一点，经常有题目出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinarySearchTree" scheme="http://yoursite.com/tags/BinarySearchTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-序列化二叉树</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-序列化二叉树/</id>
    <published>2020-01-27T00:57:21.000Z</published>
    <updated>2020-01-27T01:39:38.236Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十八篇。<br>主要知识点为二叉树，针对于一棵给定的二叉树进行编码和解码。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先就是按照正常的先序遍历的思路对原来的二叉树进行存储，用,来隔离每个节点，用#来表示空节点。用递归的思路来进行编码。<br>解码的时候操作反过来，针对于之前编码生成的字符串，从头到尾依次遍历，通过<strong>,</strong>来对节点进行分离，通过#来判定当前节点为空，通过递归的方式生成之前的二叉树。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char* Serialize(TreeNode *root) &#123;   </span><br><span class="line">        if(!root) return &quot;#&quot;;</span><br><span class="line">        string r = to_string(root-&gt;val);</span><br><span class="line">        r.push_back(&apos;,&apos;);</span><br><span class="line">        char *left = Serialize(root-&gt;left);</span><br><span class="line">        char *right = Serialize(root-&gt;right);</span><br><span class="line">        char *ret = new char[strlen(left) + strlen(right) + r.size()];</span><br><span class="line">        strcpy(ret, r.c_str());</span><br><span class="line">        strcat(ret, left);</span><br><span class="line">        strcat(ret, right);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* Deserialize(char *str) &#123;</span><br><span class="line">        return decode(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    TreeNode* decode(char *&amp;str) &#123;</span><br><span class="line">        if(*str==&apos;#&apos;)&#123;</span><br><span class="line">            str++;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        int num = 0;</span><br><span class="line">        while(*str != &apos;,&apos;)</span><br><span class="line">            num = num*10 + (*(str++)-&apos;0&apos;);</span><br><span class="line">        str++;</span><br><span class="line">        TreeNode *root = new TreeNode(num);</span><br><span class="line">        root-&gt;left = decode(str);</span><br><span class="line">        root-&gt;right = decode(str);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十八篇。&lt;br&gt;主要知识点为二叉树，针对于一棵给定的二叉树进行编码和解码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-把二叉树打印成多行</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-把二叉树打印成多行/</id>
    <published>2020-01-26T10:58:48.000Z</published>
    <updated>2020-01-26T13:47:33.980Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十七篇。<br>主要知识点为二叉树，就是简单的层序遍历而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是简单的层序遍历。<br>用队列保存每一层的结果，方便遍历下一层，<br>同时本层的结果放到一个数组中进行存储。<br>所有层数组的集合就是我们的最终结果。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* root) &#123;</span><br><span class="line">            if(!root) return &#123;&#125;;</span><br><span class="line">            vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">            queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">            while(!q.empty())&#123;</span><br><span class="line">                vector&lt;int&gt; level;</span><br><span class="line">                for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                    auto a = q.front(); q.pop();</span><br><span class="line">                    level.push_back(a-&gt;val);</span><br><span class="line">                    if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                    if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(level);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十七篇。&lt;br&gt;主要知识点为二叉树，就是简单的层序遍历而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-按之字形顺序打印二叉树</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-按之字形顺序打印二叉树/</id>
    <published>2020-01-26T10:42:46.000Z</published>
    <updated>2020-01-26T10:57:29.949Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十六篇。<br>主要知识点为二叉树，就是层序遍历的变形而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>层序遍历的思路。<br>通过队列来保存每一层的节点，方便下一层的遍历,同时本层的结果要放在本层的数组中，<br>由于要之字形进行保存，也就是说奇数层和偶数层要分别处理，所以要记录层数,用于之后的判断。</p><ul><li>单数层添加的时候插入到本层数组的后面，实现从左到右依次添加的效果;</li><li>双数层添加的时候每次插入到数组的头部，实现类似从右往左添加的效果。</li></ul><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        int levelnum = 1;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; level;</span><br><span class="line">            for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                auto a = q.front(); q.pop();</span><br><span class="line">                if(levelnum%2 == 1)&#123;</span><br><span class="line">                   level.push_back(a-&gt;val);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                   level.insert(level.begin(),a-&gt;val);   </span><br><span class="line">                &#125;</span><br><span class="line">                if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">            levelnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十六篇。&lt;br&gt;主要知识点为二叉树，就是层序遍历的变形而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-对称的二叉树</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-对称的二叉树/</id>
    <published>2020-01-26T10:25:39.000Z</published>
    <updated>2020-01-26T10:41:28.309Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十五篇。<br>主要知识点为二叉树，就是简单的判断一棵树是不是对称二叉树。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>什么时候一棵树是对称的呢？<br>首先，根节点相同；<br>其次，如果左右子树都不存在，肯定是对称的；如果左右子树只存在一个，那么肯定是不对称的。<br>如果左右子树都存在，那么左子树是对称的，右子树也是对称的。<br>最后，通过辅助函数，递归调用，问题就可以得到解决。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetrical(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        return helper(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    bool helper(TreeNode* root1,TreeNode* root2)&#123;</span><br><span class="line">        if(!root1 &amp;&amp; !root2) return true;</span><br><span class="line">        if(!root1 || !root2) return false;</span><br><span class="line">        if(root1-&gt;val != root2-&gt;val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return helper(root1-&gt;left,root2-&gt;right) &amp;&amp; helper(root1-&gt;right,root2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十五篇。&lt;br&gt;主要知识点为二叉树，就是简单的判断一棵树是不是对称二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉树的下一个节点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-二叉树的下一个节点/</id>
    <published>2020-01-26T09:52:05.000Z</published>
    <updated>2020-01-26T10:24:39.244Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十四篇。<br>主要知识点为二叉树，查找二叉树中序遍历给定节点的下一个节点。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于给定的节点，</p><ol><li>如果存在右子树，那么给定节点中序遍历的下一个节点就是右子树的最左侧节点。</li><li>如果不存在右子树，那么就可能存在两种情况，<ol><li>当前节点是根节点的左子树，那么它中序遍历的下一个节点就是它的根节点。</li><li>当前节点是根节点的右子树，那么它中序遍历的下一个节点是当前所在左子树的根节点。</li></ol></li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeLinkNode *left;</span><br><span class="line">    struct TreeLinkNode *right;</span><br><span class="line">    struct TreeLinkNode *next;</span><br><span class="line">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeLinkNode* res;</span><br><span class="line">        // 当前节点存在右子树</span><br><span class="line">        if(pNode &amp;&amp; pNode-&gt;right)&#123;</span><br><span class="line">            TreeLinkNode* temp = pNode-&gt;right;</span><br><span class="line">            while(temp-&gt;left)&#123;</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = temp;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">         // 当前节点不存在右子树，</span><br><span class="line">           TreeLinkNode* par = pNode-&gt;next;</span><br><span class="line">           while(pNode-&gt;next &amp;&amp; par-&gt;right == pNode)&#123;</span><br><span class="line">               pNode = pNode-&gt;next;</span><br><span class="line">               par  = pNode-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           res = par;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十四篇。&lt;br&gt;主要知识点为二叉树，查找二叉树中序遍历给定节点的下一个节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-删除链表中重复的结点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-删除链表中重复的结点/</id>
    <published>2020-01-26T09:12:58.000Z</published>
    <updated>2020-01-26T09:49:24.987Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十三篇。<br>主要知识点为链表的遍历，去除重复元素。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>将整个链表进行遍历，通过map来保存每个节点出现的次数。之后再重建链表，链表结点的值仅仅对应于出现一次的元素。返回新链表即可。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>可以直接在原来的链表上进行操作，具体的思路如下：<br>首先在头节点之前建立一个帮助结点，帮助结点之后的就是我们真正的没有重复结点的链表。<br>然后我们从head结点开始向后遍历，如果碰到有相同元素，那么一直向后遍历，越过这些重复元素。如果元素值没有重复，那么就都向后遍历一个节点。直到遍历结束。</p><p>下面以1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5为例进行详细说明，<br>我们开始创建辅助节点将原来的链表变成-1-&gt;1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5,<br>然后有两个指针一个指针p指向之前的头节点1，一个指针last指向辅助节点-1，开始遍历。提醒一下，他们两个操作的可是同一个链表。</p><ol><li>1!=2,所以1不重复，所以p前移指向2，last前移指向1；</li><li>2!=3,所以2不重复，所以p前移指向3，last前移指向2；</li><li>3==3，所以3是重复的，这个时候p继续前移，直到指向第一个不是3的节点，也就是4，last的next指向4.（这样的话所有的3就已经被删除了）</li><li>4==4，所以4也是重复的，这个时候p继续前移，直到指向第一个不是4的节点，也就是5，last的next指向5，(这样的话所有的4就已经被删除了)</li><li>5已经没有后继节点了，所有结束。</li></ol><p>然后整个的链表就变成了-1-&gt;1-&gt;2-&gt;5,最后结果返回-1的next即可。<br>相比于前一种思路可以极大的提高空间同时提升效率。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>本题目的目标是1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5变成1-&gt;2-&gt;5，题目等同于<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">leetcode-83-RemoveDuplicatesfromSortedListII</a><br>但是也有类似的题目是从1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5变成1-&gt;2-&gt;3-&gt;4-&gt;5。比如<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">leetcode-82-RemoveDuplicatesfromSortedList</a></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* first = new ListNode(-1);</span><br><span class="line">        first-&gt;next = head;</span><br><span class="line">        ListNode* last = first;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">           if(p-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">               //如果有重复元素，那么就跳过。</span><br><span class="line">               int val = p-&gt;val;</span><br><span class="line">               while(p &amp;&amp; p-&gt;val == val)&#123;</span><br><span class="line">                   p = p-&gt;next;</span><br><span class="line">               &#125;   </span><br><span class="line">               //此时p指向不是之前相等值的第一个元素，但是不能保证这个值也不重复，</span><br><span class="line">               //所以此时继续进入到循环之中进行判断。</span><br><span class="line">               //通过last-&gt;next = p 删除了中间值为val的所有值。</span><br><span class="line">               last-&gt;next = p;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               // 如果不重复，那就直接链接到last上。p继续后移</span><br><span class="line">               last= p;</span><br><span class="line">               p = p-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        return first-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><h3 id="扩展代码"><a href="#扩展代码" class="headerlink" title="扩展代码"></a>扩展代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        // 去掉重复元素,重复元素保留一次</span><br><span class="line">        if(!head) return NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">            if(p-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十三篇。&lt;br&gt;主要知识点为链表的遍历，去除重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-链表中环的入口节点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-链表中环的入口节点/</id>
    <published>2020-01-26T06:32:54.000Z</published>
    <updated>2020-01-26T09:11:24.060Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十二篇。<br>主要知识点为链表的遍历，同样的使用一个set就可以解决问题。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路非常清晰，从头开始遍历，遍历的时候先判断当前节点是否在set中，如果已经在，那么这个节点肯定就是那个入口节点。如果不在，继续向后遍历。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;ListNode*&gt; mset;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            if(mset.count(p)) return p;</span><br><span class="line">            mset.insert(p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十二篇。&lt;br&gt;主要知识点为链表的遍历，同样的使用一个set就可以解决问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-字符流中第一个不重复的字符</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-字符流中第一个不重复的字符/</id>
    <published>2020-01-26T06:26:41.000Z</published>
    <updated>2020-01-26T06:31:29.225Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十一篇。<br>主要知识点为字符串中每个字符的出现次数，同样的题目其实已经出现很多次了，相信大家都已经可以做到手到擒来了。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>输出描述:<br>如果当前字符流没有存在出现一次的字符，返回#字符。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于插入的每个字符都进行一次保存，然后对于每个字符出现的次数都可以通过map来保存出现次数，最后遍历一遍map找到第一个出现次数为1的字符就可以了。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string s = &quot;&quot;;</span><br><span class="line">    map&lt;char,int&gt; mmap;</span><br><span class="line">  //Insert one char from stringstream</span><br><span class="line">    void Insert(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">       s += ch;</span><br><span class="line">       if(mmap[ch])&#123;</span><br><span class="line">           mmap[ch]++;</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           mmap[ch] = 1;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //return the first appearence once char in current stringstream</span><br><span class="line">    char FirstAppearingOnce()</span><br><span class="line">    &#123;</span><br><span class="line">        for(char a:s)&#123;</span><br><span class="line">            if(mmap[a] == 1)</span><br><span class="line">               return a;</span><br><span class="line">        &#125;</span><br><span class="line">        return &apos;#&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十一篇。&lt;br&gt;主要知识点为字符串中每个字符的出现次数，同样的题目其实已经出现很多次了，相信大家都已经可以做到手到擒来了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-表示数值的字符串</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-表示数值的字符串/</id>
    <published>2020-01-26T06:11:42.000Z</published>
    <updated>2020-01-26T06:23:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十篇。<br>主要知识点为字符串，重点在于细心，认真的去判断成为数值的条件，然后再去做题就比较快。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目主要要考虑以下的问题</p><ol><li>小数点，正负号，指数标志可能会出现多次的问题。解决方式是设置一个标志，用来记录它们之前是否已经出现。</li><li>直接以小数点或者指数标志或者正负号结尾：解决方式在每个条件结束的时候进行一次是否到结尾的判断</li><li>string以‘\0’为标志结束。可以用来结束循环。</li><li>非法字符的问题。 对于前面没有处理的其他的非法情况都直接返回false</li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumeric(char* string)</span><br><span class="line">    &#123;</span><br><span class="line">        if(string == NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 应对仅仅只有+或者-的情况</span><br><span class="line">        if(*string == &apos;+&apos; || *string == &apos;-&apos;)&#123;</span><br><span class="line">            string++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //标记小数点、整数部分、指数部分是否存在，</span><br><span class="line">        bool point = false, numint = false, nume = false;</span><br><span class="line">        while(*string != &apos;\0&apos;)&#123;</span><br><span class="line">            //处理小数</span><br><span class="line">            if(*string == &apos;.&apos;)&#123;</span><br><span class="line">                if( point || nume) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                string++;</span><br><span class="line">                point = true;</span><br><span class="line">                if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //处理科学计数法</span><br><span class="line">            else if(*string == &apos;E&apos; || *string == &apos;e&apos;)&#123;</span><br><span class="line">                if(numint == false || nume)&#123;</span><br><span class="line">                     return false;</span><br><span class="line">                &#125;</span><br><span class="line">                string++; </span><br><span class="line">                nume = true;</span><br><span class="line">                if(*string == &apos;+&apos; || *string == &apos;-&apos;)&#123;</span><br><span class="line">                    string++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //处理正常数据</span><br><span class="line">            else if(*string &gt;= &apos;0&apos; &amp;&amp; *string &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                numint = true;</span><br><span class="line">                string++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十篇。&lt;br&gt;主要知识点为字符串，重点在于细心，认真的去判断成为数值的条件，然后再去做题就比较快。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-正则表达式匹配</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-正则表达式匹配/</id>
    <published>2020-01-26T05:50:50.000Z</published>
    <updated>2020-01-26T06:05:32.779Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十九篇。<br>这个题目比较难，甚至我觉得是整个剑指offer里面最难的一道题目了，<br>也是参考了网上的答案加上自己的理解来解决这道题目，no more talk, show you code!</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题目其实关注的点比较多，下面一个一个来说</p><ol><li>匹配串或者模式串为空的情况</li><li>字符串是以’\0’为标志结束的</li><li><strong>.</strong>的处理，可以表示任何一个字符,要注意此时匹配串是不是已经到了结尾</li><li><em>号的处理，由于</em>可以表示它前面的字符出现0次，1次，甚至多次，所以这个时候就会让模式串和匹配串进行不同的后续的比较。</li></ol><p>代码里面的注释写的非常清楚了，所以直接看代码吧。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool match(char* str, char* pattern)</span><br><span class="line">    &#123;</span><br><span class="line">        // 两者任意一个为空，则返回空。</span><br><span class="line">        if(str == NULL || pattern == NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return matchCore(str, pattern);</span><br><span class="line">     &#125;</span><br><span class="line">    //本部分以str = aaa 为例进行说明。</span><br><span class="line">    bool matchCore(char* str, char* pattern)&#123;</span><br><span class="line">        // 字符串和模式串都运行到了结尾，则匹配完成。返回true</span><br><span class="line">        if(*str == &apos;\0&apos; &amp;&amp; *pattern == &apos;\0&apos;)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 字符串没有到结尾，模式串到结尾了，则返回false</span><br><span class="line">        // 模式串没有到结尾，字符串到结尾了，则根据后续判断进行，需要对&apos;*&apos;做处理</span><br><span class="line">        if((*str != &apos;\0&apos; &amp;&amp; *pattern == &apos;\0&apos;))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果模式串的下一个字符是&apos;*&apos;，</span><br><span class="line">        if(*(pattern + 1) == &apos;*&apos;)&#123;</span><br><span class="line">            // 如果字符串和模式串相等，或者模式串是&apos;.&apos;，并且字符串没有到结尾，则继续匹配</span><br><span class="line">            if(*str == *pattern || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;))&#123;</span><br><span class="line">                // 可能存在三种情况。</span><br><span class="line">                // 1. *匹配前面字符0次， 如pattern = a*aaa</span><br><span class="line">                // 2. *匹配前面字符1次， 如pattern = a*aa</span><br><span class="line">                // 3. *匹配前面字符不止一次，如pattern = a*</span><br><span class="line">                return    // *匹配0次</span><br><span class="line">                    matchCore(str, pattern + 2)|| </span><br><span class="line">                          // *匹配1次</span><br><span class="line">                    matchCore(str + 1, pattern + 2) ||</span><br><span class="line">                          // *匹配不止1次</span><br><span class="line">                    matchCore(str + 1, pattern);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果字符串和模式串不相等，则跳过当前模式串的字符和&apos;*&apos;，进入新一轮的匹配</span><br><span class="line">            else&#123;</span><br><span class="line">                // 比如pattern = b*aaa</span><br><span class="line">                return matchCore(str, pattern + 2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果字符串和模式串相等，或者模式串是&apos;.&apos;，并且字符串没有到结尾，则继续匹配</span><br><span class="line">        if(*str == *pattern || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;))&#123;</span><br><span class="line">            return matchCore(str + 1, pattern + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十九篇。&lt;br&gt;这个题目比较难，甚至我觉得是整个剑指offer里面最难的一道题目了，&lt;br&gt;也是参考了网上的答案加上自己的理解来解决这道题目，no more talk, show you code!&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="hard" scheme="http://yoursite.com/tags/hard/"/>
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="正则表达" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-构建乘积数组</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-构建乘积数组/</id>
    <published>2020-01-26T03:37:35.000Z</published>
    <updated>2020-01-26T03:57:30.390Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十八篇。<br>主要知识点为数组，但是可以通过类似于矩阵的方式来进行性能的提升。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>暴力求解，双层循环，对每个结果进行单独的计算即可。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>其实我们在计算的时候可以发现很多计算是重复的，举例来说<br>1, 2, 3, 4, 5<br>计算第一个数字的时候是2*3*4*5,<br>计算第二个数字的时候是1*3*4*5,<br>计算第三个数字的时候是1*2*4*5,<br>计算第四个数字的时候是1*2*3*5,<br>计算第五个数字的时候是1*2*3*4。<br>这样就可以发现很多运算是重复的，比如第一行的3<em>4</em>5和第二行的3<em>4</em>5，<br>如何去掉重复的计算呢？就是我们接下来要考虑的问题。<br>同样以1, 2, 3, 4, 5为例来进行说明，我们可以发现同一行的计算可以分成左右两个部分。<br>计算第一个数字的时候是(1)*(2*3*4*5),<br>计算第二个数字的时候是(1*1)*(3*4*5),<br>计算第三个数字的时候是(1*2*1)*(4*5),<br>计算第四个数字的时候是(1*2*3*1)*(5),<br>计算第五个数字的时候是(1*2*3*4*1)()。<br>左面括号中下一行的数字是上一行的数字再乘上一个数字，<br>右面括号中上一行的数字是下一行的数组再乘上一个数字。<br>而最终的结果就是左边的括号乘上右面的括号。<br>非常优秀的思路。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        //  方法1: 双层遍历 O(n^2)</span><br><span class="line">        vector&lt;int&gt; res ;</span><br><span class="line">        int temp = 1;</span><br><span class="line">        for(int i  = 0;i&lt; A.size();i++)&#123;</span><br><span class="line">            for(int j = 0; j&lt; A.size(); j++)&#123;</span><br><span class="line">                if(i != j)&#123;</span><br><span class="line">                   temp = A[j] *temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            temp = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n^2),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        //  方法2: 巧妙运用一下前一次和后一次的关系</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;int&gt; left = &#123;1&#125;;</span><br><span class="line">        vector&lt;int&gt; right = &#123;1&#125;;</span><br><span class="line">        for(int i = 1; i &lt;= A.size()-1; i++)&#123;</span><br><span class="line">            left.push_back(left.back()* A[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for( int i = A.size()-2; i&gt;=0;i--)&#123;</span><br><span class="line">            right.insert(right.begin(),right.front()*A[i+1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i&lt;A.size();i++)&#123;</span><br><span class="line">            res.push_back(left[i] * right[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十八篇。&lt;br&gt;主要知识点为数组，但是可以通过类似于矩阵的方式来进行性能的提升。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数组中重复的数字</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-数组中重复的数字/</id>
    <published>2020-01-26T03:22:44.000Z</published>
    <updated>2020-01-26T03:35:26.708Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十七篇。<br>主要知识点为数组，找数组中重复的数字，类似于之前找出现一次或者两次的数字。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>找个set来存一下之前出现过的数据，然后在新遍历到数据的时候只要先看一下set中有没有存在，若存在，则直接返回即可，若不存在，将这个数据放到set中，继续向后遍历。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // Parameters:</span><br><span class="line">    //        numbers:     an array of integers</span><br><span class="line">    //        length:      the length of array numbers</span><br><span class="line">    //        duplication: (Output) the duplicated number in the array number</span><br><span class="line">    // Return value:       true if the input is valid, and there are some duplications in the array number</span><br><span class="line">    //                     otherwise false</span><br><span class="line">    bool duplicate(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; mset;</span><br><span class="line">        for(int i = 0; i&lt;length; i++)&#123;</span><br><span class="line">            if(!mset.count(numbers[i]))&#123;</span><br><span class="line">                mset.insert(numbers[i]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十七篇。&lt;br&gt;主要知识点为数组，找数组中重复的数字，类似于之前找出现一次或者两次的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-把字符串转化成整数</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E6%88%90%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-把字符串转化成整数/</id>
    <published>2020-01-26T03:12:36.000Z</published>
    <updated>2020-01-26T03:20:27.806Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十六篇。<br>主要知识点为字符串的判断和边界条件的判定，细心一点就没有问题。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br>输入描述:<br>输入一个字符串,包括数字字母符号,可以为空<br>输出描述:<br>如果是合法的数值表达则返回该数字，否则返回0</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题目需要考虑的边界有以下几个：</p><ol><li>正负号的判定</li><li>数字中间可能有非法字符</li><li>数字结果可能会超出INT类型的范围。<br>考虑好以上几个边界本题目就可以得到解决。</li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int StrToInt(string str) &#123;</span><br><span class="line">       if(str.size() == 0) return 0;</span><br><span class="line">       int flag  = 0; //默认正数</span><br><span class="line">       if(str[0] == &apos;+&apos;)&#123;</span><br><span class="line">           flag = 1;</span><br><span class="line">       &#125;else if(str[0] == &apos;-&apos;)&#123;</span><br><span class="line">           flag = 2;</span><br><span class="line">       &#125;</span><br><span class="line">       int start = flag&gt;0?1:0;</span><br><span class="line">       long res = 0;</span><br><span class="line">       while(start &lt; str.size())&#123;</span><br><span class="line">           if(str[start]&gt;&apos;0&apos; &amp;&amp; str[start] &lt;&apos;9&apos;)&#123;</span><br><span class="line">               res = res*10 + (str[start]-&apos;0&apos;);</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           start++;</span><br><span class="line">       &#125;</span><br><span class="line">       res = (flag == 2)?(-res):res;</span><br><span class="line">       //判断是否出现溢出</span><br><span class="line">       if(res &gt;INT_MAX || res &lt; INT_MIN)&#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十六篇。&lt;br&gt;主要知识点为字符串的判断和边界条件的判定，细心一点就没有问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-不用加减乘除做加法</title>
    <link href="http://yoursite.com/2020/01/25/%E5%89%91%E6%8C%87offer-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
    <id>http://yoursite.com/2020/01/25/剑指offer-不用加减乘除做加法/</id>
    <published>2020-01-25T13:02:14.000Z</published>
    <updated>2020-01-26T03:10:43.389Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十五篇。<br>主要知识点为位运算，思路非常神奇，可以打破我们的思维定势。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="">题目描述</a></h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>当我们计算两个数字之和的时候，实际上一方面我们计算两个数当前位的加法运算，另一方面是计算当前位的进位运算，本题目我们采用同样的思路来对二进制进行计算，当前位的计算用位的异或操作，具体操作为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1^1 = 0; 1^0 = 1; 0^1 = 1; 0^0 = 0;</span><br></pre></td></tr></table></figure><p>而进位运算通过位的与运算来进行计算，具体操作为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&amp;1 = 1; 1&amp;0 = 0; 0&amp;1 = 0; 0&amp;0 = 0;</span><br></pre></td></tr></table></figure><p>下面我们举例来进行说明：<br>比如2+4变成二进制为010和100，<br>这样直接通过位的异或计算当前位就是110，而进位计算010&amp;100 = 0，<br>所以最终计算结果的二进制就是110，也就是6；</p><p>比如2+6，它们的二进制分别为010和110，<br>计算当前位为010^110= 100,计算进位010&amp;110=010。<br>由于是进的位，所以在进行下一步计算的时候，进位结果要左移一位之后再来和之前的计算结果进行计算，<br>所以当前位运算结果变为100^100 = 000,进位结果变为100&amp;100 = 100，<br>进位结果继续左移1位得到1000，和原来当前位数字000进行异或计算得到0000^1000=1000，而进位0000&amp;1000 = 0，运算结束。<br>所以最后结果就是1000也就是8。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Add(int num1, int num2)</span><br><span class="line">    &#123;</span><br><span class="line">        //return num1+num2;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        while(num2 != 0)&#123;</span><br><span class="line">            temp = num1^num2;</span><br><span class="line">            num2 = (num1&amp;num2)&lt;&lt;1;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十五篇。&lt;br&gt;主要知识点为位运算，思路非常神奇，可以打破我们的思维定势。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="位运算" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-扑克牌顺子</title>
    <link href="http://yoursite.com/2020/01/25/%E5%89%91%E6%8C%87offer-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/"/>
    <id>http://yoursite.com/2020/01/25/剑指offer-扑克牌顺子/</id>
    <published>2020-01-25T12:30:55.000Z</published>
    <updated>2020-01-25T13:00:04.249Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十四篇。<br>没有用到啥比较厉害的算法，主要还是学习一下思路,有思路事情就变得的非常简单啦。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=11198&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于大小王可以替代任何牌，所以我们对这次要单独处理。<br>然后我们找到抽到的排面中最小且不为0的数字，<br>然后开始依次找其他四个比它大且构成顺子的四张牌。如果有对应的牌，那么就继续判断下一张；<br>如果没有对应的牌，但是有0，就意味着可以用小王来替换对应的牌，然后继续判断下一张；<br>如果既没有对应的牌，然后也没有大小王可以用来替换，那么肯定就不能构成顺子，就直接返回false即可。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">        int zeros = count(numbers.begin(),numbers.end(),0);</span><br><span class="line">        int mmin = INT_MAX;</span><br><span class="line">        for(int i:numbers)&#123;</span><br><span class="line">            if(i != 0 &amp;&amp; i&lt;mmin)&#123;</span><br><span class="line">                mmin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i&lt;5;i++)&#123;</span><br><span class="line">            if(count(numbers.begin(),numbers.end(),mmin+i))&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;else if(zeros &gt; 0)&#123;</span><br><span class="line">                zeros--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十四篇。&lt;br&gt;没有用到啥比较厉害的算法，主要还是学习一下思路,有思路事情就变得的非常简单啦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
</feed>
