<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingwen&#39;s blog</title>
  
  <subtitle>没有输出的输入是不完整的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-12-04T11:14:29.693Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李庆文</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>restrict-iP-under-linux</title>
    <link href="http://yoursite.com/2023/12/04/restrict-ip-under-linux/"/>
    <id>http://yoursite.com/2023/12/04/restrict-ip-under-linux/</id>
    <published>2023-12-04T11:00:00.000Z</published>
    <updated>2023-12-04T11:14:29.693Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何通过配置ip白名单和黑名单限制linux访问ip,从而保障安全。</p><a id="more"></a><ol><li>白名单</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts.allow</span><br><span class="line"></span><br><span class="line"># 配置允许单个ip可登陆</span><br><span class="line">sshd:216.64.87.126:allow</span><br><span class="line"></span><br><span class="line"># 配置子网内所有ip可登陆</span><br><span class="line">sshd:216.64.87.0&#x2F;24:allow</span><br></pre></td></tr></table></figure><ol start="2"><li>黑名单</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts.deny</span><br><span class="line"></span><br><span class="line"># 配置单个ip不可登陆</span><br><span class="line">sshd:216.64.87.126:allow</span><br><span class="line"></span><br><span class="line"># 配置子网内所有ip不可登陆</span><br><span class="line">sshd:216.64.87.0&#x2F;24:allow</span><br></pre></td></tr></table></figure><ol start="3"><li>配置生效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure><ol start="4"><li>参考链接<br><a href="https://www.cnblogs.com/lcword/p/14371300.html" target="_blank" rel="noopener">linux下限制ip访问</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何通过配置ip白名单和黑名单限制linux访问ip,从而保障安全。&lt;/p&gt;
    
    </summary>
    
    
      <category term="疑难杂症" scheme="http://yoursite.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Download-Microsoft-Remote-Desktop-for-MacOS</title>
    <link href="http://yoursite.com/2023/12/01/Download-Microsoft-Remote-Desktop-for-MacOS/"/>
    <id>http://yoursite.com/2023/12/01/Download-Microsoft-Remote-Desktop-for-MacOS/</id>
    <published>2023-12-01T05:42:39.000Z</published>
    <updated>2023-12-01T05:54:35.925Z</updated>
    
    <content type="html"><![CDATA[<p>本文将分享在Mac系统安装Microsoft Remote Desktop方法。</p><a id="more"></a><p>由于苹果账号的地域限制，中国用户不能在app store直接下载用于访问远程桌面的Microsoft remote desktop for macos.<br>因此从网上找到了下载链接。</p><p><a href="https://go.microsoft.com/fwlink/?linkid=868963" target="_blank" rel="noopener">Microsoft Remote Desktop for MacOS链接</a><br>感谢文章<a href="https://blog.csdn.net/Jason_WangYing/article/details/109080206" target="_blank" rel="noopener">Microsoft Remote Desktop for MacOS 在线下载</a>的分享。</p><p>同时，为了防止在线资源失效，我已将下载好的资源包上传至阿里云盘，大家可通过下面的阿里云盘分享链接直接下载。</p><p><a href="https://www.alipan.com/s/5t33zb4KGxZ" target="_blank" rel="noopener">Microsoft Remote Desktop for MacOS 阿里云盘链接</a></p><p>下载安装完毕就可以直接使用啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将分享在Mac系统安装Microsoft Remote Desktop方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="精品宝藏" scheme="http://yoursite.com/categories/%E7%B2%BE%E5%93%81%E5%AE%9D%E8%97%8F/"/>
    
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
      <category term="remote desktop" scheme="http://yoursite.com/tags/remote-desktop/"/>
    
  </entry>
  
  <entry>
    <title>bug-GPG-error-bookworm-InRelease-is-not-signed</title>
    <link href="http://yoursite.com/2023/11/30/bug-GPG-error-bookworm-InRelease-is-not-signed/"/>
    <id>http://yoursite.com/2023/11/30/bug-GPG-error-bookworm-InRelease-is-not-signed/</id>
    <published>2023-11-30T06:29:13.000Z</published>
    <updated>2023-11-30T06:48:48.932Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍使用python-slim执行apt-get update时候碰到的GPG error问题。</p><a id="more"></a><ol><li>现象描述</li></ol><p>基于如下Dockerfile构建目标镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.12-slim</span><br><span class="line">...</span><br><span class="line">RUN apt-get update</span><br></pre></td></tr></table></figure><p>碰到类似如下描述的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W: GPG error: http:&#x2F;&#x2F;deb.debian.org&#x2F;debian bookworm InRelease: The following signatures couldn&#39;t be verified because the public key is not available: NO_PUBKEY 0E98404D386FA1D9 NO_PUBKEY 6ED0E7B82643E131 NO_PUBKEY F8D2585B8783D481</span><br><span class="line">E: The repository &#39;http:&#x2F;&#x2F;deb.debian.org&#x2F;debian bookworm InRelease&#39; is not signed.</span><br></pre></td></tr></table></figure><ol start="2"><li>原因</li></ol><blockquote><p>It is Docker with libseccomp so a newer syscall used in Debian Bookworm packages/libs is being blocked. libseccomp lets you configure allowed syscalls for a process. Docker sets a default seccomp profile for all containers such that only certain syscalls are allowed and everything else is blocked (so, newer syscalls that are not yet known to libseccomp or docker are blocked).<br><a href="https://github.com/docker-library/python/issues/837" target="_blank" rel="noopener">python:3.9 - Failed run apt update from the last version of the image #837</a></p></blockquote><p>简单解释就是官方的Python镜像升级，构建python镜像的基础镜像从原来的debian10 buster升级到debian12 bookworm, 在此情况下很多bookworm采用的新的系统调用被libseccomp屏蔽掉了，因此执行报错。</p><ol start="3"><li>解决方案<br>本人采用的解决方案为更新基础镜像。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># FROM python:3.12-slim</span><br><span class="line">FROM python:3.12-slim-bullseye</span><br></pre></td></tr></table></figure><p>其他可能可行的解决方案</p><ul><li>Update libseccomp and docker on the host running the containers.</li><li>Add the following in the Dockerfile:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN mv -i &#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;debian-archive-*.asc  &#x2F;root&#x2F;</span><br><span class="line">RUN ln -s &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;debian-archive-* &#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;</span><br></pre></td></tr></table></figure><ol start="4"><li>参考链接<br><a href="https://stackoverflow.com/questions/76955036/build-started-failing-using-python3-8-docker-image-on-apt-get-update-and-instal" target="_blank" rel="noopener">stackoverflow-Build started failing using Python:3.8 Docker image on apt-get update and install with GPG error: bookworm InRelease is not signed</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍使用python-slim执行apt-get update时候碰到的GPG error问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="疑难杂症" scheme="http://yoursite.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="bug" scheme="http://yoursite.com/tags/bug/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="debian" scheme="http://yoursite.com/tags/debian/"/>
    
  </entry>
  
  <entry>
    <title>centos安装python</title>
    <link href="http://yoursite.com/2023/11/29/install-python-on-centos/"/>
    <id>http://yoursite.com/2023/11/29/install-python-on-centos/</id>
    <published>2023-11-29T12:02:00.000Z</published>
    <updated>2023-11-29T13:37:56.870Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何在centos系统通过源码安装最新的python.</p><a id="more"></a><p>python10以上要求openssl的版本要大于1.1，centos默认安装的openssl为1.0，因此需要首先更新默认的openssl</p><h2 id="更新openssl">更新openssl</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 检查默认openssl</span><br><span class="line">which openssl</span><br><span class="line">openssl version</span><br><span class="line"></span><br><span class="line"># 下载并解压openssl源码 </span><br><span class="line">wget https:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.1.1o.tar.gz</span><br><span class="line">tar -xzvf openssl-1.1.1o.tar.gz &amp;&amp; cd openssl-1.1.1o&#x2F;</span><br><span class="line"></span><br><span class="line"># 编译安装</span><br><span class="line">.&#x2F;config --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openssl</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"># 更新软连接</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;openssl&#x2F;bin&#x2F;openssl &#x2F;usr&#x2F;bin&#x2F;openssl</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;openssl&#x2F;lib&#x2F;libssl.so.1.1 &#x2F;usr&#x2F;lib64&#x2F;libssl.so.1.1</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;openssl&#x2F;lib&#x2F;libcrypto.so.1.1 &#x2F;usr&#x2F;lib64&#x2F;libcrypto.so.1.1</span><br><span class="line"></span><br><span class="line"># 检查此时的openssl</span><br><span class="line">openssl version</span><br></pre></td></tr></table></figure><h2 id="安装python">安装python</h2><p>在centos系统中下载源码，如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># python版本下载地址为[python download](https:&#x2F;&#x2F;www.python.org&#x2F;downloads&#x2F;)，自行选择目标python版本 </span><br><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.12.0&#x2F;Python-3.12.0.tgz </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf Python-3.12.0.tgz &amp;&amp; cd Python-3.12.0</span><br><span class="line"></span><br><span class="line"># 编译安装</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3.12.0 --with-openssl&#x3D;&#x2F;usr&#x2F;local&#x2F;openssl </span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"># 添加软连接</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3.12.0&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3.12.0&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip3</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">python3 -v</span><br></pre></td></tr></table></figure><p>安装成功！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何在centos系统通过源码安装最新的python.&lt;/p&gt;
    
    </summary>
    
    
      <category term="必备技能" scheme="http://yoursite.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>change-pip-source-in-dockerfile</title>
    <link href="http://yoursite.com/2023/08/28/change-pip-source-in-dockerfile/"/>
    <id>http://yoursite.com/2023/08/28/change-pip-source-in-dockerfile/</id>
    <published>2023-08-28T11:44:57.000Z</published>
    <updated>2023-08-28T12:38:45.408Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将介绍如何在Dockerfile中更新pip源。</p><a id="more"></a><p>首先新建项目文件夹test,包含用于构建镜像的Dockerfile文件和设置pip源信息的pip.conf文件。</p><h2 id="目录结构">目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">touch Dockerfile pip.conf</span><br></pre></td></tr></table></figure><h3 id="更新pip-conf文件">更新pip.conf文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">timeout &#x3D; 120</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">trusted-host &#x3D; pypi.tuna.tsinghua.edu.cn</span><br><span class="line"></span><br><span class="line">[search]</span><br><span class="line">index &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure><h3 id="更新Dockerfile文件">更新Dockerfile文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7-slim</span><br><span class="line"></span><br><span class="line"># replace python pip source</span><br><span class="line">COPY pip.conf &#x2F;etc&#x2F;pip.conf</span><br><span class="line"></span><br><span class="line">RUN pip3 install flask redis</span><br><span class="line"></span><br><span class="line">#其他Dockefile的命令...</span><br><span class="line"></span><br><span class="line">CMD [&quot;python3&quot;,&quot;main.py&quot;]</span><br></pre></td></tr></table></figure><h2 id="编译执行">编译执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd test</span><br><span class="line">docker build -t gateway:v0.1 .</span><br></pre></td></tr></table></figure><p>编译成功，即可实现在镜像中使用pip命令安装对应的软件库。<br>如果自己主机的pip源要更新，则只需要用本文中的pip.conf文件替换掉自己机器对应的文件即可。<br>bingo！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章将介绍如何在Dockerfile中更新pip源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="pip" scheme="http://yoursite.com/tags/pip/"/>
    
      <category term="Dockerfile" scheme="http://yoursite.com/tags/Dockerfile/"/>
    
  </entry>
  
  <entry>
    <title>check-login-without-password</title>
    <link href="http://yoursite.com/2022/03/03/check-login-without-password/"/>
    <id>http://yoursite.com/2022/03/03/check-login-without-password/</id>
    <published>2022-03-03T10:37:43.000Z</published>
    <updated>2022-03-03T11:19:29.137Z</updated>
    
    <content type="html"><![CDATA[<p>通过find命令查找authorized_keys文件来查询系统内是否存在免密登陆情况。</p><a id="more"></a><h2 id="原理说明">原理说明</h2><p>机器A某用户如果要免秘登陆到机器B，则需要在机器A上通过类似ssh-keygen -t rsa的命令生成公钥和私钥，然后将公钥发送到机器B对应用户目录下的.ssh目录下的authorized_keys文件中。<br>所以反推，若想查看是否存在免密登陆，则只需要查看系统用户目录下是否存在authorized_keys目录即可。</p><h2 id="详细命令">详细命令</h2><h3 id="root用户">root用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;root -name  authorized_keys</span><br></pre></td></tr></table></figure><h3 id="普通用户">普通用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;home&#x2F;*&#x2F;.ssh -name authorized_keys</span><br></pre></td></tr></table></figure><p>为保证系统的安全性，在确认没有必要的情况下 直接通过rm -rf<br>命令删除对应的文件即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过find命令查找authorized_keys文件来查询系统内是否存在免密登陆情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>golang-bug-sf-IsExported-undefined</title>
    <link href="http://yoursite.com/2022/03/03/golang-bug-sf-IsExported-undefined/"/>
    <id>http://yoursite.com/2022/03/03/golang-bug-sf-IsExported-undefined/</id>
    <published>2022-03-03T04:30:47.000Z</published>
    <updated>2022-03-03T04:45:35.439Z</updated>
    
    <content type="html"><![CDATA[<p>通过升级golang版本为1.17.X解决sf.IsExported undefined问题。</p><a id="more"></a><h2 id="问题描述">问题描述</h2><p>在编写项目的时候，通过go build命令生成可执行二进制文件时候，碰见sf.IsExported undefined问题。</p><p>经过查询,主要是<a href="https://github.com/kubernetes-sigs/controller-tools/issues/643" target="_blank" rel="noopener">github-issue</a>，可以发现大概率是golang版本问题，问题出现在golang1.16.X。</p><h2 id="解决方案">解决方案</h2><p>升级系统内golang版本为golang1.17.X即可。</p><p>但是考虑到系统内其他的项目可能仍然需要原来的golang1.16版本,所以要设置系统对于多版本golang的支持。</p><h2 id="详细命令">详细命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;go.dev&#x2F;dl&#x2F;go1.17.7.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -C &#x2F;usr&#x2F;local&#x2F;go117 -xzvf go1.17.7.linux-amd64.tar.gz </span><br><span class="line"></span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;go117&#x2F;go&#x2F;bin &#x2F;usr&#x2F;bin&#x2F;go117</span><br></pre></td></tr></table></figure><p>升级完成后可以通过如下方式查看目前系统内的golang命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br><span class="line">go117 version</span><br></pre></td></tr></table></figure><p>通过go117 build命令重新编译项目，上述碰到的问题得到解决。</p><p>PS: 一定要善于使用搜索引擎啊！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过升级golang版本为1.17.X解决sf.IsExported undefined问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="bug-records" scheme="http://yoursite.com/categories/bug-records/"/>
    
    
      <category term="bug" scheme="http://yoursite.com/tags/bug/"/>
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Centos系统中安装golang环境</title>
    <link href="http://yoursite.com/2021/08/05/Install-golang-in-centos-system/"/>
    <id>http://yoursite.com/2021/08/05/Install-golang-in-centos-system/</id>
    <published>2021-08-05T07:58:17.000Z</published>
    <updated>2021-08-05T08:03:05.698Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何在centos系统中安装golang环境。</p><a id="more"></a><h2 id="一、centos安装golang环境流程">一、centos安装golang环境流程</h2><h3 id="1、golang仓库选择合适的package">1、golang仓库选择合适的package</h3><p>从如下两个网址中选择适合自己机器的package,右键复制链接地址得到对应package的下载地址。重点关注第二个网址，这也是写本文的目的。</p><ul><li><a href="https://golang.org/dl/" target="_blank" rel="noopener">golang官方仓库</a></li><li><a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">golang-Google仓库</a></li></ul><h3 id="2、服务器下载">2、服务器下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget  https:&#x2F;&#x2F;golang.google.cn&#x2F;dl&#x2F;go1.16.6.linux-amd64.tar.gz # 前面复制的目标package的下载网址。</span><br><span class="line">rm -rf &#x2F;usr&#x2F;local&#x2F;go </span><br><span class="line">tar -C &#x2F;usr&#x2F;local -xzf go1.16.6.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="3、将go相关命令添加到环境变量中">3、将go相关命令添加到环境变量中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line"># 添加如下内容</span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin </span><br><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><h3 id="4、golang环境确认">4、golang环境确认</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure><h2 id="二、参考文档。">二、参考文档。</h2><ol><li><a href="https://golang.org/doc/install" target="_blank" rel="noopener">golang-doc-install</a></li><li><a href="https://www.runoob.com/go/go-environment.html" target="_blank" rel="noopener">golang环境安装</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何在centos系统中安装golang环境。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux系统" scheme="http://yoursite.com/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>Goland配置默认文件头信息</title>
    <link href="http://yoursite.com/2021/01/18/goland-default-header-information/"/>
    <id>http://yoursite.com/2021/01/18/goland-default-header-information/</id>
    <published>2021-01-18T07:44:52.000Z</published>
    <updated>2021-01-18T07:49:51.743Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了如何给Goland编辑器配置文件头的默认信息。</p><a id="more"></a><p>点击Goland-&gt;Preference进入goland配置页面。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20210118154352.png" alt=""><br>一图搞定！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了如何给Goland编辑器配置文件头的默认信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Goland" scheme="http://yoursite.com/tags/Goland/"/>
    
  </entry>
  
  <entry>
    <title>curl命令下载资源速度缓慢解决方案</title>
    <link href="http://yoursite.com/2020/12/15/curl%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90%E9%80%9F%E5%BA%A6%E7%BC%93%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2020/12/15/curl%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90%E9%80%9F%E5%BA%A6%E7%BC%93%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-12-15T01:43:47.000Z</published>
    <updated>2020-12-15T02:20:24.694Z</updated>
    
    <content type="html"><![CDATA[<p>在服务器下载资源往往会通过curl或者wget命令，但是有时部分资源会因为网络问题下载缓慢甚至直接下载失败。<br>本文提出三种解决方案来解决这个问题。</p><a id="more"></a><h2 id="修改hosts文件解决DNS污染问题">修改hosts文件解决DNS污染问题</h2><p>类似于githubusercontent.com等网站会因为dns解析失败而不能访问成功。此时我们可以通过修改hosts文件来解决这个问题。</p><ol><li>打开网站<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">ipaddress</a>，输入不能访问的资源的地址，获取对应地址的ip地址。比如我们输入raw.githubusercontent.com网站<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20201215095532.png" alt=""><br><img src="https://cdn.kingwen.cn/qiniu_kwimg20201215095655.png" alt=""><br>可以看到对应的ip地址为199.232.96.133</li></ol><p>此时，我们修改/etc/hosts文件，在文件的最后添加如下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">199.232.96.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><p>从而事情就可以得到解决。</p><p>为方便大家使用，github的<a href="https://github.com/hawtim/blog/issues/10" target="_blank" rel="noopener">解决curl connection refused问题</a>的issue已经为我们总结了常见的几个更改的网址，我一并放在此处供大家使用，直接拷贝并追加到/etc/hosts文件中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">199.232.68.133 raw.githubusercontent.com</span><br><span class="line">199.232.68.133 user-images.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars2.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure><h2 id="下载源码自行编译">下载源码自行编译</h2><p>有些package会提供多种方式供大家下载使用，比如yum安装、apt-get安装、brew安装，curl下载后sh安装。<br>除此之外，其实还有一种常见的安装方式就是项目会提供源代码，然后用户下载后自行通过make命令进行编译，之后再将对应的二进制执行程序复制到/usr/local/bin目录下。</p><h2 id="其他主机拷贝">其他主机拷贝</h2><p>可以通过scp命令将其他主机已经安装好的二进制文件复制到本机。相关scp的使用说明可以参见文章<a href="https://www.runoob.com/linux/linux-comm-scp.html" target="_blank" rel="noopener">Linux scp命令</a></p><p>我暂时知道的解决方式就上面三种，如果以后有其他方式可以再补充吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在服务器下载资源往往会通过curl或者wget命令，但是有时部分资源会因为网络问题下载缓慢甚至直接下载失败。&lt;br&gt;
本文提出三种解决方案来解决这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="curl" scheme="http://yoursite.com/tags/curl/"/>
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>cron表达式学习</title>
    <link href="http://yoursite.com/2020/12/09/learn-cron-expression/"/>
    <id>http://yoursite.com/2020/12/09/learn-cron-expression/</id>
    <published>2020-12-09T02:10:34.000Z</published>
    <updated>2020-12-09T02:22:49.879Z</updated>
    
    <content type="html"><![CDATA[<p>Cron语法经常用于定时任务的设定，如定时进行数据采集任务，定时进行数据备份任务等。<br>本文对cron表达式进行了简单介绍。</p><a id="more"></a><h2 id="语法说明">语法说明</h2><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201208212253.png" alt=""></p><ol><li>每个cron指令一般包含5个部分，分别对应分钟、小时、天、月、周。 每个部分用空格隔开。</li><li>每个部分的通用标志。</li></ol><ul><li>* : 表示任意值</li><li>, ：表示值的列表</li><li>- ：表示值的范围</li><li>/ ：表示值的步长</li></ul><ol start="3"><li>每个值的取值范围</li></ol><ul><li>分钟： 0 - 59</li><li>小时：0 - 23</li><li>天：1 - 31</li><li>月：1 - 12</li><li>周：0 - 6</li></ul><h2 id="举例说明">举例说明</h2><ol><li>每隔十分钟执行一次</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#x2F;10 * * * *</span><br></pre></td></tr></table></figure><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201208231301.png" alt=""><br>2. 双月中每周一周二的前两个小时每隔5分钟执行一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#x2F;5 0-2 * *&#x2F;2 1,2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201208231642.png" alt=""></p><h2 id="后续更新">后续更新</h2><p>本部分参考盖若博主的文章，属于cron语法使用的升级版。</p><ol><li>如果cron表达式中有6个值，则第一个表示秒。</li><li>如果cron表示式中有7个值，则最后一个表示年。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20201209100616.png" alt=""><br><img src="https://cdn.kingwen.cn/qiniu_kwimg20201209100647.png" alt=""></li></ol><h2 id="参考链接">参考链接</h2><ol><li><a href="https://crontab.guru/#*_*_*_*_*" target="_blank" rel="noopener">在线解析crontab guru</a></li><li><a href="https://www.gairuo.com/p/cron-expression-sheet" target="_blank" rel="noopener">盖若-Cron 定时任务表达式手册</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cron语法经常用于定时任务的设定，如定时进行数据采集任务，定时进行数据备份任务等。&lt;br&gt;
本文对cron表达式进行了简单介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="cron" scheme="http://yoursite.com/tags/cron/"/>
    
      <category term="自动化" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>jupyter设置多编程语言支持</title>
    <link href="http://yoursite.com/2020/10/17/jupyter%E8%AE%BE%E7%BD%AE%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/"/>
    <id>http://yoursite.com/2020/10/17/jupyter%E8%AE%BE%E7%BD%AE%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/</id>
    <published>2020-10-17T12:28:47.000Z</published>
    <updated>2020-10-17T12:39:14.290Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要介绍如何设置jupyter notebook使其在支持python的基础上支持octave和R语言。</p><a id="more"></a><p><a href="https://github.com/jupyter/notebook" target="_blank" rel="noopener">jupyter notebook</a>是目前应用非常广泛的一个软件。它最大的亮点在于让用户可以即时编码，即时测试，即时调整，而且支持超过40种编程语言，详情可参考<a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="noopener">jupyter-kernels-list</a>。</p><h2 id="设置多编程语言支持">设置多编程语言支持</h2><h3 id="octave支持">octave支持</h3><ol><li>首先本地要安装octave, mac用户可以直接通过如下命令安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install octave</span><br></pre></td></tr></table></figure><p>其他系统可以自行参考<a href="https://www.gnu.org/software/octave/download" target="_blank" rel="noopener">octave安装教程</a><br>2. 安装jupyter和octave进行交互的octave_kernel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install octave_kernel</span><br></pre></td></tr></table></figure><p>更多细节可以参考<a href="https://github.com/Calysto/octave_kernel/blob/master/README.rst" target="_blank" rel="noopener">octave_kernel-Github</a></p><h3 id="R语言支持">R语言支持</h3><ol><li>本地安装R语言环境</li></ol><p>下载连接 <a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/" target="_blank" rel="noopener">tsinghua-cran-download</a></p><p>R语言官网<a href="https://www.r-project.org/" target="_blank" rel="noopener">R-project</a></p><ol start="2"><li>配置R语言kernel</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 进入R语言console</span><br><span class="line">R</span><br><span class="line"># 安装kernel</span><br><span class="line">install.packages(&#39;IRkernel&#39;)</span><br><span class="line">选择合适的源即可。</span><br><span class="line"># 为系统所有用户安装</span><br><span class="line">IRkernel::installspec(user &#x3D; FALSE)</span><br></pre></td></tr></table></figure><h3 id="查看jupyter的内核支持">查看jupyter的内核支持</h3><ol><li>通过命令行查看</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter kernelspec list</span><br></pre></td></tr></table></figure><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016145435.png" alt=""></p><p>2.通过打开notebook新建文件来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016145812.png" alt=""></p><h2 id="bug记录">bug记录</h2><ol><li>configurations are cuurently only defined for the following language:</li></ol><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016114704.png" alt=""></p><ul><li>问题描述</li></ul><p>这个问题出现在我为本地jupyter新添加了R语言和octave语言的kernel.但是当我新建一个对应的文件的时候，就报错上面的错误。</p><ul><li>解决措施</li></ul><p>问题出现在autopep8插件上，这个插件仅仅支持python，所以在使用其他语言的时候就会报错，所以当我们在编写其他语言相关的文件时候，我们将这个插件关掉即可。</p><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016113535.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要介绍如何设置jupyter notebook使其在支持python的基础上支持octave和R语言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具推荐" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="jupyter" scheme="http://yoursite.com/tags/jupyter/"/>
    
      <category term="octave" scheme="http://yoursite.com/tags/octave/"/>
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>七牛云+PicGo制作博客图床</title>
    <link href="http://yoursite.com/2020/09/11/%E4%B8%83%E7%89%9B%E4%BA%91-PicGo%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/"/>
    <id>http://yoursite.com/2020/09/11/%E4%B8%83%E7%89%9B%E4%BA%91-PicGo%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/</id>
    <published>2020-09-11T11:54:19.000Z</published>
    <updated>2020-09-11T13:06:19.670Z</updated>
    
    <content type="html"><![CDATA[<p>用七牛云和PicGo给博客的图片安了一个家，七牛云真香！</p><a id="more"></a><p>对于所有写博客的同学来说，图床是一个必须要考虑的事情，最好图床可以稳定、便宜还要好用。</p><p>我从写博客以来，用过微博的图床(后来外链关闭了)，用过github搭建过图床（访问速度堪忧），用过简书做图床(平台现在越做越差)，后来就直接用有道云笔记了（但是只能自己看），一路走来，充满坎坷。</p><p>最近刚好有点时间，我就把自己的域名和服务器重新认证了一下，准备以后好好做点东西，所以图床的事情也必须要搞一下，于是本篇文章应运而生！</p><h2 id="前期准备">前期准备</h2><ol><li><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGO</a>：到releases下载最新版本的符合自己电脑的安装包，下载即可。注意下载的是稳定版本还是试用版本，带有beta的都是试用版本。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911200650.png" alt=""></li><li><a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a>对象存储：在七牛云新建存储空间，用来保存图片即可。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911201552.png" alt=""></li><li>实名认证后的域名。可以通过腾讯云或者阿里云进行域名购买，然后记得要到工信部认证。否则是不能对外提供服务的。</li></ol><h2 id="具体步骤">具体步骤</h2><h3 id="1-设置七牛云存储">1.设置七牛云存储</h3><ol><li>对象存储-&gt;空间管理-&gt;新建空间<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911201447.png" alt=""></li></ol><ul><li>存储空间名称：名称自定义即可。要注意长度</li><li>存储区域：自己选一个离自己比较近的区域即可。</li><li>访问控制：要设置为公开</li></ul><ol start="2"><li>设置自己的存储空间<br>刷新列表就可以看到自己刚刚新建的存储空间。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911201842.png" alt=""><br>这里其实最需要干的是要绑定自己的域名，七牛云仅仅提供了一个测试域名，只能有一个月的使用时间，之后便不能访问了。所以需要干的是选择设置，绑定自己的域名。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911202412.png" alt=""><br>具体绑定域名方法七牛云有详细的说明文档，以及https和cdn的绑定，按照说明指导就行。</li></ol><h3 id="2-设置PicGo">2. 设置PicGo</h3><ol><li>右键图标查看详情打开picGO设置面板，左侧图床设置选择七牛图床<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203034.png" alt=""></li></ol><ul><li>AccessKey和SecretKey：七牛云页面右上角个人中心的密钥管理里面可以设置<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203301.png" alt=""></li><li>存储空间名称：就是我们前面的存储空间的名称。注意我这里用的是我实际图床使用的名字kwimg，但是我前面演示的是dh-img，那个仅仅是演示。大家在设置的时候此处要和前面创建的保持一致。</li><li>设定访问网址：<br>如果是没有实际绑定自己的域名的话，可以在空间概览中查看。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203700.png" alt=""><br>如果是自己已经绑定好域名的话，是下面这个样子的。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203838.png" alt=""><br>还有需要注意的一点是需要自己在网址的前面加上(<strong>http:// 或者 https://</strong>)。</li><li>确认存储区域<br>这里和我们之前申请存储空间的时候选择的区域是相关的。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911204251.png" alt=""></li><li>设定网址后缀： 这个暂时不用设置</li><li>制定存储区域： 自己随便设置，仅仅是图片的url路径多点东西而已不重要。</li></ul><ol start="2"><li>设置快捷键<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911204718.png" alt=""></li><li>设置开机自启<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911204812.png" alt=""></li><li>接下来就可以非常开心的将图片提交到七牛云存储啦。</li></ol><ul><li>当我们截图之后直接通过快捷键上传图片，图片上传成功之后对应的markdown地址会在本地的粘贴板。直接在对应的markdown文件中ctrl+v就行啦。</li><li>如果想看之前提交过图片，可以左键点击图标查看；也可以右键查看详情，然后查看对应的相册，点击图片下面的三个按钮最左面一个就可以复制本张图片的markdown地址；中间一个可以修改url地址；最右面一个可以将本张图片在相册中删掉，但是七牛云存储中依然存在。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911205205.png" alt=""></li></ul><h2 id="关于价格">关于价格</h2><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911205849.png" alt=""><br>如果仅仅是个人博客，而且访问量没有那么大的话，基本上就是免费的，七牛云真棒！！</p><p>ok,剩下的就是安心写博客啦,gogogo!</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://picgo.github.io/PicGo-Doc/zh/guide/" target="_blank" rel="noopener">PicGo-Guide文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用七牛云和PicGo给博客的图片安了一个家，七牛云真香！&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="PicGo" scheme="http://yoursite.com/tags/PicGo/"/>
    
      <category term="七牛云" scheme="http://yoursite.com/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
      <category term="图床" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>爬虫项目阶段性总结</title>
    <link href="http://yoursite.com/2020/07/18/data-scientist-grow-up/"/>
    <id>http://yoursite.com/2020/07/18/data-scientist-grow-up/</id>
    <published>2020-07-18T09:09:05.000Z</published>
    <updated>2020-07-18T09:29:51.835Z</updated>
    
    <content type="html"><![CDATA[<p>我对于爬虫项目的阶段性总结。<br>包含做项目时的流程、每个流程相关技术概述以及自己的学习经验。<br>方便自己后期查阅，也希望能给别人一点点指引。</p><a id="more"></a><h2 id="【前言】">【前言】</h2><ol><li>本学习计划仅作为参考，具体学习路线根据自己的实际情况酌情调整。</li><li>本学习路线图侧重数据工程师或者数据科学家路线，包括数据爬虫，清洗，存储，分析，展示等一系列流程。</li><li>本文档主要是给大黄写的，大黄写代码要加油啊！</li></ol><h2 id="完整的项目流程">完整的项目流程</h2><ol><li>确定项目内容：可以选择自己感兴趣的内容或者根据工作任务确定。</li><li>确定项目最终效果：根据目标效果反推出需要的数据。</li><li>确定数据源：根据想要的数据确定一个或者多个数据源</li><li>确定技术方案：分析数据源，确定需要的技术方案以及技术可行性。</li><li>开始动手！按照技术方案将数据进行采集，并最终实现预期的项目效果。</li></ol><h2 id="项目详细技术">项目详细技术</h2><h3 id="网页数据获取">网页数据获取</h3><p>本部分工作主要是用爬虫程序模拟浏览器访问对应的网站来获取网页html数据。</p><ol><li>发送请求获取网页数据。以python为例，可以通过类似于<a href="https://requests.readthedocs.io/en/master/" target="_blank" rel="noopener">requests</a>、urllib等package发送请求。</li><li>在正式编写代码前，要首先通过F12开发者选项（chrome浏览器）分析请求内容。或者直接通过网站页面右键-&gt;检查-&gt;network面板进行查看。</li></ol><ul><li>分析请求的url，查看是否存在跳转，是否需要登陆，如果需要登陆则考虑模拟登陆或者保存cookie或者使用cookie池。</li><li>查看能否直接请求对应的api获取目标数据,如果不能,再考虑请求网页原始数据再将目标数据解析出来。</li><li>对于模拟登陆，可以通过输入一个错误的用户名和密码来获得真正的url请求情况，否则可能因为成功跳转而看不到相关内容；</li></ul><ol start="3"><li>注意各种反爬虫措施的处理，包括伪造请求头、设置请求间隔时间、设置ip代理,携带cookie信息等等</li></ol><h3 id="网页解析">网页解析</h3><p>本部分工作是将网页对应的html页面内容进行解析。重点是灵活使用各种解析库，将想要的数据提取出来。<br>其中解析库主要包括<a href="https://www.runoob.com/xpath/xpath-syntax.html" target="_blank" rel="noopener">xpath</a>,<a href="https://www.crummy.com/software/BeautifulSoup/doc" target="_blank" rel="noopener">bs4</a>，<a href="https://pythonhosted.org/pyquery/" target="_blank" rel="noopener">pyquery</a>等，还可以结合正则表达式、字符串操作等多种方式对网页内容进行解析。</p><h3 id="数据处理">数据处理</h3><p>网页解析出来的内容数据可能存在数据缺失、数据格式不一致等问题。所以需要进行数据处理操作。</p><ul><li>数据缺失问题：删除整条数据、填充特殊值、填充中位数、填充众数、数据拟合等</li><li>数据格式不一致问题：确定数据统一格式，包括单位、格式等</li></ul><h3 id="数据存储">数据存储</h3><p>将处理好的数据进行数据存储，方便后期使用。</p><ul><li>关系型数据库：mysql、oracle等</li><li>文档型数据库：mongodb</li><li>图数据库：neo4j</li><li>内存数据库： redis<br>个人比较倾向于爬虫处理后的结果暂时放到mongdb中，原因就是方便读写。等数据处理结束之后可以根据数据类型以及对外服务的类型决定放到图数据库或者关系型数据库。</li></ul><h3 id="数据分析">数据分析</h3><p>根据预期的项目效果对已经爬取的数据进行数据分析。</p><ul><li>按照不同类别进行划分，比如不同的地域，不同季节，不同人群等。</li><li>按照时间线进行分析，比如平均身高，平均薪酬等。</li><li>按照其他统计学的知识对数据进行处理并分析。</li></ul><h3 id="数据展示">数据展示</h3><p>数据分析的结果要通过合适的方式进行展示。</p><ul><li>ppt、word等办公软件。考虑内嵌图表或者截图插入</li><li>个人网站、个人博客等。考虑使用<a href="https://echarts.apache.org/examples/zh/index.html" target="_blank" rel="noopener">echarts.js</a>或者<a href="https://observablehq.com/@d3/gallery" target="_blank" rel="noopener">d3.js</a>等图表库，效果非常好。</li></ul><h3 id="结论">结论</h3><p>我们研究或者调研的内容告诉我们什么内容，说明了什么道理，给我们什么启示，这个也应该作为我们整个项目的一部分进行说明。</p><h2 id="技术进一步提升">技术进一步提升</h2><p>上面介绍的技术仅仅适应于数据量较小的常规数据采集路线。下面说一下其中可以进行扩展和提升的部分。</p><h3 id="爬虫框架的使用">爬虫框架的使用</h3><p>数据采集是一个比较常见的需求，所以程序员们开发出了很多方便扩展的爬虫框架，比如<a href="https://docs.scrapy.org/en/latest/intro/tutorial.html" target="_blank" rel="noopener">scrapy</a>、<a href="http://docs.pyspider.org/en/latest/" target="_blank" rel="noopener">pyspider</a>、<a href="https://scrapy-redis.readthedocs.io/en/stable/" target="_blank" rel="noopener">scrapy-redis</a>、<a href="https://scrapy-cluster.readthedocs.io/en/latest/topics/introduction/overview.html" target="_blank" rel="noopener">scrapy-cluster</a>等，可以让我们将重点放在处理核心业务上。</p><h3 id="docker的使用">docker的使用</h3><p>docker可以认为是一个轻量的虚拟机，通过镜像来创建实例，每个实例彼此隔离彼此独立，从而可以让程序员摆脱编程开发测试部署环境不一致的问题，同时方便进行横向扩展。在我们项目构造出对应的镜像之后，便会由镜像在手，天下我有的豪气。<br>在使用新的组件之前，可以先去<a href="https://hub.docker.com/" target="_blank" rel="noopener">dockerhub</a>看看，之后尽量所有的项目要通过docker进行部署，用dockerfile来进行定义。让项目组件化，这样就可以解耦合，从而方便扩展和升级。</p><p>爬虫过程的每一个步骤都可以单独拿出来交给对应的docker镜像来处理。看自己最后的需求进行不同粒度的分解。</p><h3 id="大数据组件">大数据组件</h3><p>在数据清洗、数据分析的时候如果数据量太大，可以和大数据平台进行对接，包括hadoop、mapreduce等，然后将对应的结果保存起来供进一步使用。</p><p>大数据平台的东西由很多，而且环境部署比较麻烦，所以本部分强烈建议使用docker进行部署，然后在部署的时候要注意不同实例之间的通信。</p><h3 id="分布式爬虫部署">分布式爬虫部署</h3><p>当数据量太大，单机爬虫的速率就远远不能满足我们的需求，这个时候就可以考虑使用分布式爬虫，将很多台主机一起来爬取想要的数据，上面说的爬虫框架sacrpy就是单机版本的，scrapy-redis就是在scrapy的基础上添加redis用来做爬取队列，可以作为分布式爬虫使用，scrapy-cluster是在scrapy-redis的基础上添加大数据组件kafka从而与大数据平台对接，也属于分布式爬虫。scrapyd可以用来方便的部署分布式爬虫程序。<a href="https://docs.gerapy.com/en/latest/" target="_blank" rel="noopener">Gerapy</a>也值得关注。</p><h3 id="APP内容的爬取">APP内容的爬取</h3><p>本部分我没有做过，但是我知道有很多库，包括Charles、mitmproxy、Appium等，可以对手机app进行抓包，从而采集到想要的数据。</p><h2 id="学习经验">学习经验</h2><ol><li>要以项目为主导，no bb，show your code！！</li><li>善于使用搜索引擎google、bing</li><li>学会使用<a href="https://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a>查找bug</li><li>尽量通过官方文档学习新的技术</li><li>合理使用github这个宝库</li><li>找一本好的参考资料比如<a href="https://item.jd.com/12333540.html" target="_blank" rel="noopener">Python 3网络爬虫开发实战</a>以及网站<a href="https://cuiqingcai.com/" target="_blank" rel="noopener">静觅-崔庆才</a></li></ol><p>最后，开始动手吧！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我对于爬虫项目的阶段性总结。&lt;br&gt;
包含做项目时的流程、每个流程相关技术概述以及自己的学习经验。&lt;br&gt;
方便自己后期查阅，也希望能给别人一点点指引。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="spider" scheme="http://yoursite.com/tags/spider/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Docker-容器内安装vim编辑器</title>
    <link href="http://yoursite.com/2020/06/15/docker-4-install-vim-in-container/"/>
    <id>http://yoursite.com/2020/06/15/docker-4-install-vim-in-container/</id>
    <published>2020-06-15T07:40:03.000Z</published>
    <updated>2020-06-15T08:01:47.410Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章将会介绍在container中安装vim编辑器。<br>需要注意在正式开发时要通过dockerfile来进行所有环境的设置。</p><a id="more"></a><p>在有些容器中使用vim命令的时候，会提示如下错误。</p><blockquote><p>vim: command not found</p></blockquote><p>说明容器中没有安装vim.<br>我们可以通过如下命令进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure><p>如果安装的时候报错，报错信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package vim</span><br></pre></td></tr></table></figure><p>可以通过如下命令来解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章将会介绍在container中安装vim编辑器。&lt;br&gt;
需要注意在正式开发时要通过dockerfile来进行所有环境的设置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Docker提升-实现原理</title>
    <link href="http://yoursite.com/2020/06/15/docker-3-principle/"/>
    <id>http://yoursite.com/2020/06/15/docker-3-principle/</id>
    <published>2020-06-15T07:05:44.000Z</published>
    <updated>2020-06-15T07:16:39.901Z</updated>
    
    <content type="html"><![CDATA[<p>docker镜像是一个特殊的文件系统。<br>本篇文章将介绍如何docker镜像的层级结构，同时学习如何查看中间层镜像。</p><a id="more"></a><h2 id="docker的原理">docker的原理</h2><p>Docker 的镜像就是它的文件系统，一个镜像可以放在另外一个镜像的上层，那么位于下层的就是它的父镜像。所以，Docker 会存在很多镜像层，每个镜像层都是只读的，并且不会改变。当我们创建一个新的容器时，Docker 会构建出一个镜像栈，并在栈的最顶层添加一个读写层，如图所示。<br><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdbf9e98a71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>其中中间的这些镜像层就是intermediate image，是不能被删除的。</p><h2 id="如何查看中间层镜像">如何查看中间层镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查看镜像</span><br><span class="line">docker image ls</span><br><span class="line">&#x2F;&#x2F;查看所有镜像（包含中间层镜像）</span><br><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure><p>带参数a选项的命令输出的结果中含有none:none标签的镜像都是intermediate image(中间层镜像)，这些镜像会被其他镜像所使用，是不能被随意删除的。</p><h2 id="none-none-标签镜像">none:none 标签镜像</h2><p>具有none:none 标签的景象都是intermediate image吗？ 其实不是，还有一类镜像是dangling image（悬虚镜像），通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>命令展示出来的镜像也会包含none:none标签的镜像，这就是dangling image.</p><p>那么dangling image是如何产生的呢？<br>比如我们最开始通过如下命令构造一个名称为test:v1的镜像，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t test:v1 .</span><br></pre></td></tr></table></figure><p>然后我们后期对代码进行了修改，所以我们会重新构造一个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t test:v1 .</span><br></pre></td></tr></table></figure><p>我们没有为它分配新的名字，新构造的镜像还是叫做test:v1。这个时候原来的test:v1就会成为dangling image，根本没用，而且会占用存储空间。</p><p>可以通过如下命令将所有的玄虚镜像删掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h2 id="写在最后">写在最后</h2><p>记得多关注一下docker的help文档,以查看镜像命令为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  log docker image ls --help</span><br><span class="line"></span><br><span class="line">Usage:  docker image ls [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">List images</span><br><span class="line"></span><br><span class="line">Aliases:</span><br><span class="line">  ls, images, list</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">      --digests         Show digests</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print images using a Go template</span><br><span class="line">      --no-trunc        Don&#39;t truncate output</span><br><span class="line">  -q, --quiet           Only show numeric IDs</span><br></pre></td></tr></table></figure><p>可以看到-a选项后面说，默认是隐藏intermediate images的。所以我们就可以了解到存在intermediate images 而且还可以通过在原命令的后面加参数a来查看中间层镜像。</p><p>更细节的原理可以查看这篇文章<a href="https://www.projectatomic.io/blog/2015/07/what-are-docker-none-none-images/" target="_blank" rel="noopener">What are Docker <none>:<none> images?</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker镜像是一个特殊的文件系统。&lt;br&gt;
本篇文章将介绍如何docker镜像的层级结构，同时学习如何查看中间层镜像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>Docker进阶-Dockerfile的编写和使用</title>
    <link href="http://yoursite.com/2020/06/15/docker-2-dockerfile/"/>
    <id>http://yoursite.com/2020/06/15/docker-2-dockerfile/</id>
    <published>2020-06-15T06:55:13.000Z</published>
    <updated>2020-06-15T08:02:45.217Z</updated>
    
    <content type="html"><![CDATA[<p>在实际开发中完全使用他人构造好的镜像是不现实的。<br>所以本篇文章我们将会学习Dockerfile的知识，从而学习如何构造符合项目要求的镜像。</p><a id="more"></a><h2 id="Dockerfile文档展示">Dockerfile文档展示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">RUN apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y python3-pip python3-dev</span><br><span class="line"></span><br><span class="line"># We copy just the requirements.txt first to leverage Docker cache</span><br><span class="line">COPY .&#x2F;requirements.txt &#x2F;app&#x2F;requirements.txt</span><br><span class="line"></span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line"></span><br><span class="line">RUN python3 -m pip install --upgrade pip</span><br><span class="line">RUN pip3 install -r requirements.txt</span><br><span class="line"></span><br><span class="line">COPY . &#x2F;app</span><br><span class="line"></span><br><span class="line"># ENTRYPOINT [ &quot;python3&quot; ]</span><br><span class="line"></span><br><span class="line">CMD [ &quot;python3&quot;, &quot;main.py&quot; ]</span><br></pre></td></tr></table></figure><h2 id="逐行命令解释">逐行命令解释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1. FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">FROM 关键字会初始化一个image构造，并为后续的所有操作设置基础镜像，，上面的例子表示，该image是以ubuntu:16.04为基础构建的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. RUN apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y python3-pip python3-dev</span><br><span class="line"></span><br><span class="line">RUN 会在上一层的基础上添加新的layer,并将结果提交给下一层。RUN命令有两种形式。一种是shell格式，格式如下</span><br><span class="line">RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is &#x2F;bin&#x2F;sh -c on Linux or cmd &#x2F;S &#x2F;C on Windows)</span><br><span class="line"></span><br><span class="line">另一种是exec格式，格式如下</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)</span><br><span class="line"></span><br><span class="line">&amp;&amp; \ 并不是Docker独有的，只是告诉linux这两条命令要一起执行，而不是执行两次，这样就只会产生一层layer,如果有两个RUN，那么就会产生两个中间层。 </span><br><span class="line"></span><br><span class="line">3. COPY .&#x2F;requirements.txt &#x2F;app&#x2F;requirements.txt</span><br><span class="line">COPY 命令同样有两种形式，可以实现将源文件复制到目标位置，支持正则表达式。</span><br><span class="line">COPY [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [--chown&#x3D;&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br><span class="line"></span><br><span class="line">4. WORKDIR &#x2F;app</span><br><span class="line">- WORKDIR 会设置当前的工作目录，在本条指令之后的RUN, CMD, ENTRYPOINT, COPY 和 ADD目录都是在当前目录下执行的。</span><br><span class="line">- WORKDIR 可以出现多次，从而更换shell的执行路径</span><br><span class="line"></span><br><span class="line">5. RUN python3 -m pip install --upgrade pip</span><br><span class="line">6. RUN pip3 install -r requirements.txt</span><br><span class="line">RUN命令的shell形式，更新pip同时安装依赖。</span><br><span class="line"></span><br><span class="line">7. COPY . &#x2F;app</span><br><span class="line">复制命令 将当前目录的所有文件复制到&#x2F;app目录下</span><br><span class="line"></span><br><span class="line">8.CMD [ &quot;python3&quot;, &quot;main.py&quot; ]</span><br><span class="line">CMD的作用是提供容器的默认指令，也就是我们docker run 的最后一个参数。CMD有三种形式，在一个Dockerfile中，如果有多个CMD指令，那么只有最后一个CMD命令会起作用。</span><br><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)</span><br><span class="line">CMD command param1 param2 (shell form)</span><br><span class="line"></span><br><span class="line">如果CMD命令后只有参数，没有可执行的命令，那么它肯定是配合ENTRYPOINT使用的。同时要注意，如果是配合ENTRYPOINT的时候，CMD和ENTRYPOINT都要使用使用 JSON array 格式。如果用ENTRYPOINT进行改写，则如下所示。</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ &quot;python&quot; ]</span><br><span class="line">CMD [ &quot;main.py&quot; ]</span><br></pre></td></tr></table></figure><h2 id="打包镜像">打包镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t kuakua:latest .</span><br><span class="line"> -t 设置镜像名称和标签，如果标签没有设定，默认是latest</span><br><span class="line"> .  在当前目录寻找Dockerfile进行镜像打包。</span><br></pre></td></tr></table></figure><h2 id="运行容器">运行容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> docker run -d -p 5001:5000 --name kuakua -v &#x2F;Users&#x2F;liqingwen&#x2F;workplace&#x2F;temp&#x2F;kuakua&#x2F;log:&#x2F;log kuakua:latest</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 详细解释</span><br><span class="line">-d  表示以守护进程的形式进行执行，后台运行</span><br><span class="line">-p 5001:5000 将容器的5000端口映射到宿主机的5001端口</span><br><span class="line">--name kuakua 将当前容器命名为kuakua</span><br><span class="line">-v bind mount a volumn 将容器的log目录和本地的&#x2F;Users&#x2F;liqingwen&#x2F;workplace&#x2F;temp&#x2F;kuakua&#x2F;log做一个映射。如果容器端log目录下有内容更新，则本地的log目录也会同步更新。</span><br><span class="line">kuakua:latest 镜像名称</span><br></pre></td></tr></table></figure><h2 id="项目地址">项目地址</h2><p>本项目完整代码已经在github开源，项目地址<a href="https://github.com/aweng126/TestProject/tree/master/kuakua" target="_blank" rel="noopener">夸夸机器人</a>,欢迎大家去尝试一下。</p><h2 id="参考">参考</h2><ol><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">dockerfile 官方参考文档</a></li><li><a href="https://runnable.com/docker/python/dockerize-your-flask-application" target="_blank" rel="noopener">Dockerize your Flask Application</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际开发中完全使用他人构造好的镜像是不现实的。&lt;br&gt;
所以本篇文章我们将会学习Dockerfile的知识，从而学习如何构造符合项目要求的镜像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="dockerfile" scheme="http://yoursite.com/tags/dockerfile/"/>
    
  </entry>
  
  <entry>
    <title>Docker初探-认识并使用docker</title>
    <link href="http://yoursite.com/2020/06/15/docker-fundamentals/"/>
    <id>http://yoursite.com/2020/06/15/docker-fundamentals/</id>
    <published>2020-06-15T03:14:10.000Z</published>
    <updated>2020-06-15T06:45:56.831Z</updated>
    
    <content type="html"><![CDATA[<p>docker是目前最流行的虚拟化技术。<br>本篇文章主要介绍docker的基本概念以及初步尝试使用docker技术。</p><a id="more"></a><h2 id="docker是什么">docker是什么</h2><p>Docker 属于 Linux容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p><p>Docker将应用程序与该程序的依赖，打包在一个文件里面。只要运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。</p><h2 id="docker好在哪">docker好在哪</h2><ol><li>更高效的利用系统资源</li><li>更快速的启动时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>容易迁移、维护和扩展</li></ol><h2 id="docker专有名词">docker专有名词</h2><ol><li>镜像，image, 包括各种环境的定义和说明。</li><li>容器，container, 是一个镜像的运行实体，不同容器之间是相互隔离的。</li><li>仓库，镜像的仓库，用于用户发布自己的镜像或者查找自己需要的镜像，目前最大的公开仓库为<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker hub</a>,一个项目star越多，说明项目越好越稳定。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdab4a554d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="常用命令">常用命令</h2><h3 id="启动docker">启动docker</h3><p>如果是mac或者windows用户，可以直接使用Docker Desktop来可视化处理<br>如果是linux用户，需要通过命令行来启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start&#x2F;stop&#x2F;restart</span><br></pre></td></tr></table></figure><h3 id="使用docker">使用docker</h3><ol><li>help帮助命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image --help</span><br></pre></td></tr></table></figure><p>通过这条命令可以查看与docker的镜像相关的命令<br>将image替换为container，则可以查看到关于container的相关帮助。<br>同时，可以进一步查看相关命令的细节，比如下面的命令就可以查看image下prune命令的细节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune --help</span><br></pre></td></tr></table></figure><ol start="2"><li>搜索并拉取镜像</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 搜索与ubuntu相关的image</span><br><span class="line">docker search ubuntu</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拉取镜像到本地</span><br><span class="line">docker pull ubuntu</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果没有特别声明tag,会默认使用latest标签。</span><br><span class="line">&#x2F;&#x2F; 当然可以去docker hub去查找image并查看更加细节的东西，比如版本信息，然后在拉取的时候可以指定版本。</span><br><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure><ol start="3"><li>列出当前本地的所有镜像</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">或者</span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>如果想同时查看中间层镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images -a</span><br><span class="line">或者</span><br><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure><ol start="4"><li>删除本地镜像</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除固定的某个镜像</span><br><span class="line">docker rmi imageid</span><br><span class="line">docker image rm imageid</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除所有玄虚镜像</span><br><span class="line">docker image prune</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除所有玄虚镜像和未使用的景象</span><br><span class="line">docker image prune -a</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除所有仓库名为redis的镜像</span><br><span class="line">docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure><ol start="5"><li>启动一个容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从image启动一个容器</span><br><span class="line">docker run -it --name ubuntu  ubuntu:18.04  &#x2F;bin&#x2F;bash</span><br><span class="line"> -i : Keep STDIN open even if not attached 即使没有连接，也要保持标准输入保持打开状态</span><br><span class="line"> -t : Allocate a pseudo-TTY  分配一个伪tty</span><br><span class="line"> -name ubuntu : 为当前容器分配名字为ubuntu</span><br><span class="line"> ubuntu:18.04 ：要运行的镜像</span><br><span class="line"> &#x2F;bin&#x2F;bash ：要执行的命令。</span><br><span class="line"></span><br><span class="line">还有一个参数非常常见 </span><br><span class="line"> -d : Run container in background and print container ID 在后台运行容器，且打印容器id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 把之前停止的容器重新启动</span><br><span class="line">docker start containerid</span><br><span class="line">docker attach containerid</span><br></pre></td></tr></table></figure><p>使用docker run命令来启动容器，docker在后台运行的标准操作包括</p><pre><code>1. 检查本地是否存在指定的镜像，不存在则从公有仓库下载2. 使用镜像创建并启动容器3.分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层4.从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中去5.从地址池分配一个ip地址给容器6.执行用户指定的应用程序7.执行完毕之后容器被终止</code></pre><p>需要注意的是，对于容器要执行的命令而言，如果执行结束，那么容器就会关闭。</p><ol start="6"><li>查看当前正在运行的容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>如果还想查看已经退出的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><ol start="7"><li>连接一个执行之中的容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container exec -it containerid</span><br></pre></td></tr></table></figure><ol start="8"><li>退出正在运行的容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctrl + D</span><br><span class="line">或者</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><ol start="9"><li>查看镜像所占空间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><ol start="10"><li>删除某些名称中含有dingms的container</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm $(docker ps -a |grep dingms | awk &#39;&#123;print $1&#125;&#39;)</span><br></pre></td></tr></table></figure><ol start="11"><li>守护态进程<br>很多时候，需要让docker在后台运行而不是直接把结果输出到当前宿主下面，这个时候可以用守护态运行。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 没有使用守护态，始终在本地终端输出</span><br><span class="line">docker run  ubuntu:18.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用守护态,不在本地终端输出，但是在最后结果输出</span><br><span class="line">docker run -d ubuntu:18.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">&#x2F;&#x2F; 查看当前contain</span><br><span class="line">docker container ls</span><br><span class="line">docker container logs containerid</span><br></pre></td></tr></table></figure><ol start="12"><li>终止某个容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop containerid</span><br></pre></td></tr></table></figure><p>对于正在运行中的容器，重新启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container restart containerid</span><br></pre></td></tr></table></figure><ol start="13"><li>进入容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker attach containerid</span><br><span class="line"></span><br><span class="line">docker exec -it containerid bash</span><br><span class="line"></span><br><span class="line">用attach进入终端之后，如果exit会直接让容器终止。</span><br><span class="line">但是exec通过exit退出之后，容器不会终止。</span><br></pre></td></tr></table></figure><ol start="14"><li>镜像打包和加载</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 打包镜像</span><br><span class="line">docker save -o ~&#x2F;Desktop&#x2F;kuakua.tar kuakua:latest</span><br><span class="line">&#x2F;&#x2F; 加载tar包到对应的镜像</span><br><span class="line">docker load -i ~&#x2F;Desktop&#x2F;kuakua.tar</span><br></pre></td></tr></table></figure><ol start="15"><li>导出和导入容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 导出容器快照文件到本地文件</span><br><span class="line">docker export containerid &gt; name.tar</span><br><span class="line">&#x2F;&#x2F; 从容器快照文件再导入为镜像</span><br><span class="line">cat name.tar | docker import - test&#x2F;name:v1.0</span><br><span class="line">&#x2F;&#x2F; 查看所属镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p>从网上找到一个非常棒的图<br><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdbf14142a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2 id="参考文章">参考文章</h2><ol><li><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">Docker 从入门到实践</a></li><li><a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="noopener">Docker-cli官方文档</a></li><li><a href="https://juejin.im/post/5cacbfd7e51d456e8833390c#heading-0" target="_blank" rel="noopener">30 分钟快速入门 Docker 教程</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker是目前最流行的虚拟化技术。&lt;br&gt;
本篇文章主要介绍docker的基本概念以及初步尝试使用docker技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>go-get碰到timeout怎么办</title>
    <link href="http://yoursite.com/2020/04/23/go-micro-bug-io-timeout/"/>
    <id>http://yoursite.com/2020/04/23/go-micro-bug-io-timeout/</id>
    <published>2020-04-23T12:49:48.000Z</published>
    <updated>2020-04-23T13:42:28.357Z</updated>
    
    <content type="html"><![CDATA[<p>go get 下载资源的时候下载缓慢甚至遇到timeout,可以通过设置代理的方式来解决。</p><a id="more"></a><p>通过如下命令可以查看go对应的各类变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure><p>我们重点要看.GO111MODULE这两个选项。</p><ol><li>GOPROXY: 代表是使用代理。</li><li>GO111MODULE: 表示是否使用module.在Go1.11版本之后就非常推荐使用go module 来管理依赖了。所以非常推荐使用。</li></ol><h2 id="Linux-或者-Mac环境下">Linux 或者 Mac环境下</h2><p>直接修改环境变量就可以啦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line">export GO111MODULE&#x3D;on</span><br><span class="line">export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io </span><br><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p>通过go env再查看一下，上面的路径是否生效。若已经生效，则重新 go get 下载资源即可。</p><h2 id="GO-Land-开发">GO Land 开发</h2><p>GO111MODULE=ON还是要通过上面的方式进行设定。</p><p>如果是使用goland,还可以依次的点击如下选项设置proxy。<br>GOLAND-&gt;Preferences-&gt;Go-&gt;Go modules(vgo)-&gt;选中Enable Go module integration.<br>同时设置proxy的值为 <a href="https://goproxy.io" target="_blank" rel="noopener">https://goproxy.io</a> 或者 <a href="https://goproxy.cn" target="_blank" rel="noopener">https://goproxy.cn</a>,direct<br>点击apply就行。</p><p>通过go env再查看一下，上面的路径是否生效。若已经生效，则重新 go get 下载资源即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go get 下载资源的时候下载缓慢甚至遇到timeout,可以通过设置代理的方式来解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Bugs" scheme="http://yoursite.com/categories/Bugs/"/>
    
    
      <category term="go-micro" scheme="http://yoursite.com/tags/go-micro/"/>
    
      <category term="timout" scheme="http://yoursite.com/tags/timout/"/>
    
      <category term="proxy" scheme="http://yoursite.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>【微服务Go-micro第三篇】相关概念解释</title>
    <link href="http://yoursite.com/2020/04/23/go-micro-3-concept-interpretation/"/>
    <id>http://yoursite.com/2020/04/23/go-micro-3-concept-interpretation/</id>
    <published>2020-04-23T10:51:33.000Z</published>
    <updated>2020-04-23T11:06:52.405Z</updated>
    
    <content type="html"><![CDATA[<p>在搭建环境的时候其实我就有很多疑问了，怎么有这么多概念？<br>微服务、RPC, gRPC, protoc等等，它们都是啥？本篇文章来进行比较详细的解释。</p><a id="more"></a><h2 id="微服务">微服务</h2><p>使用一套小服务来开发单个应用的方式，每个服务运行在独立的进程里，一般采用轻量级的通讯机制互联，并且它们可以通过自动化的方式部署。</p><h2 id="RPC">RPC</h2><ol><li>远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议</li><li>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li><li>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用</li></ol><h2 id="gRPC">gRPC</h2><ol><li>gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统</li><li>gRPC客户端和服务端可以在多种环境中运行和交互，例如用java写一个服务端，可以用go语言写客户端调用</li></ol><h2 id="protobuff">protobuff</h2><ol><li>gRPC可以实现微服务，将大的项目拆分为多个小且独立的业务模块，也就是服务，各服务间使用高效的protobuf协议进行RPC调用，gRPC默认使用protocol  buffer，这是google开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如JSON）</li><li>可以用proto files创建gRPC服务，用message类型来定义方法参数和返回类型</li></ol><h2 id="个人理解">个人理解</h2><p>结合这里和我们上一篇的文章，我们可以得到以下结论</p><ol><li>我们是使用了proto file(user.proto)来定义对应的方法和返回类型，其中message结构来定义接收参数和返回参数的名称以及类型。 service结构来定义对应的远程调用的方法和接受的对应的参数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service user&#123;</span><br><span class="line">        rpc RegisterUser(RegisterUserReq) returns (RegisterUserRsp)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserReq&#123;</span><br><span class="line">        string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserRsp&#123;</span><br><span class="line">        string status &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>protoc命令会按照proto文件中声明的message的格式构造传输对象。gRPC的服务器端和客户端都遵守protocal buffer协议，在客户端会序列化请求对象，在服务端反序列化请求对象，服务器端处理完成之后，序列化响应对象，客户端再反序列化响应对象。所以共同遵守protocal buff 协议让客户端和服务器端可以方便地进行通信，即使最后客户端和服务器端是用不同的语言来实现的也没有关系。</li></ol><h2 id="protobuf语法">protobuf语法</h2><h3 id="简单介绍">简单介绍</h3><ol><li>以.proto结尾</li><li>Message命名采用驼峰命名方式，字段命名采用小写字母加下划线分隔方式</li><li>结构定义可以包含：message、service、enum</li><li>可以通过required表示这个参数是必须的，optional表示这个参数是可选的。通过default表示这个参数的默认值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;; &#x2F;&#x2F; </span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query &#x3D; 1;</span><br><span class="line">  optional int32 page_number &#x3D; 2;</span><br><span class="line">  optional int32 result_per_page &#x3D; 3 [default &#x3D; 10];</span><br><span class="line">  enum Corpus &#123;</span><br><span class="line">    UNIVERSAL &#x3D; 0;</span><br><span class="line">    WEB &#x3D; 1;</span><br><span class="line">    IMAGES &#x3D; 2;</span><br><span class="line">    LOCAL &#x3D; 3;</span><br><span class="line">    NEWS &#x3D; 4;</span><br><span class="line">    PRODUCTS &#x3D; 5;</span><br><span class="line">    VIDEO &#x3D; 6;</span><br><span class="line">  &#125;</span><br><span class="line">  optional Corpus corpus &#x3D; 4 [default &#x3D; UNIVERSAL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service SearchService &#123;</span><br><span class="line">        rpc Search (SearchRequest) returns (SearchResponse) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>更多使用方式可以参见下面的两个链接。</p><h3 id="参考链接">参考链接</h3><ol><li><a href="https://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="noopener">[译]Protobuf 语法指南</a></li><li><a href="http://www.topgoer.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Protobuf%E8%AF%AD%E6%B3%95.html" target="_blank" rel="noopener">1. Protobuf语法</a></li></ol><h2 id="Go-micro">Go-micro</h2><h3 id="什么是go-micro">什么是go-micro</h3><p>go-micro是一个框架，提供了分布式开发所需要的核心需求，包括RPC和基于事件驱动的通信。设计理念是可插拔。</p><h3 id="Go-micro特点">Go-micro特点</h3><ol><li>服务发现：自动服务注册和命名解析。服务发现是微服务开发中的核心，当服务A要与服务B协作时，它得知道服务B在哪里。目前默认的服务发现机制是组播multicast DNS (mdns，组播)，是一种零配置网络。</li><li>负载均衡：在服务发现的基础上构建客户端的负载均衡。当我们查找一个服务发现它有多个节点时，我们需要一种机制来决定最终路由到哪一个节点。默认使用random hashed load balancing来提供服务的负载均衡。如果出现问题，那么go-micro会尝试使用其他节点。</li><li>消息编码：基于内容类型动态编码消息，客户端和服务器端将会使用基于内容类型的编解码器来对Go语言的类型进行无缝隙的编解码。客户端可以编码并发送各种类型额消息，客户端和服务器端默认能够处理这些消息，默认包含 protobuf and json。</li><li>请求/相应：RPC通信是基于双向信息流的请求和相应。go-micro提供一种同步的抽象。一个发送给服务的请求会被自动的解析、负载均衡、拨号、转成字节流。默认传输是通过gRPC。</li><li>异步信息：发布订阅机制在异步通信和事件驱动架构中非常重要，事件通知在微服务开发中占有重要地位。默认的消息传递系统是http事件消息代理。</li><li>可插拔： Go Micro为每个分布式系统抽象出接口。因此，Go Micro的接口都是可插拔的，允许其在运行时不可知的情况下仍可支持。所以只要实现接口，可以在内部使用任何的技术。更多插件请参考：<a href="http://github.com/micro/go-plugins" target="_blank" rel="noopener">github.com/micro/go-plugins</a></li></ol><h3 id="go-micro通信流程">go-micro通信流程</h3><ol><li>Server监听客户端的调用，对Brocker推送过来的信息进行处理。并且Server端需要向Register注册自己的存在或消亡，这样Client才能知道自己的状态</li><li>Register服务的注册的发现，Client端从Register中得到Server的信息，然后每次调用都根据算法选择一个的Server进行通信，当然通信是要经过编码/解码，选择传输协议等一系列过程的</li><li>如果有需要通知所有的Server端可以使用Brocker进行信息的推送，Brocker 信息队列进行信息的接收和发布</li></ol><h3 id="go-micro接口">go-micro接口</h3><p>go-micro之所以可以高度订制和他的框架结构是分不开的，go-micro由8个关键的interface组成，每一个interface都可以根据自己的需求重新实现，这8个主要的inteface也构成了go-micro的框架结构<br><img src="http://www.topgoer.com/static/wei/6/1.png" alt=""></p><h3 id="go-micro-接口详解">go-micro 接口详解</h3><h4 id="Transort通信接口">Transort通信接口</h4><p>通信相关接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type Socket interface &#123;</span><br><span class="line">   Recv(*Message) error</span><br><span class="line">   Send(*Message) error</span><br><span class="line">   Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Client interface &#123;</span><br><span class="line">   Socket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Listener interface &#123;</span><br><span class="line">   Addr() string</span><br><span class="line">   Close() error</span><br><span class="line">   Accept(func(Socket)) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Transport interface &#123;</span><br><span class="line">   Dial(addr string, opts ...DialOption) (Client, error)</span><br><span class="line">   Listen(addr string, opts ...ListenOption) (Listener, error)</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Codec编码接口">Codec编码接口</h4><p>编解码，底层也是protobuf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Codec interface &#123;</span><br><span class="line">   ReadHeader(*Message, MessageType) error</span><br><span class="line">   ReadBody(interface&#123;&#125;) error</span><br><span class="line">   Write(*Message, interface&#123;&#125;) error</span><br><span class="line">   Close() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.1.3. Registry注册接口<br>服务注册发现的实现：etcd、consul、mdns、kube-DNS、zk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Registry interface &#123;</span><br><span class="line">   Register(*Service, ...RegisterOption) error</span><br><span class="line">   Deregister(*Service) error</span><br><span class="line">   GetService(string) ([]*Service, error)</span><br><span class="line">   ListServices() ([]*Service, error)</span><br><span class="line">   Watch(...WatchOption) (Watcher, error)</span><br><span class="line">   String() string</span><br><span class="line">   Options() Options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Selector负载均衡">Selector负载均衡</h4><p>根据不同算法请求主机列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Selector interface &#123;</span><br><span class="line">   Init(opts ...Option) error</span><br><span class="line">   Options() Options</span><br><span class="line">   &#x2F;&#x2F; Select returns a function which should return the next node</span><br><span class="line">   Select(service string, opts ...SelectOption) (Next, error)</span><br><span class="line">   &#x2F;&#x2F; Mark sets the success&#x2F;error against a node</span><br><span class="line">   Mark(service string, node *registry.Node, err error)</span><br><span class="line">   &#x2F;&#x2F; Reset returns state back to zero for a service</span><br><span class="line">   Reset(service string)</span><br><span class="line">   &#x2F;&#x2F; Close renders the selector unusable</span><br><span class="line">   Close() error</span><br><span class="line">   &#x2F;&#x2F; Name of the selector</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Broker发布订阅接口">Broker发布订阅接口</h4><p>pull push watch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Broker interface &#123;</span><br><span class="line">   Options() Options</span><br><span class="line">   Address() string</span><br><span class="line">   Connect() error</span><br><span class="line">   Disconnect() error</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Publish(string, *Message, ...PublishOption) error</span><br><span class="line">   Subscribe(string, Handler, ...SubscribeOption) (Subscriber, error)</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Client客户端接口">Client客户端接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Client interface &#123;</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Options() Options</span><br><span class="line">   NewMessage(topic string, msg interface&#123;&#125;, opts ...MessageOption) Message</span><br><span class="line">   NewRequest(service, method string, req interface&#123;&#125;, reqOpts ...RequestOption) Request</span><br><span class="line">   Call(ctx context.Context, req Request, rsp interface&#123;&#125;, opts ...CallOption) error</span><br><span class="line">   Stream(ctx context.Context, req Request, opts ...CallOption) (Stream, error)</span><br><span class="line">   Publish(ctx context.Context, msg Message, opts ...PublishOption) error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Server服务端接口">Server服务端接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Server interface &#123;</span><br><span class="line">   Options() Options</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Handle(Handler) error</span><br><span class="line">   NewHandler(interface&#123;&#125;, ...HandlerOption) Handler</span><br><span class="line">   NewSubscriber(string, interface&#123;&#125;, ...SubscriberOption) Subscriber</span><br><span class="line">   Subscribe(Subscriber) error</span><br><span class="line">   Register() error</span><br><span class="line">   Deregister() error</span><br><span class="line">   Start() error</span><br><span class="line">   Stop() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Serveice接口">Serveice接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Service interface &#123;</span><br><span class="line">   Init(...Option)</span><br><span class="line">   Options() Options</span><br><span class="line">   Client() client.Client</span><br><span class="line">   Server() server.Server</span><br><span class="line">   Run() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.topgoer.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1/GoMicro%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">Go Micro接口详解</a></p><h2 id="总结">总结</h2><p>看了上面那么多概念，我们可以稍微做一下梳理和总结。</p><ol><li>我们对业务需求进行梳理划分，分解一个一个的单一职责的任务，我们分别通过一个<strong>微服务</strong>来实现对应的任务。</li><li><strong>go-micro</strong>是一个可以用来实现微服务的框架，设计理念是可插拔，什么意思呢，就是组件可以随时替换，有多种实现方式。go-micro的整理设计逻辑如下图所示。<br><img src="http://www.topgoer.com/static/wei/6/1.png" alt=""></li><li>微服务在实现过程中是有一定的技术要求的。</li></ol><ul><li>服务注册与发现：用户想调用一个服务，必须首先找到这个服务，所以对于一个服务而言，就必须在开启时要进行注册，go-micro让Registry来负责这个任务，而Registry有多种实现方式，可以参见下表，而我们搭建环境的时候就用的<strong>etcd</strong>。</li><li>要进行负载均衡。用户在找同一个服务的时候可能会有多个节点实现这个服务，所以需要根据相应的<a href="https://blog.csdn.net/lihao21/article/details/54695471" target="_blank" rel="noopener">负载均衡机制</a>进行节点选择。这部分就由Selector来负责。</li><li>要进行消息编解码，不同的service在调用的时候是需要传递数据的，数据在编码和解码上要有统一的规则，从而进行序列化和反序列化。编解码支持json和<strong>protobuff</strong>。这部分的编解码工作由Codec来负责。我们在用go-micro编写微服务时，我们会按照protobuf的语法来编写<strong>proto file</strong>，然后通过protoc,protoc-gen-go,protoc-gen-mico来生成对应的消息对象以及相应服务的API.</li><li>要进行通信：这部分由transort来负责。</li><li>Broker主要对异步信息进行处理</li></ul><p>4.这几部分具体有哪些实现呢？可以看<a href="https://github.com/micro/go-plugins" target="_blank" rel="noopener">go-plugins</a>这个库中的插件的集合。</p><table><thead><tr><th>Directory</th><th>Description</th></tr></thead><tbody><tr><td>Broker</td><td>PubSub messaging; NATS, NSQ, RabbitMQ, Kafka</td></tr><tr><td>Client</td><td>RPC Clients; gRPC, HTTP</td></tr><tr><td>Codec</td><td>Message Encoding; BSON, Mercury</td></tr><tr><td>Micro</td><td>Micro Toolkit Plugins</td></tr><tr><td>Registry</td><td>Service Discovery; Etcd, Gossip, NATS</td></tr><tr><td>Selector</td><td>Load balancing; Label, Cache, Static</td></tr><tr><td>Server</td><td>RPC Servers; gRPC, HTTP</td></tr><tr><td>Transport</td><td>Bidirectional Streaming; NATS, RabbitMQ</td></tr><tr><td>Wrapper</td><td>Middleware; Circuit Breakers, Rate Limiting, Tracing, Monitoring</td></tr></tbody></table><ol start="5"><li>对我们而言如何使用go-micro呢？</li></ol><ul><li>根据服务需求来写好proto file</li><li>根据proto file 生成对应的传输对象以及服务端和客户端的api</li><li>编写服务器端和客户端代码</li><li>执行服务器端和客户端代码</li></ul><p>注意：在执行的时候可以指定最下面一层的各个组件，具体指定方式可以通过命令行指定或者设置环境变量或者直接在文件中写死等方式，更加详细的内容可以查看<a href="https://github.com/micro/go-plugins/blob/master/README.md" target="_blank" rel="noopener">Go-Plugins-README</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在搭建环境的时候其实我就有很多疑问了，怎么有这么多概念？&lt;br&gt;
微服务、RPC, gRPC, protoc等等，它们都是啥？本篇文章来进行比较详细的解释。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="go-micro" scheme="http://yoursite.com/tags/go-micro/"/>
    
  </entry>
  
</feed>
