<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingwen&#39;s blog</title>
  
  <subtitle>没有输出的输入是不完整的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-15T07:16:39.901Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李庆文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker提升-实现原理</title>
    <link href="http://yoursite.com/2020/06/15/docker-3-principle/"/>
    <id>http://yoursite.com/2020/06/15/docker-3-principle/</id>
    <published>2020-06-15T07:05:44.000Z</published>
    <updated>2020-06-15T07:16:39.901Z</updated>
    
    <content type="html"><![CDATA[<p>docker镜像是一个特殊的文件系统。<br>本篇文章将介绍如何docker镜像的层级结构，同时学习如何查看中间层镜像。</p><a id="more"></a><h2 id="docker的原理"><a href="#docker的原理" class="headerlink" title="docker的原理"></a>docker的原理</h2><p>Docker 的镜像就是它的文件系统，一个镜像可以放在另外一个镜像的上层，那么位于下层的就是它的父镜像。所以，Docker 会存在很多镜像层，每个镜像层都是只读的，并且不会改变。当我们创建一个新的容器时，Docker 会构建出一个镜像栈，并在栈的最顶层添加一个读写层，如图所示。<br><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdbf9e98a71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>其中中间的这些镜像层就是intermediate image，是不能被删除的。</p><h2 id="如何查看中间层镜像"><a href="#如何查看中间层镜像" class="headerlink" title="如何查看中间层镜像"></a>如何查看中间层镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查看镜像</span><br><span class="line">docker image ls</span><br><span class="line">//查看所有镜像（包含中间层镜像）</span><br><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure><p>带参数a选项的命令输出的结果中含有none:none标签的镜像都是intermediate image(中间层镜像)，这些镜像会被其他镜像所使用，是不能被随意删除的。</p><h2 id="none-none-标签镜像"><a href="#none-none-标签镜像" class="headerlink" title="none:none 标签镜像"></a>none:none 标签镜像</h2><p>具有none:none 标签的景象都是intermediate image吗？ 其实不是，还有一类镜像是dangling image（悬虚镜像），通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>命令展示出来的镜像也会包含none:none标签的镜像，这就是dangling image.</p><p>那么dangling image是如何产生的呢？<br>比如我们最开始通过如下命令构造一个名称为test:v1的镜像，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t test:v1 .</span><br></pre></td></tr></table></figure><p>然后我们后期对代码进行了修改，所以我们会重新构造一个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t test:v1 .</span><br></pre></td></tr></table></figure><p>我们没有为它分配新的名字，新构造的镜像还是叫做test:v1。这个时候原来的test:v1就会成为dangling image，根本没用，而且会占用存储空间。</p><p>可以通过如下命令将所有的玄虚镜像删掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>记得多关注一下docker的help文档,以查看镜像命令为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  log docker image ls --help</span><br><span class="line"></span><br><span class="line">Usage:  docker image ls [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">List images</span><br><span class="line"></span><br><span class="line">Aliases:</span><br><span class="line">  ls, images, list</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">      --digests         Show digests</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print images using a Go template</span><br><span class="line">      --no-trunc        Don&apos;t truncate output</span><br><span class="line">  -q, --quiet           Only show numeric IDs</span><br></pre></td></tr></table></figure><p>可以看到-a选项后面说，默认是隐藏intermediate images的。所以我们就可以了解到存在intermediate images 而且还可以通过在原命令的后面加参数a来查看中间层镜像。</p><p>更细节的原理可以查看这篇文章<a href="https://www.projectatomic.io/blog/2015/07/what-are-docker-none-none-images/" target="_blank" rel="noopener">What are Docker <none>:<none> images?</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker镜像是一个特殊的文件系统。&lt;br&gt;本篇文章将介绍如何docker镜像的层级结构，同时学习如何查看中间层镜像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>Docker进阶-Dockerfile的编写和使用</title>
    <link href="http://yoursite.com/2020/06/15/docker-2-dockerfile/"/>
    <id>http://yoursite.com/2020/06/15/docker-2-dockerfile/</id>
    <published>2020-06-15T06:55:13.000Z</published>
    <updated>2020-06-15T07:04:26.016Z</updated>
    
    <content type="html"><![CDATA[<p>在实际开发中完全使用他人构造好的镜像是不现实的。<br>所以本篇文章我们将会学习Dockerfile的知识，从而学习如何构造符合项目要求的镜像。</p><a id="more"></a><h2 id="Dockerfile文档展示"><a href="#Dockerfile文档展示" class="headerlink" title="Dockerfile文档展示"></a>Dockerfile文档展示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">RUN apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y python3-pip python3-dev</span><br><span class="line"></span><br><span class="line"># We copy just the requirements.txt first to leverage Docker cache</span><br><span class="line">COPY ./requirements.txt /app/requirements.txt</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">RUN python3 -m pip install --upgrade pip</span><br><span class="line">RUN pip3 install -r requirements.txt</span><br><span class="line"></span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"># ENTRYPOINT [ &quot;python3&quot; ]</span><br><span class="line"></span><br><span class="line">CMD [ &quot;python3&quot;, &quot;main.py&quot; ]</span><br></pre></td></tr></table></figure><h2 id="逐行命令解释"><a href="#逐行命令解释" class="headerlink" title="逐行命令解释"></a>逐行命令解释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1. FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">FROM 关键字会初始化一个image构造，并为后续的所有操作设置基础镜像，，上面的例子表示，该image是以ubuntu:16.04为基础构建的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. RUN apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y python3-pip python3-dev</span><br><span class="line"></span><br><span class="line">RUN 会在上一层的基础上添加新的layer,并将结果提交给下一层。RUN命令有两种形式。一种是shell格式，格式如下</span><br><span class="line">RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)</span><br><span class="line"></span><br><span class="line">另一种是exec格式，格式如下</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)</span><br><span class="line"></span><br><span class="line">&amp;&amp; \ 并不是Docker独有的，只是告诉linux这两条命令要一起执行，而不是执行两次，这样就只会产生一层layer,如果有两个RUN，那么就会产生两个中间层。 </span><br><span class="line"></span><br><span class="line">3. COPY ./requirements.txt /app/requirements.txt</span><br><span class="line">COPY 命令同样有两种形式，可以实现将源文件复制到目标位置，支持正则表达式。</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br><span class="line"></span><br><span class="line">4. WORKDIR /app</span><br><span class="line">- WORKDIR 会设置当前的工作目录，在本条指令之后的RUN, CMD, ENTRYPOINT, COPY 和 ADD目录都是在当前目录下执行的。</span><br><span class="line">- WORKDIR 可以出现多次，从而更换shell的执行路径</span><br><span class="line"></span><br><span class="line">5. RUN python3 -m pip install --upgrade pip</span><br><span class="line">6. RUN pip3 install -r requirements.txt</span><br><span class="line">RUN命令的shell形式，更新pip同时安装依赖。</span><br><span class="line"></span><br><span class="line">7. COPY . /app</span><br><span class="line">复制命令 将当前目录的所有文件复制到/app目录下</span><br><span class="line"></span><br><span class="line">8.CMD [ &quot;python3&quot;, &quot;main.py&quot; ]</span><br><span class="line">CMD的作用是提供容器的默认指令，也就是我们docker run 的最后一个参数。CMD有三种形式，在一个Dockerfile中，如果有多个CMD指令，那么只有最后一个CMD命令会起作用。</span><br><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)</span><br><span class="line">CMD command param1 param2 (shell form)</span><br><span class="line"></span><br><span class="line">如果CMD命令后只有参数，没有可执行的命令，那么它肯定是配合ENTRYPOINT使用的。同时要注意，如果是配合ENTRYPOINT的时候，CMD和ENTRYPOINT都要使用使用 JSON array 格式。如果用ENTRYPOINT进行改写，则如下所示。</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ &quot;python&quot; ]</span><br><span class="line">CMD [ &quot;main.py&quot; ]</span><br></pre></td></tr></table></figure><h2 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t kuakua:latest .</span><br><span class="line"> -t 设置镜像名称和标签，如果标签没有设定，默认是latest</span><br><span class="line"> .  在当前目录寻找Dockerfile进行镜像打包。</span><br></pre></td></tr></table></figure><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> docker run -d -p 5001:5000 --name kuakua -v /Users/liqingwen/workplace/temp/kuakua/log:/log kuakua:latest</span><br><span class="line"></span><br><span class="line">// 详细解释</span><br><span class="line">-d  表示以守护进程的形式进行执行，后台运行</span><br><span class="line">-p 5001:5000 将容器的5000端口映射到宿主机的5001端口</span><br><span class="line">--name kuakua 将当前容器命名为kuakua</span><br><span class="line">-v bind mount a volumn 将容器的log目录和本地的/Users/liqingwen/workplace/temp/kuakua/log做一个映射。如果容器端log目录下有内容更新，则本地的log目录也会同步更新。</span><br><span class="line">kuakua:latest 镜像名称</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">dockerfile 官方参考文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际开发中完全使用他人构造好的镜像是不现实的。&lt;br&gt;所以本篇文章我们将会学习Dockerfile的知识，从而学习如何构造符合项目要求的镜像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="dockerfile" scheme="http://yoursite.com/tags/dockerfile/"/>
    
  </entry>
  
  <entry>
    <title>Docker初探-认识并使用docker</title>
    <link href="http://yoursite.com/2020/06/15/docker-fundamentals/"/>
    <id>http://yoursite.com/2020/06/15/docker-fundamentals/</id>
    <published>2020-06-15T03:14:10.000Z</published>
    <updated>2020-06-15T06:45:56.831Z</updated>
    
    <content type="html"><![CDATA[<p>docker是目前最流行的虚拟化技术。<br>本篇文章主要介绍docker的基本概念以及初步尝试使用docker技术。</p><a id="more"></a><h2 id="docker是什么"><a href="#docker是什么" class="headerlink" title="docker是什么"></a>docker是什么</h2><p> Docker 属于 Linux容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p><p> Docker将应用程序与该程序的依赖，打包在一个文件里面。只要运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。</p><h2 id="docker好在哪"><a href="#docker好在哪" class="headerlink" title="docker好在哪"></a>docker好在哪</h2><ol><li>更高效的利用系统资源</li><li>更快速的启动时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>容易迁移、维护和扩展</li></ol><h2 id="docker专有名词"><a href="#docker专有名词" class="headerlink" title="docker专有名词"></a>docker专有名词</h2><ol><li>镜像，image, 包括各种环境的定义和说明。</li><li>容器，container, 是一个镜像的运行实体，不同容器之间是相互隔离的。</li><li>仓库，镜像的仓库，用于用户发布自己的镜像或者查找自己需要的镜像，目前最大的公开仓库为<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker hub</a>,一个项目star越多，说明项目越好越稳定。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdab4a554d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><p>如果是mac或者windows用户，可以直接使用Docker Desktop来可视化处理<br>如果是linux用户，需要通过命令行来启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start/stop/restart</span><br></pre></td></tr></table></figure><h3 id="使用docker"><a href="#使用docker" class="headerlink" title="使用docker"></a>使用docker</h3><ol><li>help帮助命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image --help</span><br></pre></td></tr></table></figure>通过这条命令可以查看与docker的镜像相关的命令<br>将image替换为container，则可以查看到关于container的相关帮助。<br>同时，可以进一步查看相关命令的细节，比如下面的命令就可以查看image下prune命令的细节。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune --help</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>搜索并拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 搜索与ubuntu相关的image</span><br><span class="line">docker search ubuntu</span><br><span class="line"></span><br><span class="line">// 拉取镜像到本地</span><br><span class="line">docker pull ubuntu</span><br><span class="line"></span><br><span class="line">// 如果没有特别声明tag,会默认使用latest标签。</span><br><span class="line">// 当然可以去docker hub去查找image并查看更加细节的东西，比如版本信息，然后在拉取的时候可以指定版本。</span><br><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure></li><li><p>列出当前本地的所有镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">或者</span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>如果想同时查看中间层镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images -a</span><br><span class="line">或者</span><br><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure></li><li><p>删除本地镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 删除固定的某个镜像</span><br><span class="line">docker rmi imageid</span><br><span class="line">docker image rm imageid</span><br><span class="line"></span><br><span class="line">//删除所有玄虚镜像</span><br><span class="line">docker image prune</span><br><span class="line"></span><br><span class="line">// 删除所有玄虚镜像和未使用的景象</span><br><span class="line">docker image prune -a</span><br><span class="line"></span><br><span class="line">// 删除所有仓库名为redis的镜像</span><br><span class="line">docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure></li><li><p>启动一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 从image启动一个容器</span><br><span class="line">docker run -it --name ubuntu  ubuntu:18.04  /bin/bash</span><br><span class="line"> -i : Keep STDIN open even if not attached 即使没有连接，也要保持标准输入保持打开状态</span><br><span class="line"> -t : Allocate a pseudo-TTY  分配一个伪tty</span><br><span class="line"> -name ubuntu : 为当前容器分配名字为ubuntu</span><br><span class="line"> ubuntu:18.04 ：要运行的镜像</span><br><span class="line"> /bin/bash ：要执行的命令。</span><br><span class="line"></span><br><span class="line">还有一个参数非常常见 </span><br><span class="line"> -d : Run container in background and print container ID 在后台运行容器，且打印容器id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 把之前停止的容器重新启动</span><br><span class="line">docker start containerid</span><br><span class="line">docker attach containerid</span><br></pre></td></tr></table></figure><p>使用docker run命令来启动容器，docker在后台运行的标准操作包括</p><ol><li>检查本地是否存在指定的镜像，不存在则从公有仓库下载</li><li>使用镜像创建并启动容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中去</li><li>从地址池分配一个ip地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕之后容器被终止</li></ol></li></ol><p>需要注意的是，对于容器要执行的命令而言，如果执行结束，那么容器就会关闭。</p><ol start="6"><li><p>查看当前正在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>如果还想查看已经退出的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>连接一个执行之中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container exec -it containerid</span><br></pre></td></tr></table></figure></li><li><p>退出正在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctrl + D</span><br><span class="line">或者</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li><li><p>查看镜像所占空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure></li><li><p>删除某些名称中含有dingms的container</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm $(docker ps -a |grep dingms | awk &apos;&#123;print $1&#125;&apos;)</span><br></pre></td></tr></table></figure></li><li><p>守护态进程<br>很多时候，需要让docker在后台运行而不是直接把结果输出到当前宿主下面，这个时候可以用守护态运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 没有使用守护态，始终在本地终端输出</span><br><span class="line">docker run  ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line"></span><br><span class="line">//使用守护态,不在本地终端输出，但是在最后结果输出</span><br><span class="line">docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">// 查看当前contain</span><br><span class="line">docker container ls</span><br><span class="line">docker container logs containerid</span><br></pre></td></tr></table></figure></li><li><p>终止某个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop containerid</span><br></pre></td></tr></table></figure><p>对于正在运行中的容器，重新启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container restart containerid</span><br></pre></td></tr></table></figure></li><li><p>进入容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker attach containerid</span><br><span class="line"></span><br><span class="line">docker exec -it containerid bash</span><br><span class="line"></span><br><span class="line">用attach进入终端之后，如果exit会直接让容器终止。</span><br><span class="line">但是exec通过exit退出之后，容器不会终止。</span><br></pre></td></tr></table></figure></li><li><p>镜像打包和加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 打包镜像</span><br><span class="line">docker save -o ~/Desktop/kuakua.tar kuakua:latest</span><br><span class="line">// 加载tar包到对应的镜像</span><br><span class="line">docker load -i ~/Desktop/kuakua.tar</span><br></pre></td></tr></table></figure></li><li><p>导出和导入容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 导出容器快照文件到本地文件</span><br><span class="line">docker export containerid &gt; name.tar</span><br><span class="line">// 从容器快照文件再导入为镜像</span><br><span class="line">cat name.tar | docker import - test/name:v1.0</span><br><span class="line">// 查看所属镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p>从网上找到一个非常棒的图<br><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdbf14142a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">Docker 从入门到实践</a></li><li><a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="noopener">Docker-cli官方文档</a></li><li><a href="https://juejin.im/post/5cacbfd7e51d456e8833390c#heading-0" target="_blank" rel="noopener">30 分钟快速入门 Docker 教程</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker是目前最流行的虚拟化技术。&lt;br&gt;本篇文章主要介绍docker的基本概念以及初步尝试使用docker技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>go-get碰到timeout怎么办</title>
    <link href="http://yoursite.com/2020/04/23/go-micro-bug-io-timeout/"/>
    <id>http://yoursite.com/2020/04/23/go-micro-bug-io-timeout/</id>
    <published>2020-04-23T12:49:48.000Z</published>
    <updated>2020-04-23T13:42:28.357Z</updated>
    
    <content type="html"><![CDATA[<p>go get 下载资源的时候下载缓慢甚至遇到timeout,可以通过设置代理的方式来解决。</p><a id="more"></a><p>通过如下命令可以查看go对应的各类变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure><p>我们重点要看.GO111MODULE这两个选项。</p><ol><li>GOPROXY: 代表是使用代理。</li><li>GO111MODULE: 表示是否使用module.在Go1.11版本之后就非常推荐使用go module 来管理依赖了。所以非常推荐使用。</li></ol><h2 id="Linux-或者-Mac环境下"><a href="#Linux-或者-Mac环境下" class="headerlink" title="Linux 或者 Mac环境下"></a>Linux 或者 Mac环境下</h2><p>直接修改环境变量就可以啦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line">export GO111MODULE=on</span><br><span class="line">export GOPROXY=https://goproxy.io </span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>通过go env再查看一下，上面的路径是否生效。若已经生效，则重新 go get 下载资源即可。</p><h2 id="GO-Land-开发"><a href="#GO-Land-开发" class="headerlink" title="GO Land 开发"></a>GO Land 开发</h2><p>GO111MODULE=ON还是要通过上面的方式进行设定。 </p><p>如果是使用goland,还可以依次的点击如下选项设置proxy。<br>GOLAND-&gt;Preferences-&gt;Go-&gt;Go modules(vgo)-&gt;选中Enable Go module integration.<br>同时设置proxy的值为 <a href="https://goproxy.io" target="_blank" rel="noopener">https://goproxy.io</a> 或者 <a href="https://goproxy.cn,direct" target="_blank" rel="noopener">https://goproxy.cn,direct</a><br>点击apply就行。</p><p>通过go env再查看一下，上面的路径是否生效。若已经生效，则重新 go get 下载资源即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go get 下载资源的时候下载缓慢甚至遇到timeout,可以通过设置代理的方式来解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Bugs" scheme="http://yoursite.com/categories/Bugs/"/>
    
    
      <category term="go-micro" scheme="http://yoursite.com/tags/go-micro/"/>
    
      <category term="timout" scheme="http://yoursite.com/tags/timout/"/>
    
      <category term="proxy" scheme="http://yoursite.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>【微服务Go-micro第三篇】相关概念解释</title>
    <link href="http://yoursite.com/2020/04/23/go-micro-3-concept-interpretation/"/>
    <id>http://yoursite.com/2020/04/23/go-micro-3-concept-interpretation/</id>
    <published>2020-04-23T10:51:33.000Z</published>
    <updated>2020-04-23T11:06:52.405Z</updated>
    
    <content type="html"><![CDATA[<p>在搭建环境的时候其实我就有很多疑问了，怎么有这么多概念？<br>微服务、RPC, gRPC, protoc等等，它们都是啥？本篇文章来进行比较详细的解释。</p><a id="more"></a><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>使用一套小服务来开发单个应用的方式，每个服务运行在独立的进程里，一般采用轻量级的通讯机制互联，并且它们可以通过自动化的方式部署。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><ol><li>远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议</li><li>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li><li>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用</li></ol><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><ol><li>gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统</li><li>gRPC客户端和服务端可以在多种环境中运行和交互，例如用java写一个服务端，可以用go语言写客户端调用</li></ol><h2 id="protobuff"><a href="#protobuff" class="headerlink" title="protobuff"></a>protobuff</h2><ol><li>gRPC可以实现微服务，将大的项目拆分为多个小且独立的业务模块，也就是服务，各服务间使用高效的protobuf协议进行RPC调用，gRPC默认使用protocol  buffer，这是google开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如JSON）</li><li>可以用proto files创建gRPC服务，用message类型来定义方法参数和返回类型</li></ol><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>结合这里和我们上一篇的文章，我们可以得到以下结论</p><ol><li><p>我们是使用了proto file(user.proto)来定义对应的方法和返回类型，其中message结构来定义接收参数和返回参数的名称以及类型。 service结构来定义对应的远程调用的方法和接受的对应的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service user&#123;</span><br><span class="line">        rpc RegisterUser(RegisterUserReq) returns (RegisterUserRsp)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserReq&#123;</span><br><span class="line">        string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserRsp&#123;</span><br><span class="line">        string status = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>protoc命令会按照proto文件中声明的message的格式构造传输对象。gRPC的服务器端和客户端都遵守protocal buffer协议，在客户端会序列化请求对象，在服务端反序列化请求对象，服务器端处理完成之后，序列化响应对象，客户端再反序列化响应对象。所以共同遵守protocal buff 协议让客户端和服务器端可以方便地进行通信，即使最后客户端和服务器端是用不同的语言来实现的也没有关系。</p></li></ol><h2 id="protobuf语法"><a href="#protobuf语法" class="headerlink" title="protobuf语法"></a>protobuf语法</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><ol><li>以.proto结尾</li><li>Message命名采用驼峰命名方式，字段命名采用小写字母加下划线分隔方式</li><li>结构定义可以包含：message、service、enum</li><li>可以通过required表示这个参数是必须的，optional表示这个参数是可选的。通过default表示这个参数的默认值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; // </span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;</span><br><span class="line">  optional int32 page_number = 2;</span><br><span class="line">  optional int32 result_per_page = 3 [default = 10];</span><br><span class="line">  enum Corpus &#123;</span><br><span class="line">    UNIVERSAL = 0;</span><br><span class="line">    WEB = 1;</span><br><span class="line">    IMAGES = 2;</span><br><span class="line">    LOCAL = 3;</span><br><span class="line">    NEWS = 4;</span><br><span class="line">    PRODUCTS = 5;</span><br><span class="line">    VIDEO = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  optional Corpus corpus = 4 [default = UNIVERSAL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service SearchService &#123;</span><br><span class="line">        rpc Search (SearchRequest) returns (SearchResponse) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>更多使用方式可以参见下面的两个链接。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="noopener">[译]Protobuf 语法指南</a></li><li><a href="http://www.topgoer.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Protobuf%E8%AF%AD%E6%B3%95.html" target="_blank" rel="noopener">1. Protobuf语法</a></li></ol><h2 id="Go-micro"><a href="#Go-micro" class="headerlink" title="Go-micro"></a>Go-micro</h2><h3 id="什么是go-micro"><a href="#什么是go-micro" class="headerlink" title="什么是go-micro"></a>什么是go-micro</h3><p>go-micro是一个框架，提供了分布式开发所需要的核心需求，包括RPC和基于事件驱动的通信。设计理念是可插拔。</p><h3 id="Go-micro特点"><a href="#Go-micro特点" class="headerlink" title="Go-micro特点"></a>Go-micro特点</h3><ol><li>服务发现：自动服务注册和命名解析。服务发现是微服务开发中的核心，当服务A要与服务B协作时，它得知道服务B在哪里。目前默认的服务发现机制是组播multicast DNS (mdns，组播)，是一种零配置网络。</li><li>负载均衡：在服务发现的基础上构建客户端的负载均衡。当我们查找一个服务发现它有多个节点时，我们需要一种机制来决定最终路由到哪一个节点。默认使用random hashed load balancing来提供服务的负载均衡。如果出现问题，那么go-micro会尝试使用其他节点。</li><li>消息编码：基于内容类型动态编码消息，客户端和服务器端将会使用基于内容类型的编解码器来对Go语言的类型进行无缝隙的编解码。客户端可以编码并发送各种类型额消息，客户端和服务器端默认能够处理这些消息，默认包含 protobuf and json。</li><li>请求/相应：RPC通信是基于双向信息流的请求和相应。go-micro提供一种同步的抽象。一个发送给服务的请求会被自动的解析、负载均衡、拨号、转成字节流。默认传输是通过gRPC。</li><li>异步信息：发布订阅机制在异步通信和事件驱动架构中非常重要，事件通知在微服务开发中占有重要地位。默认的消息传递系统是http事件消息代理。</li><li>可插拔： Go Micro为每个分布式系统抽象出接口。因此，Go Micro的接口都是可插拔的，允许其在运行时不可知的情况下仍可支持。所以只要实现接口，可以在内部使用任何的技术。更多插件请参考：github.com/micro/go-plugins</li></ol><h3 id="go-micro通信流程"><a href="#go-micro通信流程" class="headerlink" title="go-micro通信流程"></a>go-micro通信流程</h3><ol><li>Server监听客户端的调用，对Brocker推送过来的信息进行处理。并且Server端需要向Register注册自己的存在或消亡，这样Client才能知道自己的状态</li><li>Register服务的注册的发现，Client端从Register中得到Server的信息，然后每次调用都根据算法选择一个的Server进行通信，当然通信是要经过编码/解码，选择传输协议等一系列过程的</li><li>如果有需要通知所有的Server端可以使用Brocker进行信息的推送，Brocker 信息队列进行信息的接收和发布</li></ol><h3 id="go-micro接口"><a href="#go-micro接口" class="headerlink" title="go-micro接口"></a>go-micro接口</h3><p>go-micro之所以可以高度订制和他的框架结构是分不开的，go-micro由8个关键的interface组成，每一个interface都可以根据自己的需求重新实现，这8个主要的inteface也构成了go-micro的框架结构<br><img src="http://www.topgoer.com/static/wei/6/1.png" alt=""></p><h3 id="go-micro-接口详解"><a href="#go-micro-接口详解" class="headerlink" title="go-micro 接口详解"></a>go-micro 接口详解</h3><h4 id="Transort通信接口"><a href="#Transort通信接口" class="headerlink" title="Transort通信接口"></a>Transort通信接口</h4><p>通信相关接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type Socket interface &#123;</span><br><span class="line">   Recv(*Message) error</span><br><span class="line">   Send(*Message) error</span><br><span class="line">   Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Client interface &#123;</span><br><span class="line">   Socket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Listener interface &#123;</span><br><span class="line">   Addr() string</span><br><span class="line">   Close() error</span><br><span class="line">   Accept(func(Socket)) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Transport interface &#123;</span><br><span class="line">   Dial(addr string, opts ...DialOption) (Client, error)</span><br><span class="line">   Listen(addr string, opts ...ListenOption) (Listener, error)</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Codec编码接口"><a href="#Codec编码接口" class="headerlink" title="Codec编码接口"></a>Codec编码接口</h4><p>编解码，底层也是protobuf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Codec interface &#123;</span><br><span class="line">   ReadHeader(*Message, MessageType) error</span><br><span class="line">   ReadBody(interface&#123;&#125;) error</span><br><span class="line">   Write(*Message, interface&#123;&#125;) error</span><br><span class="line">   Close() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.1.3. Registry注册接口<br>服务注册发现的实现：etcd、consul、mdns、kube-DNS、zk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Registry interface &#123;</span><br><span class="line">   Register(*Service, ...RegisterOption) error</span><br><span class="line">   Deregister(*Service) error</span><br><span class="line">   GetService(string) ([]*Service, error)</span><br><span class="line">   ListServices() ([]*Service, error)</span><br><span class="line">   Watch(...WatchOption) (Watcher, error)</span><br><span class="line">   String() string</span><br><span class="line">   Options() Options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Selector负载均衡"><a href="#Selector负载均衡" class="headerlink" title="Selector负载均衡"></a>Selector负载均衡</h4><p>根据不同算法请求主机列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Selector interface &#123;</span><br><span class="line">   Init(opts ...Option) error</span><br><span class="line">   Options() Options</span><br><span class="line">   // Select returns a function which should return the next node</span><br><span class="line">   Select(service string, opts ...SelectOption) (Next, error)</span><br><span class="line">   // Mark sets the success/error against a node</span><br><span class="line">   Mark(service string, node *registry.Node, err error)</span><br><span class="line">   // Reset returns state back to zero for a service</span><br><span class="line">   Reset(service string)</span><br><span class="line">   // Close renders the selector unusable</span><br><span class="line">   Close() error</span><br><span class="line">   // Name of the selector</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Broker发布订阅接口"><a href="#Broker发布订阅接口" class="headerlink" title="Broker发布订阅接口"></a>Broker发布订阅接口</h4><p>pull push watch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Broker interface &#123;</span><br><span class="line">   Options() Options</span><br><span class="line">   Address() string</span><br><span class="line">   Connect() error</span><br><span class="line">   Disconnect() error</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Publish(string, *Message, ...PublishOption) error</span><br><span class="line">   Subscribe(string, Handler, ...SubscribeOption) (Subscriber, error)</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Client客户端接口"><a href="#Client客户端接口" class="headerlink" title="Client客户端接口"></a>Client客户端接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Client interface &#123;</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Options() Options</span><br><span class="line">   NewMessage(topic string, msg interface&#123;&#125;, opts ...MessageOption) Message</span><br><span class="line">   NewRequest(service, method string, req interface&#123;&#125;, reqOpts ...RequestOption) Request</span><br><span class="line">   Call(ctx context.Context, req Request, rsp interface&#123;&#125;, opts ...CallOption) error</span><br><span class="line">   Stream(ctx context.Context, req Request, opts ...CallOption) (Stream, error)</span><br><span class="line">   Publish(ctx context.Context, msg Message, opts ...PublishOption) error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Server服务端接口"><a href="#Server服务端接口" class="headerlink" title="Server服务端接口"></a>Server服务端接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Server interface &#123;</span><br><span class="line">   Options() Options</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Handle(Handler) error</span><br><span class="line">   NewHandler(interface&#123;&#125;, ...HandlerOption) Handler</span><br><span class="line">   NewSubscriber(string, interface&#123;&#125;, ...SubscriberOption) Subscriber</span><br><span class="line">   Subscribe(Subscriber) error</span><br><span class="line">   Register() error</span><br><span class="line">   Deregister() error</span><br><span class="line">   Start() error</span><br><span class="line">   Stop() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Serveice接口"><a href="#Serveice接口" class="headerlink" title="Serveice接口"></a>Serveice接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Service interface &#123;</span><br><span class="line">   Init(...Option)</span><br><span class="line">   Options() Options</span><br><span class="line">   Client() client.Client</span><br><span class="line">   Server() server.Server</span><br><span class="line">   Run() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.topgoer.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1/GoMicro%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">Go Micro接口详解</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了上面那么多概念，我们可以稍微做一下梳理和总结。</p><ol><li>我们对业务需求进行梳理划分，分解一个一个的单一职责的任务，我们分别通过一个<strong>微服务</strong>来实现对应的任务。</li><li><strong>go-micro</strong>是一个可以用来实现微服务的框架，设计理念是可插拔，什么意思呢，就是组件可以随时替换，有多种实现方式。go-micro的整理设计逻辑如下图所示。<br><img src="http://www.topgoer.com/static/wei/6/1.png" alt=""></li><li>微服务在实现过程中是有一定的技术要求的。</li></ol><ul><li>服务注册与发现：用户想调用一个服务，必须首先找到这个服务，所以对于一个服务而言，就必须在开启时要进行注册，go-micro让Registry来负责这个任务，而Registry有多种实现方式，可以参见下表，而我们搭建环境的时候就用的<strong>etcd</strong>。</li><li>要进行负载均衡。用户在找同一个服务的时候可能会有多个节点实现这个服务，所以需要根据相应的<a href="https://blog.csdn.net/lihao21/article/details/54695471" target="_blank" rel="noopener">负载均衡机制</a>进行节点选择。这部分就由Selector来负责。</li><li>要进行消息编解码，不同的service在调用的时候是需要传递数据的，数据在编码和解码上要有统一的规则，从而进行序列化和反序列化。编解码支持json和<strong>protobuff</strong>。这部分的编解码工作由Codec来负责。我们在用go-micro编写微服务时，我们会按照protobuf的语法来编写<strong>proto file</strong>，然后通过protoc,protoc-gen-go,protoc-gen-mico来生成对应的消息对象以及相应服务的API.</li><li>要进行通信：这部分由transort来负责。</li><li>Broker主要对异步信息进行处理</li></ul><p>4.这几部分具体有哪些实现呢？可以看<a href="https://github.com/micro/go-plugins" target="_blank" rel="noopener">go-plugins</a>这个库中的插件的集合。</p><table><thead><tr><th>Directory</th><th>Description</th></tr></thead><tbody><tr><td>Broker</td><td>PubSub messaging; NATS, NSQ, RabbitMQ, Kafka</td></tr><tr><td>Client</td><td>RPC Clients; gRPC, HTTP</td></tr><tr><td>Codec</td><td>Message Encoding; BSON, Mercury</td></tr><tr><td>Micro</td><td>Micro Toolkit Plugins</td></tr><tr><td>Registry</td><td>Service Discovery; Etcd, Gossip, NATS</td></tr><tr><td>Selector</td><td>Load balancing; Label, Cache, Static</td></tr><tr><td>Server</td><td>RPC Servers; gRPC, HTTP</td></tr><tr><td>Transport</td><td>Bidirectional Streaming; NATS, RabbitMQ</td></tr><tr><td>Wrapper</td><td>Middleware; Circuit Breakers, Rate Limiting, Tracing, Monitoring</td></tr></tbody></table><ol start="5"><li>对我们而言如何使用go-micro呢？</li></ol><ul><li>根据服务需求来写好proto file</li><li>根据proto file 生成对应的传输对象以及服务端和客户端的api</li><li>编写服务器端和客户端代码</li><li>执行服务器端和客户端代码</li></ul><p>注意：在执行的时候可以指定最下面一层的各个组件，具体指定方式可以通过命令行指定或者设置环境变量或者直接在文件中写死等方式，更加详细的内容可以查看<a href="https://github.com/micro/go-plugins/blob/master/README.md" target="_blank" rel="noopener">Go-Plugins-README</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在搭建环境的时候其实我就有很多疑问了，怎么有这么多概念？&lt;br&gt;微服务、RPC, gRPC, protoc等等，它们都是啥？本篇文章来进行比较详细的解释。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="go-micro" scheme="http://yoursite.com/tags/go-micro/"/>
    
  </entry>
  
  <entry>
    <title>【微服务Go-micro第二篇】protoc到底干了啥</title>
    <link href="http://yoursite.com/2020/04/22/go-micro-2-protoc-task/"/>
    <id>http://yoursite.com/2020/04/22/go-micro-2-protoc-task/</id>
    <published>2020-04-22T13:41:41.000Z</published>
    <updated>2020-04-22T13:49:59.214Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要介绍上一篇文章中利用protoc命令生成proto文件对应的另外两个文件的过程，<br>并简单介绍在实际业务中如何使用这两个文件。</p><a id="more"></a><h1 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h1><p>上一节我们通过下面的命令使得 user.proto</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=. --micro_out=. --go_out=. proto/greeter.proto</span><br></pre></td></tr></table></figure><p>生成了如下两个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.pb.go  user.pb.micro.go</span><br></pre></td></tr></table></figure><p>我们现在可以解释为什么会出现这种情况啦。</p><ol><li><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">protoc</a>是一个代码生成的工具，它其实可以生成多种语言对应的文件,包括但是不限于c++,java,js,python,c#,当然也包括Go。</li><li>可以根据命令的参数格式发现–go_out实际上就是将生成的go语言的文件放到当前目录。然后–micro_out就是将生成的微服务的文件放到当前目录，所以就生成了上面的两个文件。</li><li>具体是怎么生成的呢？先说生成的go文件，这个文件我看了一下其实主要就是对于proto文件中的message进行编写。因为这个message将会是之后服务器和客户端进行通信的对象结构，所以有一些通用的方法，比如结构体定义，string方法等，在后面微服务的时候可以调用它。再说生成的micro文件，这个文件会针对于service中rpc的定义进行展开。会提供客户端和服务器端对应的api。</li><li>先说服务器端api的调用和对应api的使用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type UserHandler interface &#123;</span><br><span class="line">        RegisterUser(context.Context, *RegisterUserReq, *RegisterUserRsp) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RegisterUserHandler(s server.Server, hdlr UserHandler, opts ...server.HandlerOption) error &#123;</span><br><span class="line">        type user interface &#123;</span><br><span class="line">                RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error</span><br><span class="line">        &#125;</span><br><span class="line">        type User struct &#123;</span><br><span class="line">                user</span><br><span class="line">        &#125;</span><br><span class="line">        h := &amp;userHandler&#123;hdlr&#125;</span><br><span class="line">        return s.Handle(s.NewHandler(&amp;User&#123;h&#125;, opts...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userHandler struct &#123;</span><br><span class="line">        UserHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *userHandler) RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error &#123;</span><br><span class="line">        return h.UserHandler.RegisterUser(ctx, in, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>server端api主要要创建一个服务，然后针对于这个服务提供handler方法，对应的handler要实现接口RegisterUser中的方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type User struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func(user *User)  RegisterUser(ctx context.Context, req  *proto.RegisterUserReq,  rsp *proto.RegisterUserRsp) (error)&#123;</span><br><span class="line">        rsp.Status =&quot;ok&quot;+req.Name</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建服务</span><br><span class="line">service := micro.NewService(</span><br><span class="line">                micro.Name(&quot;user&quot;),</span><br><span class="line">        )</span><br><span class="line">proto.RegisterUserHandler(service.Server(), new(User))</span><br></pre></td></tr></table></figure>更详细的代码可以查看后面的main.go</li><li>再说客户端的api和对应api的使用<br>生成的客户端的api如下所示<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type UserService interface &#123;</span><br><span class="line">        RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userService struct &#123;</span><br><span class="line">        c    client.Client</span><br><span class="line">        name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewUserService(name string, c client.Client) UserService&#123;```&#125;</span><br><span class="line"></span><br><span class="line">func (c *userService) RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error) &#123;···&#125;</span><br></pre></td></tr></table></figure>所以在我们使用的时候，要首先通过NewUserService得到对应的service,然后调用RegisterUser方法来得到请求结果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">userService := proto.NewUserService(&quot;user&quot;, service.Client())</span><br><span class="line"></span><br><span class="line">// Call the userregister</span><br><span class="line">rsp, err := userService.RegisterUser(context.TODO(), &amp;proto.RegisterUserReq&#123;Name: &quot;John&quot;&#125;)</span><br></pre></td></tr></table></figure>更加详细的代码可以参见后面client.go中的代码。</li></ol><h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><h2 id="1-user-proto"><a href="#1-user-proto" class="headerlink" title="1.  user.proto"></a>1.  user.proto</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service user&#123;</span><br><span class="line">        rpc RegisterUser(RegisterUserReq) returns (RegisterUserRsp)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserReq&#123;</span><br><span class="line">        string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserRsp&#123;</span><br><span class="line">        string status = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-user-pb-go"><a href="#2-user-pb-go" class="headerlink" title="2. user.pb.go"></a>2. user.pb.go</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">// Code generated by protoc-gen-go. DO NOT EDIT.</span><br><span class="line">// versions:</span><br><span class="line">//      protoc-gen-go v1.21.0</span><br><span class="line">//      protoc        v3.11.4</span><br><span class="line">// source: proto/user.proto</span><br><span class="line"></span><br><span class="line">package user</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        proto &quot;github.com/golang/protobuf/proto&quot;</span><br><span class="line">        protoreflect &quot;google.golang.org/protobuf/reflect/protoreflect&quot;</span><br><span class="line">        protoimpl &quot;google.golang.org/protobuf/runtime/protoimpl&quot;</span><br><span class="line">        reflect &quot;reflect&quot;</span><br><span class="line">        sync &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">        // Verify that this generated code is sufficiently up-to-date.</span><br><span class="line">        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)</span><br><span class="line">        // Verify that runtime/protoimpl is sufficiently up-to-date.</span><br><span class="line">        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// This is a compile-time assertion that a sufficiently up-to-date version</span><br><span class="line">// of the legacy proto package is being used.</span><br><span class="line">const _ = proto.ProtoPackageIsVersion4</span><br><span class="line"></span><br><span class="line">type RegisterUserReq struct &#123;</span><br><span class="line">        state         protoimpl.MessageState</span><br><span class="line">        sizeCache     protoimpl.SizeCache</span><br><span class="line">        unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">        Name string `protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) Reset() &#123;</span><br><span class="line">        *x = RegisterUserReq&#123;&#125;</span><br><span class="line">        if protoimpl.UnsafeEnabled &#123;</span><br><span class="line">                mi := &amp;file_proto_user_proto_msgTypes[0]</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                ms.StoreMessageInfo(mi)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) String() string &#123;</span><br><span class="line">        return protoimpl.X.MessageStringOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*RegisterUserReq) ProtoMessage() &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) ProtoReflect() protoreflect.Message &#123;</span><br><span class="line">        mi := &amp;file_proto_user_proto_msgTypes[0]</span><br><span class="line">        if protoimpl.UnsafeEnabled &amp;&amp; x != nil &#123;</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                if ms.LoadMessageInfo() == nil &#123;</span><br><span class="line">                        ms.StoreMessageInfo(mi)</span><br><span class="line">                &#125;</span><br><span class="line">                return ms</span><br><span class="line">        &#125;</span><br><span class="line">        return mi.MessageOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Deprecated: Use RegisterUserReq.ProtoReflect.Descriptor instead.</span><br><span class="line">func (*RegisterUserReq) Descriptor() ([]byte, []int) &#123;</span><br><span class="line">        return file_proto_user_proto_rawDescGZIP(), []int&#123;0&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) GetName() string &#123;</span><br><span class="line">        if x != nil &#123;</span><br><span class="line">                return x.Name</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RegisterUserRsp struct &#123;</span><br><span class="line">        state         protoimpl.MessageState</span><br><span class="line">        sizeCache     protoimpl.SizeCache</span><br><span class="line">        unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">        Status string `protobuf:&quot;bytes,1,opt,name=status,proto3&quot; json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) Reset() &#123;</span><br><span class="line">        *x = RegisterUserRsp&#123;&#125;</span><br><span class="line">        if protoimpl.UnsafeEnabled &#123;</span><br><span class="line">                mi := &amp;file_proto_user_proto_msgTypes[1]</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                ms.StoreMessageInfo(mi)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) String() string &#123;</span><br><span class="line">        return protoimpl.X.MessageStringOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*RegisterUserRsp) ProtoMessage() &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) ProtoReflect() protoreflect.Message &#123;</span><br><span class="line">        mi := &amp;file_proto_user_proto_msgTypes[1]</span><br><span class="line">        if protoimpl.UnsafeEnabled &amp;&amp; x != nil &#123;</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                if ms.LoadMessageInfo() == nil &#123;</span><br><span class="line">                        ms.StoreMessageInfo(mi)</span><br><span class="line">                &#125;</span><br><span class="line">                return ms</span><br><span class="line">        &#125;</span><br><span class="line">        return mi.MessageOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Deprecated: Use RegisterUserRsp.ProtoReflect.Descriptor instead.</span><br><span class="line">func (*RegisterUserRsp) Descriptor() ([]byte, []int) &#123;</span><br><span class="line">        return file_proto_user_proto_rawDescGZIP(), []int&#123;1&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) GetStatus() string &#123;</span><br><span class="line">        if x != nil &#123;</span><br><span class="line">                return x.Status</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var File_proto_user_proto protoreflect.FileDescriptor</span><br><span class="line"></span><br><span class="line">var file_proto_user_proto_rawDesc = []byte&#123;</span><br><span class="line">        0x0a, 0x10, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f,</span><br><span class="line">        0x74, 0x6f, 0x22, 0x25, 0x0a, 0x0f, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73,</span><br><span class="line">        0x65, 0x72, 0x52, 0x65, 0x71, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,</span><br><span class="line">        0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x29, 0x0a, 0x0f, 0x52, 0x65, 0x67,</span><br><span class="line">        0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x73, 0x70, 0x12, 0x16, 0x0a, 0x06,</span><br><span class="line">        0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74,</span><br><span class="line">         0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x73, 0x70, 0x12, 0x16, 0x0a, 0x06,</span><br><span class="line">        0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74,</span><br><span class="line">        0x61, 0x74, 0x75, 0x73, 0x32, 0x3c, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x34, 0x0a, 0x0c,</span><br><span class="line">        0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x12, 0x10, 0x2e, 0x52,</span><br><span class="line">        0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x1a, 0x10,</span><br><span class="line">        0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x73, 0x70,</span><br><span class="line">        0x22, 0x00, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">        file_proto_user_proto_rawDescOnce sync.Once</span><br><span class="line">        file_proto_user_proto_rawDescData = file_proto_user_proto_rawDesc</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func file_proto_user_proto_rawDescGZIP() []byte &#123;</span><br><span class="line">        file_proto_user_proto_rawDescOnce.Do(func() &#123;</span><br><span class="line">                file_proto_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_user_proto_rawDescData)</span><br><span class="line">        &#125;)</span><br><span class="line">        return file_proto_user_proto_rawDescData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var file_proto_user_proto_msgTypes = make([]protoimpl.MessageInfo, 2)</span><br><span class="line">var file_proto_user_proto_goTypes = []interface&#123;&#125;&#123;</span><br><span class="line">        (*RegisterUserReq)(nil), // 0: RegisterUserReq</span><br><span class="line">        (*RegisterUserRsp)(nil), // 1: RegisterUserRsp</span><br><span class="line">&#125;</span><br><span class="line">var file_proto_user_proto_depIdxs = []int32&#123;</span><br><span class="line">        0, // 0: user.RegisterUser:input_type -&gt; RegisterUserReq</span><br><span class="line">        1, // 1: user.RegisterUser:output_type -&gt; RegisterUserRsp</span><br><span class="line">        1, // [1:2] is the sub-list for method output_type</span><br><span class="line">        0, // [0:1] is the sub-list for method input_type</span><br><span class="line">        0, // [0:0] is the sub-list for extension type_name</span><br><span class="line">        0, // [0:0] is the sub-list for extension extendee</span><br><span class="line">        0, // [0:0] is the sub-list for field type_name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123; file_proto_user_proto_init() &#125;</span><br><span class="line">func file_proto_user_proto_init() &#123;</span><br><span class="line">        if File_proto_user_proto != nil &#123;</span><br><span class="line">                return</span><br><span class="line">        &#125;</span><br><span class="line">        if !protoimpl.UnsafeEnabled &#123;</span><br><span class="line">                file_proto_user_proto_msgTypes[0].Exporter = func(v interface&#123;&#125;, i int) interface&#123;&#125; &#123;</span><br><span class="line">                        switch v := v.(*RegisterUserReq); i &#123;</span><br><span class="line">                        case 0:</span><br><span class="line">                                return &amp;v.state</span><br><span class="line">                        case 1:</span><br><span class="line">                                return &amp;v.sizeCache</span><br><span class="line">                        case 2:</span><br><span class="line">                                return &amp;v.unknownFields</span><br><span class="line">                        default:</span><br><span class="line">                                return nil</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                file_proto_user_proto_msgTypes[1].Exporter = func(v interface&#123;&#125;, i int) interface&#123;&#125; &#123;</span><br><span class="line">                        switch v := v.(*RegisterUserRsp); i &#123;</span><br><span class="line">                        case 0:</span><br><span class="line">                                return &amp;v.state</span><br><span class="line">                        case 1:</span><br><span class="line">                                return &amp;v.sizeCache</span><br><span class="line">                        case 2:</span><br><span class="line">                                return &amp;v.unknownFields</span><br><span class="line">                        default:</span><br><span class="line">                                return nil</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        type x struct&#123;&#125;</span><br><span class="line">        out := protoimpl.TypeBuilder&#123;</span><br><span class="line">                File: protoimpl.DescBuilder&#123;</span><br><span class="line">                        GoPackagePath: reflect.TypeOf(x&#123;&#125;).PkgPath(),</span><br><span class="line">                        RawDescriptor: file_proto_user_proto_rawDesc,</span><br><span class="line">                        NumEnums:      0,</span><br><span class="line">                        NumMessages:   2,</span><br><span class="line">                        NumExtensions: 0,</span><br><span class="line">                        NumServices:   1,</span><br><span class="line">                &#125;,</span><br><span class="line">                GoTypes:           file_proto_user_proto_goTypes,</span><br><span class="line">                DependencyIndexes: file_proto_user_proto_depIdxs,</span><br><span class="line">                MessageInfos:      file_proto_user_proto_msgTypes,</span><br><span class="line">        &#125;.Build()</span><br><span class="line">        File_proto_user_proto = out.File</span><br><span class="line">        file_proto_user_proto_rawDesc = nil</span><br><span class="line">        file_proto_user_proto_goTypes = nil</span><br><span class="line">        file_proto_user_proto_depIdxs = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-user-pb-micro-go"><a href="#3-user-pb-micro-go" class="headerlink" title="3. user.pb.micro.go"></a>3. user.pb.micro.go</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// Code generated by protoc-gen-micro. DO NOT EDIT.</span><br><span class="line">// source: proto/user.proto</span><br><span class="line"></span><br><span class="line">package user</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        fmt &quot;fmt&quot;</span><br><span class="line">        proto &quot;github.com/golang/protobuf/proto&quot;</span><br><span class="line">        math &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        context &quot;context&quot;</span><br><span class="line">        api &quot;github.com/micro/go-micro/v2/api&quot;</span><br><span class="line">        client &quot;github.com/micro/go-micro/v2/client&quot;</span><br><span class="line">        server &quot;github.com/micro/go-micro/v2/server&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Reference imports to suppress errors if they are not otherwise used.</span><br><span class="line">var _ = proto.Marshal</span><br><span class="line">var _ = fmt.Errorf</span><br><span class="line">var _ = math.Inf</span><br><span class="line"></span><br><span class="line">// This is a compile-time assertion to ensure that this generated file</span><br><span class="line">// is compatible with the proto package it is being compiled against.</span><br><span class="line">// A compilation error at this line likely means your copy of the</span><br><span class="line">// proto package needs to be updated.</span><br><span class="line">const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package</span><br><span class="line"></span><br><span class="line">// Reference imports to suppress errors if they are not otherwise used.</span><br><span class="line">var _ api.Endpoint</span><br><span class="line">var _ context.Context</span><br><span class="line">var _ client.Option</span><br><span class="line">var _ server.Option</span><br><span class="line"></span><br><span class="line">// Api Endpoints for User service</span><br><span class="line"></span><br><span class="line">func NewUserEndpoints() []*api.Endpoint &#123;</span><br><span class="line">        return []*api.Endpoint&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Client API for User service</span><br><span class="line"></span><br><span class="line">type UserService interface &#123;</span><br><span class="line">        RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userService struct &#123;</span><br><span class="line">        c    client.Client</span><br><span class="line">        name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewUserService(name string, c client.Client) UserService &#123;</span><br><span class="line">        return &amp;userService&#123;</span><br><span class="line">                c:    c,</span><br><span class="line">                name: name,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *userService) RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error) &#123;</span><br><span class="line">        req := c.c.NewRequest(c.name, &quot;User.RegisterUser&quot;, in)</span><br><span class="line">        out := new(RegisterUserRsp)</span><br><span class="line">        err := c.c.Call(ctx, req, out, opts...)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">                        return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">        return out, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Server API for User service</span><br><span class="line"></span><br><span class="line">type UserHandler interface &#123;</span><br><span class="line">        RegisterUser(context.Context, *RegisterUserReq, *RegisterUserRsp) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RegisterUserHandler(s server.Server, hdlr UserHandler, opts ...server.HandlerOption) error &#123;</span><br><span class="line">        type user interface &#123;</span><br><span class="line">                RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error</span><br><span class="line">        &#125;</span><br><span class="line">        type User struct &#123;</span><br><span class="line">                user</span><br><span class="line">        &#125;</span><br><span class="line">        h := &amp;userHandler&#123;hdlr&#125;</span><br><span class="line">        return s.Handle(s.NewHandler(&amp;User&#123;h&#125;, opts...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userHandler struct &#123;</span><br><span class="line">        UserHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *userHandler) RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error &#123;</span><br><span class="line">        return h.UserHandler.RegisterUser(ctx, in, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-main-go"><a href="#4-main-go" class="headerlink" title="4. main.go"></a>4. main.go</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;datatown/proto&quot;</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(user *User)  RegisterUser(ctx context.Context, req  *proto.RegisterUserReq,  rsp *proto.RegisterUserRsp) (error)&#123;</span><br><span class="line">        rsp.Status =&quot;ok&quot;+req.Name</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service. Optionally include some options here.</span><br><span class="line">        service := micro.NewService(</span><br><span class="line">                micro.Name(&quot;user&quot;),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // Init will parse the command line flags.</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Register handler</span><br><span class="line">        proto.RegisterUserHandler(service.Server(), new(User))</span><br><span class="line"></span><br><span class="line">        // Run the server</span><br><span class="line">        if err := service.Run(); err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-client-go"><a href="#5-client-go" class="headerlink" title="5. client.go"></a>5. client.go</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;datatown/proto&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service</span><br><span class="line">        service := micro.NewService(micro.Name(&quot;user.client&quot;))</span><br><span class="line">        // Initialise the client and parse command line flags</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Create new user service  client</span><br><span class="line">        userService := proto.NewUserService(&quot;user&quot;, service.Client())</span><br><span class="line"></span><br><span class="line">        // Call the userregister</span><br><span class="line">        rsp, err := userService.RegisterUser(context.TODO(), &amp;proto.RegisterUserReq&#123;Name: &quot;John&quot;&#125;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Print response</span><br><span class="line">        fmt.Println(rsp.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要介绍上一篇文章中利用protoc命令生成proto文件对应的另外两个文件的过程，&lt;br&gt;并简单介绍在实际业务中如何使用这两个文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="go-micro" scheme="http://yoursite.com/tags/go-micro/"/>
    
      <category term="protoc" scheme="http://yoursite.com/tags/protoc/"/>
    
  </entry>
  
  <entry>
    <title>【微服务Go-micro第一篇】环境配置</title>
    <link href="http://yoursite.com/2020/04/22/go-micro-1-build-environment/"/>
    <id>http://yoursite.com/2020/04/22/go-micro-1-build-environment/</id>
    <published>2020-04-22T04:50:21.000Z</published>
    <updated>2020-04-22T04:56:36.523Z</updated>
    
    <content type="html"><![CDATA[<p>go-micro 是一个基于Go语言的分布式框架，可以用来对外提供微服务。<br>本篇文章介绍如何在linux系统下进行环境配置，并写好自己的第一个helloworld程序。</p><a id="more"></a><h2 id="一、依赖安装"><a href="#一、依赖安装" class="headerlink" title="一、依赖安装"></a>一、依赖安装</h2><ol><li>依赖安装 protoc-gen-micro<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 依赖</span><br><span class="line">go get github.com/micro/micro/v2/cmd/protoc-gen-micro@master </span><br><span class="line"></span><br><span class="line">// 上述包依赖两个protoc 和protoc-gen-go </span><br><span class="line"></span><br><span class="line">// 第一个依赖安装</span><br><span class="line">//[protobuf下载](https://github.com/protocolbuffers/protobuf/releases)</span><br><span class="line">wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.4/protoc-3.11.4-linux-x86_64.zip</span><br><span class="line"></span><br><span class="line">unzip protoc-3.11.4-linux-x86_64.zip -d /root/go/gotool/</span><br><span class="line"></span><br><span class="line">// 路径修改</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line">PATH=/root/go/gotool/bin:$PATH</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line">// 检查是否安装成功，如果出现版本号，则说明安装成功。</span><br><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二个依赖protoc-gen-go的安装</span><br><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>依赖安装 etcd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/etcd-io/etcd/releases/download/v3.4.7/etcd-v3.4.7-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzf etcd-v3.4.7-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">cp etcd* /usr/local/bin/</span><br><span class="line"></span><br><span class="line">// 通过如下命令来启动</span><br><span class="line">etcd</span><br></pre></td></tr></table></figure><p>要声明etcd来进行注册服务，在bash_profile中添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MICRO_REGISTRY=etcd</span><br></pre></td></tr></table></figure><p>如果碰到用go get 命令报403错误可以使用代理来解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line">//添加如下内容</span><br><span class="line"></span><br><span class="line">export GOPROXY=https://goproxy.io // 设置代理</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>通过go-module来管理依赖<br>在bash_profile中添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、helloworld程序"><a href="#二、helloworld程序" class="headerlink" title="二、helloworld程序"></a>二、helloworld程序</h2><h3 id="2-1-官方实例的helloworld"><a href="#2-1-官方实例的helloworld" class="headerlink" title="2.1 官方实例的helloworld"></a>2.1 官方实例的helloworld</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/micro/micro/v2 </span><br><span class="line"></span><br><span class="line">git clone https://github.com/micro/examples.git</span><br><span class="line">cd examples/service</span><br><span class="line">go run main.go</span><br><span class="line">go run main.go --run_client</span><br></pre></td></tr></table></figure><p>结果会出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello john</span><br></pre></td></tr></table></figure><p>说明实验成功。</p><h3 id="2-2-自己编写helloworld测试"><a href="#2-2-自己编写helloworld测试" class="headerlink" title="2.2 自己编写helloworld测试"></a>2.2 自己编写helloworld测试</h3><ol><li>构造项目<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 建立项目</span><br><span class="line">mkdir hello &amp;&amp; cd  hello</span><br><span class="line"></span><br><span class="line">// 利用模块来管理相关的依赖。 </span><br><span class="line">go mod init hello</span><br></pre></td></tr></table></figure></li><li>编写服务原型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在hello目录下建立服务原型</span><br><span class="line">mkdir proto</span><br><span class="line">vim proto/greeter.proto</span><br></pre></td></tr></table></figure>greeter.proto 内容如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service Greeter &#123;</span><br><span class="line">    rpc Hello(Request) returns (Response) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">    string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    string greeting = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>根据服务原型生成对应的代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在hello目录下执行</span><br><span class="line"> protoc --proto_path=. --micro_out=. --go_out=. proto/greeter.proto</span><br></pre></td></tr></table></figure>此时在hello/proto目录下会有三个文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greeter.pb.go  </span><br><span class="line">greeter.pb.micro.go </span><br><span class="line">greeter.proto</span><br></pre></td></tr></table></figure></li><li>编写main.go文件作为服务器代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vim main.go</span><br><span class="line">// 内容如下</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;hello/proto&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Greeter struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (g *Greeter) Hello(ctx context.Context, req *proto.Request, rsp *proto.Response) error &#123;</span><br><span class="line">        rsp.Greeting = &quot;Hello &quot; + req.Name</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service. Optionally include some options here.</span><br><span class="line">        service := micro.NewService(</span><br><span class="line">                micro.Name(&quot;greeter&quot;),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // Init will parse the command line flags.</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Register handler</span><br><span class="line">        proto.RegisterGreeterHandler(service.Server(), new(Greeter))</span><br><span class="line"></span><br><span class="line">        // Run the server</span><br><span class="line">        if err := service.Run(); err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编写client.go文件作为客户端代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vim client.go</span><br><span class="line">// 内容如下</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;hello/proto&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service</span><br><span class="line">        service := micro.NewService(micro.Name(&quot;greeter.client&quot;))</span><br><span class="line">        // Initialise the client and parse command line flags</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Create new greeter client</span><br><span class="line">        greeter := proto.NewGreeterService(&quot;greeter&quot;, service.Client())</span><br><span class="line"></span><br><span class="line">        // Call the greeter</span><br><span class="line">        rsp, err := greeter.Hello(context.TODO(), &amp;proto.Request&#123;Name: &quot;kingwen&quot;&#125;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Print response</span><br><span class="line">        fmt.Println(rsp.Greeting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行程序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">etcd </span><br><span class="line">go main.go</span><br><span class="line">go client.go</span><br></pre></td></tr></table></figure>结果出现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.kingwen。</span><br></pre></td></tr></table></figure>说明程序搭建成功。</li></ol><p>最后看一下代码结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── client.go</span><br><span class="line">├── default.etcd</span><br><span class="line">│   └── member</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── proto</span><br><span class="line">    ├── greeter.pb.go</span><br><span class="line">    ├── greeter.pb.micro.go</span><br><span class="line">    └── greeter.proto</span><br></pre></td></tr></table></figure><h2 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a>三、参考链接</h2><ol><li><a href="https://xueyuanjun.com/post/21585" target="_blank" rel="noopener">基于 Go Module 管理依赖并将注册中心调整为 Etcd</a></li><li><a href="https://github.com/micro/go-micro" target="_blank" rel="noopener">go-micro-github地址</a></li><li><a href="https://micro.mu/docs/go-helloworld.html" target="_blank" rel="noopener">micro官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go-micro 是一个基于Go语言的分布式框架，可以用来对外提供微服务。&lt;br&gt;本篇文章介绍如何在linux系统下进行环境配置，并写好自己的第一个helloworld程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="Go-micro" scheme="http://yoursite.com/tags/Go-micro/"/>
    
  </entry>
  
  <entry>
    <title>scrapy-断点调试</title>
    <link href="http://yoursite.com/2020/04/08/scrapy-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2020/04/08/scrapy-断点调试/</id>
    <published>2020-04-08T03:17:04.000Z</published>
    <updated>2020-04-08T05:28:22.673Z</updated>
    
    <content type="html"><![CDATA[<p>因为平时我们在写代码的时候都会依靠于debug来进行调试，<br>那么一般通过命令行启动的scrapy项目要如何进行dubug呢？</p><a id="more"></a><p>用pycharm来解决这个问题的方式也比较简单。</p><ol><li>正常加断点</li><li>要编写一个run.py文件来模拟命令行启动,文件和spiders目录同级，内容如下。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from scrapy import cmdline</span><br><span class="line"></span><br><span class="line">name = &apos;spidername&apos;</span><br><span class="line">cmd = &apos;scrapy crawl &#123;0&#125;&apos;.format(name)</span><br><span class="line">cmdline.execute(cmd.split())</span><br></pre></td></tr></table></figure></li><li>点击右上角的debug来执行即可。</li></ol><p>再说一下debug的三个选项</p><ol><li>step into : 单步执行，遇到子函数就进入子函数。</li><li>step over: 单步执行，遇到子函数不进入，而是完成子函数之后返回到当前位置，等同于处理一条命令。</li><li>step out: 单步执行，但是已经进入到子函数了，下面的部分不再单步执行而是返回到调用子函数的位置。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为平时我们在写代码的时候都会依靠于debug来进行调试，&lt;br&gt;那么一般通过命令行启动的scrapy项目要如何进行dubug呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
      <category term="debug" scheme="http://yoursite.com/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Bug-scrapy-数据错位</title>
    <link href="http://yoursite.com/2020/04/08/Bug-scrapy-%E6%95%B0%E6%8D%AE%E9%94%99%E4%BD%8D/"/>
    <id>http://yoursite.com/2020/04/08/Bug-scrapy-数据错位/</id>
    <published>2020-04-08T02:34:43.000Z</published>
    <updated>2020-04-08T03:15:10.660Z</updated>
    
    <content type="html"><![CDATA[<p>在用scrapy进行数据爬取的时候，发现通过meta传递的数据不匹配，最后发现是深拷贝和浅拷贝的问题。</p><a id="more"></a><h2 id="Bug详情"><a href="#Bug详情" class="headerlink" title="Bug详情"></a>Bug详情</h2><p>yield Request中传递的meta是浅拷贝，所以当我们有多条请求等待处理的时候，前面请求传递的meta会被后面请求传递的meta修改（他们指向同一个对象），所以就会造成前后不匹配。<br>解决方式就是将其浅拷贝变成深拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">···</span><br><span class="line">def parse(self, response):</span><br><span class="line">     yield Request(url=new_url, meta=&#123;&apos;item&apos;: copy.deepcopy(item)&#125;, callback=self.another_parse)</span><br></pre></td></tr></table></figure><p>同理，如果下载的时候下载item的时候也报错的话，也要记得将item的传递变成深拷贝即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 原来是yield item ,变成如下的样子即可。</span><br><span class="line">yield copy.deepcopy(item)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1.<a href="https://www.jianshu.com/p/42f22085f4c5" target="_blank" rel="noopener">scrapy里面item传递数据后数据不正确的问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用scrapy进行数据爬取的时候，发现通过meta传递的数据不匹配，最后发现是深拷贝和浅拷贝的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
      <category term="bug" scheme="http://yoursite.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>python-域名抽取</title>
    <link href="http://yoursite.com/2020/04/04/python-%E5%9F%9F%E5%90%8D%E6%8A%BD%E5%8F%96/"/>
    <id>http://yoursite.com/2020/04/04/python-域名抽取/</id>
    <published>2020-04-04T13:47:58.000Z</published>
    <updated>2020-04-04T14:56:02.129Z</updated>
    
    <content type="html"><![CDATA[<p>在看scrapy-cluster源码的时候发现了一个非常实用的包-tldextract，<br>可以非常方便的抽取出一个url的域名作为redis的key的一部分，感觉很神奇。所以记录一下。</p><a id="more"></a><p>对于一个网址而言，比如 www.kingwen.cn，可以分为三部分。www, kingwen, cn。分别称为二级域名，域名，后缀。tldextract(top-level domain)这个包就可以帮我们非常快的解决这个问题。</p><h2 id="安装tldextract包"><a href="#安装tldextract包" class="headerlink" title="安装tldextract包"></a>安装tldextract包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tldextract</span><br></pre></td></tr></table></figure><h2 id="使用tldextract包"><a href="#使用tldextract包" class="headerlink" title="使用tldextract包"></a>使用tldextract包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import tldextract</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    url = &apos;www.kingwen.cn&apos;</span><br><span class="line">    res = tldextract.extract(url)</span><br><span class="line">    print(res.subdomain, res.domain, res.suffix) # www kingwen cn</span><br><span class="line">    print(res.registered_domain) # kingwen.cn</span><br><span class="line">    url1 = &apos;localhost:8080/hello&apos;</span><br><span class="line">    res = tldextract.extract(url1)</span><br><span class="line">    print(res.subdomain, res.domain, res.suffix) # &apos;&apos;  localhost  &apos;&apos;</span><br></pre></td></tr></table></figure><h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>主要分为三部分。</p><ul><li>首先是进行切割，将输入的url进行划分，利用# ？ @  : 等特殊符号进行不断的划分，最后将主体的域名部分提取出来。</li><li>其次将前一部分的主体域名通过&#39;.&#39;进行划分，形成对应的list。然后按照从位置i匹配到末尾元素的原则找到符合suffix字典（预先定义好的7336条）的第一个位置i.然后返回i。</li><li>最后 list[i:]就是suffix. list[:i-1]就是subdomain. list[i]就是domain.从而问题得到解决。</li></ul><p>尽管比较简单，但是比较实用，所以就记录一下。<br>在以后用到的时候可以省去很多烦恼。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看scrapy-cluster源码的时候发现了一个非常实用的包-tldextract，&lt;br&gt;可以非常方便的抽取出一个url的域名作为redis的key的一部分，感觉很神奇。所以记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="domain" scheme="http://yoursite.com/tags/domain/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Bug-Scrapy-Filtered_offsite_request</title>
    <link href="http://yoursite.com/2020/03/31/bug-Filtered-offsite-request-Scrapy/"/>
    <id>http://yoursite.com/2020/03/31/bug-Filtered-offsite-request-Scrapy/</id>
    <published>2020-03-31T01:58:03.000Z</published>
    <updated>2020-03-31T09:11:37.138Z</updated>
    
    <content type="html"><![CDATA[<p>在写爬虫的时候遇见了一个bug,报错信息为 Filtered offsite request domain[‘mydomain’],<br>从网上找到了答案并成功解决了问题，特别记录一下。</p><a id="more"></a><h2 id="检查allowed-domains"><a href="#检查allowed-domains" class="headerlink" title="检查allowed_domains"></a>检查allowed_domains</h2><p>要去查看自己爬取的url是否符合我们的domain。如果我们要爬取的网站的网址为 <a href="https://www.example.com/1.html，" target="_blank" rel="noopener">https://www.example.com/1.html，</a> 那么我们就需要添加example.com到我们写好的爬虫中的allow_domains的list列表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allowed_domains = [&apos;example.com&apos;]</span><br></pre></td></tr></table></figure><p>看一下<a href="https://docs.scrapy.org/en/latest/topics/spiders.html" target="_blank" rel="noopener">Scrapy官方文档</a>的解释。</p><blockquote><p><strong>allowed_domains</strong><br>An optional list of strings containing domains that this spider is allowed to crawl. Requests for URLs not belonging to the domain names specified in this list (or their subdomains) won’t be followed if OffsiteMiddleware is enabled.</p></blockquote><p>如果设置进行url过滤,那么对于要新添加到爬取队列中的所有的url中必须包含allow_domains中的一个域名才可以，否则这个url就会被舍弃。</p><h2 id="设置-dont-filte-True"><a href="#设置-dont-filte-True" class="headerlink" title="设置 dont_filte=True"></a>设置 dont_filte=True</h2><p>可以直接停止scrapy对于url的过滤。也就是在新生成的Request中添加 dont_filte=True，比如下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line"> yield Request(url=&apos;https://example.com&apos;, dont_filter=True, callback=self.parse2)</span><br><span class="line">def parse2(self, response):</span><br><span class="line"> pass</span><br></pre></td></tr></table></figure><p>看一下<a href="https://docs.scrapy.org/en/latest/topics/request-response.html" target="_blank" rel="noopener">Scrapy官方文档</a>的解释：</p><blockquote><p>dont_filter (boolean) – indicates that this request should not be filtered by the scheduler. This is used when you want to perform an identical request multiple times, to ignore the duplicates filter. Use it with care, or you will get into crawling loops. Default to False.</p></blockquote><p>这个方法就比较粗暴，就直接不对url进行过滤。那么也就是说对于所有的爬取到的url都会进行重新爬取，但是如果一旦有url是重复的，可能就会陷入循环。所以尽量不要采用这么暴力的方式。这也是scrapy默认将其设置为False的一个原因。</p><p>PS:一定要细心，我个人出现的问题是我想当然的设置了域名，然后真实网站的域名和我设置的域名差一个字母，所以最后就报错了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写爬虫的时候遇见了一个bug,报错信息为 Filtered offsite request domain[‘mydomain’],&lt;br&gt;从网上找到了答案并成功解决了问题，特别记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
      <category term="bug" scheme="http://yoursite.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>priority_queue的简单使用</title>
    <link href="http://yoursite.com/2020/02/08/priority-queue%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/08/priority-queue的简单使用/</id>
    <published>2020-02-08T07:56:04.000Z</published>
    <updated>2020-02-08T08:00:08.516Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第十篇.<br>主要测试了priority_queue相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><p>优先队列，也是对容器的一个封装，形成的adapter,默认每次最先获得所有值中的最大值。<br>每次插入一个新元素或者pop出一个元素之后，剩下的元素都会重新排一次序。<br>可以改变compare函数使其变成最小堆，从而每次可以获得最小值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // 声明</span><br><span class="line">    priority_queue&lt;int&gt; pq; // 默认是最大堆，可以通过下面的方式声明为最大堆。</span><br><span class="line">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq1;</span><br><span class="line">    </span><br><span class="line">    // 也可以通过如下方式直接将一个容器内的所有元素装进priority_queue中。</span><br><span class="line">    vector&lt;int&gt; a = &#123;1,4,2,3&#125;;</span><br><span class="line">    priority_queue&lt;int&gt; pq2(less&lt;int&gt;(),a); // 最大堆</span><br><span class="line">    cout&lt;&lt;&quot;qp2.top():&quot;&lt;&lt;pq2.top()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">//    下面这种方式为什么不行？？此处存疑。</span><br><span class="line">//    priority_queue&lt;int&gt; pq3(greater&lt;int&gt;(),a); //最小堆</span><br><span class="line">//    cout&lt;&lt;pq3.top()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //下面针对pq进行操作演示</span><br><span class="line">    pq.push(2);</span><br><span class="line">    pq.push(1);</span><br><span class="line">    pq.emplace(3);</span><br><span class="line">    pq.emplace(4);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;pq.size()&quot;&lt;&lt;pq.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;pq.empty()&quot;&lt;&lt;pq.empty()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    pq.pop();</span><br><span class="line">    cout&lt;&lt;&quot;after pop,pq.size()&quot;&lt;&lt;pq.size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // 遍历: priority_queue默认是最大堆，每次的通过top()获得的元素就是最大值。</span><br><span class="line">    cout&lt;&lt;&quot;pq = &quot;;</span><br><span class="line">    while(!pq.empty())&#123;</span><br><span class="line">        cout&lt;&lt;pq.top()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果。</span><br><span class="line"> qp2.top():4</span><br><span class="line"> pq.size()4</span><br><span class="line"> pq.empty()0</span><br><span class="line"> after pop,pq.size()3</span><br><span class="line"> pq = 3    2    1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第十篇.&lt;br&gt;主要测试了priority_queue相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Priority_queue" scheme="http://yoursite.com/tags/Priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>stack的简单使用</title>
    <link href="http://yoursite.com/2020/02/08/stack%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/08/stack的简单使用/</id>
    <published>2020-02-08T06:58:02.000Z</published>
    <updated>2020-02-08T07:04:26.641Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第九篇.<br>主要测试了stack相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><p>严格来讲，stack其实也不算是容器，它是在容器的基础上进行疯转从而具备后进先出(LIFO)特性的adapter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // 声明</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line">    stack&lt;int&gt; s1(&#123;1,2,3&#125;);</span><br><span class="line">    stack&lt;int&gt; s2(s1);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;s2= &quot;;</span><br><span class="line">     while(!s2.empty())&#123;</span><br><span class="line">         cout&lt;&lt;s2.top()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">         s2.pop();</span><br><span class="line">     &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //操作</span><br><span class="line">    cout&lt;&lt;&quot;s.empty(): &quot;&lt;&lt;s.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.size(): &quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    // 这里也需要注意一下，必须在确认stack中元素个数不为0的情况下，</span><br><span class="line">    // 才可以使用s.top()来获取栈顶元素，否则就会报错。</span><br><span class="line">    //cout&lt;&lt;&quot;s.top():&quot;&lt;&lt;s.top()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    s.push(1);</span><br><span class="line">    s.emplace(2);</span><br><span class="line">    cout&lt;&lt;&quot;after push2 s.size(): &quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push2 s.empty(): &quot;&lt;&lt;s.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push2 top element is\t&quot;&lt;&lt;s.top()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s.pop();</span><br><span class="line">    cout&lt;&lt;&quot;after pop(),s.size():&quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after pop(),s.top():&quot;&lt;&lt;s.top()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s.push(3);</span><br><span class="line">    s.push(4);</span><br><span class="line">    s.push(5);</span><br><span class="line">    // 遍历</span><br><span class="line">    cout&lt;&lt;&quot;after push 345,s= &quot;;</span><br><span class="line">    while(!s.empty())&#123;</span><br><span class="line">        cout&lt;&lt;s.top()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> s2= 3    2    1</span><br><span class="line"> s.empty(): 1</span><br><span class="line"> s.size(): 0</span><br><span class="line"> after push2 s.size(): 2</span><br><span class="line"> after push2 s.empty(): 0</span><br><span class="line"> after push2 top element is    2</span><br><span class="line"> after pop(),s.size():1</span><br><span class="line"> after pop(),s.top():1</span><br><span class="line"> after push 345,s= 5    4    3    1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第九篇.&lt;br&gt;主要测试了stack相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>queue的简单使用</title>
    <link href="http://yoursite.com/2020/02/08/queue%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/08/queue的简单使用/</id>
    <published>2020-02-08T06:34:31.000Z</published>
    <updated>2020-02-08T06:38:54.733Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第八篇.<br>主要测试了queue相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><p>准确来讲，queue并不是容器，而是在容器的基础上进行了一定封装的adapter.符合先进先出(FIFO)的特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // 声明</span><br><span class="line">    queue&lt;int&gt; q ;</span><br><span class="line">    queue&lt;int&gt; q1(&#123;1,2,3,4&#125;);</span><br><span class="line">    queue&lt;int&gt; q2(q1);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;q2: &quot;;</span><br><span class="line">    while(q2.size() != 0)&#123;</span><br><span class="line">         cout&lt;&lt;q2.front()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">         q2.pop();</span><br><span class="line">     &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // 其他操作。 如果队列为空，那么调用front和back的时候就会报错，</span><br><span class="line">    // 所以给我们的警示就是在通过front和back方法获取队列元素的时候，需要提前确定内部是存在对应的元素的。</span><br><span class="line">    //cout&lt;&lt;&quot;q.front():&quot;&lt;&lt;q.front()&lt;&lt;endl;</span><br><span class="line">    //cout&lt;&lt;&quot;q.back():&quot;&lt;&lt;q.back()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;q.empty():&quot;&lt;&lt;q.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;q.size():&quot;&lt;&lt;q.size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    q.push(1);</span><br><span class="line">    q.emplace(2);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;after push q.front():&quot;&lt;&lt;q.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push q.back():&quot;&lt;&lt;q.back()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push q.empty():&quot;&lt;&lt;q.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push q.size():&quot;&lt;&lt;q.size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    q.pop();</span><br><span class="line">    cout&lt;&lt;&quot;after pop(): &quot;;</span><br><span class="line">    while(q.size() != 0)&#123;</span><br><span class="line">        cout&lt;&lt;q.front()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果</span><br><span class="line"> q2: 1    2    3    4</span><br><span class="line"> q.empty():1</span><br><span class="line"> q.size():0</span><br><span class="line"> after push q.front():1</span><br><span class="line"> after push q.back():2</span><br><span class="line"> after push q.empty():0</span><br><span class="line"> after push q.size():2</span><br><span class="line"> after pop(): 2    Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第八篇.&lt;br&gt;主要测试了queue相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>multimap的简单使用</title>
    <link href="http://yoursite.com/2020/02/07/multimap%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/07/multimap的简单使用/</id>
    <published>2020-02-07T10:01:18.000Z</published>
    <updated>2020-02-07T10:15:58.751Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第七篇.<br>主要测试了multimap相关的方法，主要作为代码备份方便之后遗忘时查询。<br>map,multimap,unordered_map,unordered_multimap仅仅有稍许差别，方法和multimap基本类似，所以不再另行写文章啦。</p><a id="more"></a><h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><ol><li>map和multimap的差别仅仅在于multimap插入的key值可以相同，其他操作都类似。所有不再单独另写文章啦。</li><li>unordered_map的使用方法和map几乎完全一致。记得引入头文件然后声明的时候声明就好啦。所以也不再单独再重新写一篇文章啦。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 引入头文件</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">// 使用的时候如同下面这种方式声明即可。</span><br><span class="line">unordered_map&lt;int,int&gt; mmap;</span><br></pre></td></tr></table></figure>同样的需要记住的是，带有unordered前缀的容器都是没有upper_bound和lower_bound的。</li></ol><h2 id="multimap的测试代码"><a href="#multimap的测试代码" class="headerlink" title="multimap的测试代码"></a>multimap的测试代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class K&gt;</span><br><span class="line">void print(const string s,const K&amp; mmap)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    for(auto&amp; a:mmap)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    multimap&lt;int,char&gt; dict &#123;</span><br><span class="line">        &#123;1,&apos;A&apos;&#125;,</span><br><span class="line">        &#123;2,&apos;B&apos;&#125;,</span><br><span class="line">        &#123;2,&apos;C&apos;&#125;,</span><br><span class="line">        &#123;3,&apos;D&apos;&#125;,</span><br><span class="line">        &#123;3,&apos;E&apos;&#125;,</span><br><span class="line">        &#123;2,&apos;F&apos;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //通过empty()来判断multimap是否为空</span><br><span class="line">    cout&lt;&lt;&quot;dict.empty() &quot;&lt;&lt;dict.empty()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //通过size()来判断元素个数</span><br><span class="line">    cout&lt;&lt;&quot;dict.size() &quot;&lt;&lt;dict.size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    print(&quot;插入前 size = &quot;+to_string(dict.size()),dict);</span><br><span class="line">    // 通过insert插入元素</span><br><span class="line">    dict.insert(&#123;4,&apos;G&apos;&#125;);</span><br><span class="line">    dict.insert(pair&lt;int, char&gt;(4,&apos;F&apos;));</span><br><span class="line">    dict.insert(make_pair(4, &apos;H&apos;));</span><br><span class="line">    dict.insert(&#123;&#123;5,&apos;I&apos;&#125;,&#123;5,&apos;J&apos;&#125;&#125;);</span><br><span class="line">    print(&quot;插入后 size = &quot;+to_string(dict.size()),dict);</span><br><span class="line"></span><br><span class="line">    // 通过erase来删除特定key的元素,参数可以是key，也可以是一个iterator</span><br><span class="line">    dict.erase(1);</span><br><span class="line">    print(&quot;删除key=1后 size = &quot;+to_string(dict.size()),dict);</span><br><span class="line"></span><br><span class="line">    // 返回类型是pair&lt;iterator,iterator&gt;,仅仅返回符合条件的pair</span><br><span class="line">    auto range = dict.equal_range(2);</span><br><span class="line">    //cout&lt;&lt;typeid(range).name()&lt;&lt;endl; //pair类型</span><br><span class="line">    cout&lt;&lt;&quot;equal_range(2) &quot;&lt;&lt;endl;</span><br><span class="line">    for(auto i = range.first;i!=range.second;++i)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;i.first\t&quot;&lt;&lt;i-&gt;first&lt;&lt;&quot;\ti.second\t&quot;&lt;&lt;i-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // lower_bound</span><br><span class="line">    auto lower = dict.lower_bound(2);</span><br><span class="line">    cout&lt;&lt;&quot;lower_bound(2) &quot;&lt;&lt;(lower-&gt;first)&lt;&lt;&quot; &quot;&lt;&lt;lower-&gt;second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    // upper_bound</span><br><span class="line">    auto upper = dict.upper_bound(2);</span><br><span class="line">    cout&lt;&lt;&quot;upper_bound(2) &quot;&lt;&lt;(upper-&gt;first)&lt;&lt;&quot; &quot;&lt;&lt;upper-&gt;second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    // equal_range返回的两个pair实际上就是用lower_bound和upper_bound来实现的</span><br><span class="line">    cout&lt;&lt;&quot;lower_bound == range.first &quot;&lt;&lt; (lower == range.first)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;upper_bound == range.second &quot;&lt;&lt; (upper == range.second)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //通过count来判断key等于给定的值一共有多少个pair</span><br><span class="line">    cout&lt;&lt;&quot;count(2) &quot;&lt;&lt;dict.count(2)&lt;&lt;endl;</span><br><span class="line">    //这个数量可以通过range的两个iterator来实现查找</span><br><span class="line">    cout&lt;&lt;&quot;distance(range.first,range.second) &quot;&lt;&lt;distance(range.first,range.second)&lt;&lt;endl;</span><br><span class="line">    //或者使用lower_bound和upper_bound来实现</span><br><span class="line">    cout&lt;&lt;&quot;distance(lower,upper)&quot;&lt;&lt;distance(lower, upper)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //通过find来判断是否存在key,返回一个iterator,如果有多个key符合条件，不一定会返回哪一个。</span><br><span class="line">    auto find2 = dict.find(2);</span><br><span class="line">    cout&lt;&lt;&quot;find2 &quot;&lt;&lt;find2-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;find2-&gt;second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //如果通过find来查找的时候没有找到对应的key,那么就会返回dict.end()这个iterator</span><br><span class="line">    auto find10 = dict.find(10);</span><br><span class="line">    cout&lt;&lt;&quot;find10==dict.end &quot;&lt;&lt;(find10==dict.end())&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    auto a = dict.begin();</span><br><span class="line">    cout&lt;&lt;&quot;dict.begin().type &quot;&lt;&lt;typeid(a).name()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //关于各类iterator</span><br><span class="line">    cout&lt;&lt;&quot;正向遍历dict.begin()-&gt;dict.end()&quot;&lt;&lt;endl;</span><br><span class="line">    for(auto a = dict.begin(); a!=dict.end(); a++)&#123;</span><br><span class="line">       // a-&gt;second = &apos;M&apos;; 这里修改就没有问题</span><br><span class="line">        cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;a-&gt;second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;正向遍历，dict.cbegin()-&gt;dict.cend()&quot;&lt;&lt;endl;</span><br><span class="line">    for(auto a = dict.cbegin(); a!=dict.cend(); a++)&#123;</span><br><span class="line">       // a -&gt; second = &apos;N&apos;; 这里修改就有问题，原因是返回的const_iterator是不允许修改的。</span><br><span class="line">        cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;a-&gt;second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;反向遍历，dict.rbegin()-&gt;dict.rend()&quot;&lt;&lt;endl;</span><br><span class="line">    for(auto a = dict.rbegin(); a!=dict.rend(); a++)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;a-&gt;second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;反向遍历，dict.rbegin()-&gt;dict.rend()&quot;&lt;&lt;endl;</span><br><span class="line">    for(auto a = dict.rbegin(); a!=dict.rend(); a++)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;a-&gt;second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;反向遍历，dict.crbegin()-&gt;dict.crend()&quot;&lt;&lt;endl;</span><br><span class="line">       for(auto a = dict.crbegin(); a!=dict.crend(); a++)&#123;</span><br><span class="line">           cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;a-&gt;second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果</span><br><span class="line"> dict.empty() 0</span><br><span class="line"> dict.size() 6</span><br><span class="line"> 插入前 size = 6</span><br><span class="line"> &#123;1,A&#125; &#123;2,B&#125; &#123;2,C&#125; &#123;2,F&#125; &#123;3,D&#125; &#123;3,E&#125;</span><br><span class="line"> 插入后 size = 11</span><br><span class="line"> &#123;1,A&#125; &#123;2,B&#125; &#123;2,C&#125; &#123;2,F&#125; &#123;3,D&#125; &#123;3,E&#125; &#123;4,G&#125; &#123;4,F&#125; &#123;4,H&#125; &#123;5,I&#125; &#123;5,J&#125;</span><br><span class="line"> 删除key=1后 size = 10</span><br><span class="line"> &#123;2,B&#125; &#123;2,C&#125; &#123;2,F&#125; &#123;3,D&#125; &#123;3,E&#125; &#123;4,G&#125; &#123;4,F&#125; &#123;4,H&#125; &#123;5,I&#125; &#123;5,J&#125;</span><br><span class="line"> equal_range(2)</span><br><span class="line"> i.first    2    i.second    B</span><br><span class="line"> i.first    2    i.second    C</span><br><span class="line"> i.first    2    i.second    F</span><br><span class="line"> lower_bound(2) 2 B</span><br><span class="line"> upper_bound(2) 3 D</span><br><span class="line"> lower_bound == range.first 1</span><br><span class="line"> upper_bound == range.second 1</span><br><span class="line"> count(2) 3</span><br><span class="line"> distance(range.first,range.second) 3</span><br><span class="line"> distance(lower,upper)3</span><br><span class="line"> find2 2 B</span><br><span class="line"> find10==dict.end 1</span><br><span class="line"> dict.begin().type NSt3__114__map_iteratorINS_15__tree_iteratorINS_12__value_typeIicEEPNS_11__tree_nodeIS3_PvEElEEEE</span><br><span class="line"> 正向遍历dict.begin()-&gt;dict.end()</span><br><span class="line"> &#123;2,B&#125; &#123;2,C&#125; &#123;2,F&#125; &#123;3,D&#125; &#123;3,E&#125; &#123;4,G&#125; &#123;4,F&#125; &#123;4,H&#125; &#123;5,I&#125; &#123;5,J&#125; 正向遍历，dict.cbegin()-&gt;dict.cend()</span><br><span class="line"> &#123;2,B&#125; &#123;2,C&#125; &#123;2,F&#125; &#123;3,D&#125; &#123;3,E&#125; &#123;4,G&#125; &#123;4,F&#125; &#123;4,H&#125; &#123;5,I&#125; &#123;5,J&#125;</span><br><span class="line"> 反向遍历，dict.rbegin()-&gt;dict.rend()</span><br><span class="line"> &#123;5,J&#125; &#123;5,I&#125; &#123;4,H&#125; &#123;4,F&#125; &#123;4,G&#125; &#123;3,E&#125; &#123;3,D&#125; &#123;2,F&#125; &#123;2,C&#125; &#123;2,B&#125;</span><br><span class="line"> 反向遍历，dict.rbegin()-&gt;dict.rend()</span><br><span class="line"> &#123;5,J&#125; &#123;5,I&#125; &#123;4,H&#125; &#123;4,F&#125; &#123;4,G&#125; &#123;3,E&#125; &#123;3,D&#125; &#123;2,F&#125; &#123;2,C&#125; &#123;2,B&#125;</span><br><span class="line"> 反向遍历，dict.crbegin()-&gt;dict.crend()</span><br><span class="line"> &#123;5,J&#125; &#123;5,I&#125; &#123;4,H&#125; &#123;4,F&#125; &#123;4,G&#125; &#123;3,E&#125; &#123;3,D&#125; &#123;2,F&#125; &#123;2,C&#125; &#123;2,B&#125;</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第七篇.&lt;br&gt;主要测试了multimap相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;br&gt;map,multimap,unordered_map,unordered_multimap仅仅有稍许差别，方法和multimap基本类似，所以不再另行写文章啦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Map" scheme="http://yoursite.com/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>set的简单用法</title>
    <link href="http://yoursite.com/2020/02/07/set%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/07/set的简单用法/</id>
    <published>2020-02-07T09:21:38.000Z</published>
    <updated>2020-02-07T10:39:17.624Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第六篇.<br>主要测试了set相关的方法，主要作为代码备份方便之后遗忘时查询。<br>set,multiset,unordered_set,unordered_multiset仅仅有稍许差别，方法和set基本类似，所以不再另行写文章啦。</p><a id="more"></a><h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><ol><li>由于set和unordered_set的功能几乎完全一致，用的时候记得引入unordered_set的头文件，然后声明对象的时候将set换成unordered_set就可以啦。就像是下面这样<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 引入头文件</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">// 声明对象</span><br><span class="line">unordered_set&lt;int&gt; a = &#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure>还需要注意的一点就是unordered_set是没有upper_bound和lower_bound方法的。</li><li>set和multiset都是通过set头文件导入的，multiset相比于set的不同点就在于可以插入相同的元素，用的时候记住就可以啦，所以也不再另行写文章，所有操作参考本文章就行。</li></ol><h2 id="set测试代码"><a href="#set测试代码" class="headerlink" title="set测试代码"></a>set测试代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printSet(const string s,const T&amp; mset)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:mset)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // 声明</span><br><span class="line">    set&lt;int&gt; a;</span><br><span class="line">    set&lt;int&gt; a1 = &#123;1,2,3&#125;;</span><br><span class="line">    set&lt;int&gt; a2(a1);</span><br><span class="line">    set&lt;int&gt; a3(a1.begin(),a1.begin());</span><br><span class="line">    </span><br><span class="line">    printSet(&quot;a:&quot;, a);</span><br><span class="line">    printSet(&quot;a1:&quot;,a1 );</span><br><span class="line">    printSet(&quot;a2:&quot;, a2);</span><br><span class="line">    printSet(&quot;a3:&quot;, a3);</span><br><span class="line">    </span><br><span class="line">    //capacity相关</span><br><span class="line">    cout&lt;&lt;&quot;a.size(): &quot;&lt;&lt;a.size()&lt;&lt;endl;</span><br><span class="line">    a.insert(1);</span><br><span class="line">    cout&lt;&lt;&quot;after insert 1, a.size()&quot;&lt;&lt;a.size()&lt;&lt;endl;</span><br><span class="line">    //set的特性就是不能插入重复元素,如果插入那么就会报错。</span><br><span class="line">    // a.insert(1);</span><br><span class="line">    //cout&lt;&lt;&quot;a.size()&quot;&lt;&lt;a.size()&lt;&lt;endl;</span><br><span class="line">    //printSet(&quot;after 2 time insert 1: &quot;, a);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;a.empty(): &quot;&lt;&lt;a.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;a.max_size(): &quot;&lt;&lt;a.max_size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //modifiers</span><br><span class="line">    a.insert(3);</span><br><span class="line">    printSet(&quot;after insert 3: &quot;, a);</span><br><span class="line">    </span><br><span class="line">    auto find3 = a.find(3);</span><br><span class="line">    a.erase(find3);</span><br><span class="line">    printSet(&quot;after erase3: &quot;, a);</span><br><span class="line"></span><br><span class="line">    a.clear();</span><br><span class="line">    printSet(&quot;after clear:&quot;, a);</span><br><span class="line">    </span><br><span class="line">    a = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    // Look up相关</span><br><span class="line">    //find 会返回一个itertor</span><br><span class="line">    auto f = a.find(2);</span><br><span class="line">    if(f!=a.end())&#123;</span><br><span class="line">        cout&lt;&lt;&quot;find \t&quot;&lt;&lt;*f&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;&quot;not found 2&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;a.find(2)\t&quot;&lt;&lt;*a.find(2)&lt;&lt;endl;</span><br><span class="line">    // count</span><br><span class="line">    cout&lt;&lt;&quot;a.count(3): &quot;&lt;&lt;a.count(3)&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">    // equal_range</span><br><span class="line">    auto equal2 = a.equal_range(2);</span><br><span class="line">    for(auto i = equal2.first; i != equal2.second; i++)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;equal2: &quot;&lt;&lt;*i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     如果我的equal_range判断的值在原来的set中没有会怎么样呢？会等价于a.end()</span><br><span class="line">     所以这里其实是告诉我们，在使用equal_range方法的时候，</span><br><span class="line">     要记得先判断一下返回的pair的第一个iterator指向的是否是end()。</span><br><span class="line">     或者在使用equal_range之前可以先通过find或者count先判断一下要找的key是存在的。</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    auto equal6 = a.equal_range(6);</span><br><span class="line">    cout&lt;&lt;&quot;equal6: &quot;&lt;&lt;*equal6.first&lt;&lt;&quot; &quot;&lt;&lt;*equal6.second&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;equal6.first == a.end(): &quot;&lt;&lt;(equal6.first == a.end())&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;equal6.second == a.end(): &quot;&lt;&lt;(equal6.second == a.end())&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // 确认set中不会有重复元素，那么如果找到，则两个iterator之差肯定为1，</span><br><span class="line">    // 如果找不到，那么差为0,后来发现set的iterator也不可做差运算，此处存疑。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // upper_bound 和 lower_bound</span><br><span class="line">    auto ub = a.upper_bound(4);</span><br><span class="line">    auto lb = a.lower_bound(2);</span><br><span class="line">    cout&lt;&lt;&quot;lower_bound(2): &quot;&lt;&lt;*lb&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;upper_bound(4): &quot;&lt;&lt;*ub&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // 遍历操作</span><br><span class="line">    set&lt;int&gt;::iterator iter = a.begin(); // 等价于auto iter = a.begin();</span><br><span class="line">    for(;iter!=a.end();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;*iter&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果</span><br><span class="line"> a:</span><br><span class="line"> a1:    1    2    3</span><br><span class="line"> a2:    1    2    3</span><br><span class="line"> a3:</span><br><span class="line"> a.size(): 0</span><br><span class="line"> after insert 1, a.size()1</span><br><span class="line"> a.empty(): 0</span><br><span class="line"> a.max_size(): 576460752303423487</span><br><span class="line"> after insert 3:     1    3</span><br><span class="line"> after erase3:     1</span><br><span class="line"> after clear:</span><br><span class="line"> find     2</span><br><span class="line"> a.find(2)    2</span><br><span class="line"> a.count(3): 1</span><br><span class="line"> equal2: 2</span><br><span class="line"> equal6: 32766 32766</span><br><span class="line"> equal6.first == a.end(): 1</span><br><span class="line"> equal6.second == a.end(): 1</span><br><span class="line"> lower_bound(2): 2</span><br><span class="line"> upper_bound(4): 5</span><br><span class="line"> 1    2    3    4    5    Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第六篇.&lt;br&gt;主要测试了set相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;br&gt;set,multiset,unordered_set,unordered_multiset仅仅有稍许差别，方法和set基本类似，所以不再另行写文章啦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Set" scheme="http://yoursite.com/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>array的简单使用</title>
    <link href="http://yoursite.com/2020/02/06/array%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/06/array的简单使用/</id>
    <published>2020-02-06T11:39:53.000Z</published>
    <updated>2020-02-06T11:41:32.838Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第五篇.<br>主要测试了array相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><p>array是c++11新加入的，是对c类型的树组进行了进一步的封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;array&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printArray(string s,const T&amp; marr)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:marr)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //声明</span><br><span class="line">    array&lt;int,3&gt; marr = &#123;3,2,4&#125;;</span><br><span class="line">    array&lt;int,2&gt; marr1&#123;1,2&#125;;</span><br><span class="line">    printArray(&quot;marr&quot;,marr);</span><br><span class="line">    printArray(&quot;marr1 &quot;,marr1);</span><br><span class="line">    </span><br><span class="line">    // access 相关</span><br><span class="line">    cout&lt;&lt;&quot;marr[0]: &quot;&lt;&lt;marr[0]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.at(0): &quot;&lt;&lt;marr.at(0)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.data(): &quot;&lt;&lt;*marr.data()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.front(): &quot;&lt;&lt;marr.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.back(): &quot;&lt;&lt;marr.back()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //capacity 相关</span><br><span class="line">    cout&lt;&lt;&quot;marr.size(): &quot;&lt;&lt;marr.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.empty(): &quot;&lt;&lt;marr.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.max_size(): &quot;&lt;&lt;marr.max_size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //Operations</span><br><span class="line">    printArray(&quot;before sort&quot;, marr);</span><br><span class="line">    sort(marr.begin(),marr.end());</span><br><span class="line">    printArray(&quot;after sort&quot;, marr);</span><br><span class="line">    </span><br><span class="line">    marr.fill(5);</span><br><span class="line">    printArray(&quot;marr.fill(5)&quot;, marr);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果</span><br><span class="line"> marr    3    2    4</span><br><span class="line"> marr1     1    2</span><br><span class="line"> marr[0]: 3</span><br><span class="line"> marr.at(0): 3</span><br><span class="line"> marr.data(): 3</span><br><span class="line"> marr.front(): 3</span><br><span class="line"> marr.back(): 4</span><br><span class="line"> marr.size(): 3</span><br><span class="line"> marr.empty(): 0</span><br><span class="line"> marr.max_size(): 3</span><br><span class="line"> before sort    3    2    4</span><br><span class="line"> after sort    2    3    4</span><br><span class="line"> marr.fill(5)    5    5    5</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第五篇.&lt;br&gt;主要测试了array相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>forward_list的简单使用</title>
    <link href="http://yoursite.com/2020/02/06/forward-list%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/06/forward-list的简单使用/</id>
    <published>2020-02-06T09:40:17.000Z</published>
    <updated>2020-02-06T10:01:02.184Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第四篇.<br>主要测试了forward_list相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">keypoints：</span><br><span class="line">1) 假设单向链表为： 1-&gt;2-&gt;3 则front位置是1，push_front,emplace_front,pop_front都是在此处操作的，</span><br><span class="line">2）没有size()函数，</span><br><span class="line">3）erase和erase函数需要使用c++20支持</span><br><span class="line">4）iterator不支持++，--，+number等操作。</span><br><span class="line">5）插入函数insert_after。</span><br><span class="line">6）forward_list为单向链表，而list是双向链表。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;forward_list&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printList(string s,const T&amp; mlist)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:mlist)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //常见的list的声明方式</span><br><span class="line">    forward_list&lt;int&gt; mlist&#123;1,2,3,4&#125;;</span><br><span class="line">    // 发现不能通过 list&lt;int&gt; mlist1(mlist.begin(),mlist.end()-2);这种方式声明，</span><br><span class="line">    // 也不能通过 list&lt;int&gt; mlist1(mlist.begin(),--mlist.end())这种方式声明,list是可以的。</span><br><span class="line">    forward_list&lt;int&gt; mlist1(mlist.begin(),mlist.end());</span><br><span class="line">    </span><br><span class="line">    forward_list&lt;int&gt; mlist2(mlist);</span><br><span class="line">    forward_list&lt;int&gt; mlist3(5,1);</span><br><span class="line">    forward_list&lt;int&gt; mlist4 = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    </span><br><span class="line">    printList(&quot;mlist&quot;, mlist);</span><br><span class="line">    printList(&quot;mlist1&quot;, mlist1);</span><br><span class="line">    printList(&quot;mlist2&quot;, mlist2);</span><br><span class="line">    printList(&quot;mlist3&quot;, mlist3);</span><br><span class="line">    printList(&quot;mlist4&quot;, mlist4);</span><br><span class="line">    </span><br><span class="line">    //front 获得第一个元素</span><br><span class="line">    cout&lt;&lt;&quot;mlist front: &quot;&lt;&lt;mlist.front()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //遍历通过iterator</span><br><span class="line">    cout&lt;&lt;&quot;print all elements by iterator: &quot;;</span><br><span class="line">    forward_list&lt;int&gt;::iterator a  = mlist.begin();</span><br><span class="line">    for(;a!=mlist.end();a++)&#123;</span><br><span class="line">        cout&lt;&lt;*a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // capacity相关 没有size()函数,为啥？此处存疑。</span><br><span class="line">    cout&lt;&lt;&quot;mlist empty &quot;&lt;&lt;mlist.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist max_size &quot;&lt;&lt;mlist.max_size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // Modifiers相关</span><br><span class="line">    //插入操作</span><br><span class="line">    mlist.insert_after(mlist.begin(), 10);</span><br><span class="line">    // 同样不能通过类似于 mlist.insert(mlist.begin()+2, 10);来插入元素</span><br><span class="line">    mlist.emplace_after(mlist.begin(), 9);</span><br><span class="line">    printList(&quot;insert begin(): &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //插入到头部</span><br><span class="line">    mlist.push_front(10);</span><br><span class="line">    printList(&quot;push_front 10: &quot;, mlist);</span><br><span class="line">    mlist.emplace_front(9);</span><br><span class="line">    printList(&quot;emplace_front 9: &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除头元素</span><br><span class="line">    mlist.pop_front();</span><br><span class="line">    printList(&quot;pop_front : &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//     erase 和erase_if 是c++20提供的</span><br><span class="line">//    auto a4 = find(mlist.begin(),mlist.end(),4);</span><br><span class="line">//    mlist.erase(a4);</span><br><span class="line">//    printList(&quot;after erase a4&quot;, mlist);</span><br><span class="line">//</span><br><span class="line">//    mlist.erase(mlist.begin());</span><br><span class="line">//    printList(&quot;after earse begin()&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // Operations 相关</span><br><span class="line">    // 排序:默认从小到大</span><br><span class="line">    mlist.sort();</span><br><span class="line">    printList(&quot;after sort&quot;, mlist);</span><br><span class="line">    //当然可以改成从大到小</span><br><span class="line">    mlist.sort(greater&lt;int&gt;());</span><br><span class="line">    printList(&quot;after sort big -&gt; small &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //顺序反转</span><br><span class="line">    mlist.reverse();</span><br><span class="line">    printList(&quot;after reverse &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除重复节点</span><br><span class="line">    mlist.unique();</span><br><span class="line">    printList(&quot;after unique&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //删除list中值为10的节点</span><br><span class="line">    mlist.remove(10);</span><br><span class="line">    printList(&quot;after remove 10:&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 删除list中值大于等于3的节点,这里使用了lamda表达式</span><br><span class="line">    mlist.remove_if([](int n)&#123;return n&gt;=3;&#125;);</span><br><span class="line">    printList(&quot;after remove &gt;=3 :&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;before clear mlist.empty() is &quot;&lt;&lt; mlist.empty()&lt;&lt;endl;</span><br><span class="line">    mlist.clear();</span><br><span class="line">    cout&lt;&lt;&quot;after clear mlist.empty() is &quot;&lt;&lt; mlist.empty()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> mlist    1    2    3    4</span><br><span class="line"> mlist1    1    2    3    4</span><br><span class="line"> mlist2    1    2    3    4</span><br><span class="line"> mlist3    1    1    1    1    1</span><br><span class="line"> mlist4    1    2    3    4    5</span><br><span class="line"> mlist front: 1</span><br><span class="line"> print all elements by iterator: 1    2    3    4</span><br><span class="line"> mlist empty 0</span><br><span class="line"> mlist max_size 1152921504606846975</span><br><span class="line"> insert begin():     1    9    10    2    3    4</span><br><span class="line"> push_front 10:     10    1    9    10    2    3    4</span><br><span class="line"> emplace_front 9:     9    10    1    9    10    2    3    4</span><br><span class="line"> pop_front :     10    1    9    10    2    3    4</span><br><span class="line"> after sort    1    2    3    4    9    10    10</span><br><span class="line"> after sort big -&gt; small     10    10    9    4    3    2    1</span><br><span class="line"> after reverse     1    2    3    4    9    10    10</span><br><span class="line"> after unique    1    2    3    4    9    10</span><br><span class="line"> after remove 10:    1    2    3    4    9</span><br><span class="line"> after remove &gt;=3 :    1    2</span><br><span class="line"> before clear mlist.empty() is 0</span><br><span class="line"> after clear mlist.empty() is 1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第四篇.&lt;br&gt;主要测试了forward_list相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Forward_list" scheme="http://yoursite.com/tags/Forward-list/"/>
    
  </entry>
  
  <entry>
    <title>list的简单使用</title>
    <link href="http://yoursite.com/2020/02/06/list%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/06/list的简单使用/</id>
    <published>2020-02-06T07:32:17.000Z</published>
    <updated>2020-02-06T07:34:23.693Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第三篇.<br>主要测试了list相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printList(string s,const T&amp; mlist)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:mlist)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //常见的list的声明方式</span><br><span class="line">    list&lt;int&gt; mlist&#123;1,2,3,4&#125;;</span><br><span class="line">    // 发现不能通过 list&lt;int&gt; mlist1(mlist.begin(),mlist.end()-2);这种方式声明，但是可以通过下面这种方式进行声明。此处存疑</span><br><span class="line">    list&lt;int&gt; mlist1(mlist.begin(),--mlist.end());</span><br><span class="line">    </span><br><span class="line">    list&lt;int&gt; mlist2(mlist);</span><br><span class="line">    list&lt;int&gt; mlist3(5,1);</span><br><span class="line">    list&lt;int&gt; mlist4 = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    </span><br><span class="line">    printList(&quot;mlist&quot;, mlist);</span><br><span class="line">    printList(&quot;mlist1&quot;, mlist1);</span><br><span class="line">    printList(&quot;mlist2&quot;, mlist2);</span><br><span class="line">    printList(&quot;mlist3&quot;, mlist3);</span><br><span class="line">    printList(&quot;mlist4&quot;, mlist4);</span><br><span class="line">    </span><br><span class="line">    //front 和back 获得第一个元素和最后一个元素</span><br><span class="line">    cout&lt;&lt;&quot;mlist front: &quot;&lt;&lt;mlist.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist back: &quot;&lt;&lt;mlist.back()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //遍历通过iterator</span><br><span class="line">    cout&lt;&lt;&quot;print all elements by iterator: &quot;;</span><br><span class="line">    list&lt;int&gt;::iterator a  = mlist.begin();</span><br><span class="line">    for(;a!=mlist.end();a++)&#123;</span><br><span class="line">        cout&lt;&lt;*a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // capacity相关</span><br><span class="line">    cout&lt;&lt;&quot;mlist empty &quot;&lt;&lt;mlist.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist size() &quot;&lt;&lt;mlist.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist max_size &quot;&lt;&lt;mlist.max_size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // Modifiers相关</span><br><span class="line">    //插入操作</span><br><span class="line">    mlist.insert(mlist.begin(), 10);</span><br><span class="line">    // 同样不能通过类似于 mlist.insert(mlist.begin()+2, 10);来插入元素</span><br><span class="line">    mlist.emplace(mlist.begin(), 9);</span><br><span class="line">    printList(&quot;insert begin(): &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //插入到头部</span><br><span class="line">    mlist.push_front(10);</span><br><span class="line">    printList(&quot;push_front 10: &quot;, mlist);</span><br><span class="line">    mlist.emplace_front(9);</span><br><span class="line">    printList(&quot;emplace_front 9: &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除头元素</span><br><span class="line">    mlist.pop_front();</span><br><span class="line">    printList(&quot;pop_front : &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 插入到尾部</span><br><span class="line">    mlist.push_back(10);</span><br><span class="line">    printList(&quot;push_back 10: &quot;, mlist);</span><br><span class="line">    mlist.emplace_back(11);</span><br><span class="line">    printList(&quot;emplace_back 11&quot;, mlist);</span><br><span class="line">    // 删除尾部元素</span><br><span class="line">    mlist.pop_back();</span><br><span class="line">    printList(&quot;pop back&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    auto a4 = find(mlist.begin(),mlist.end(),4);</span><br><span class="line">    mlist.erase(a4);</span><br><span class="line">    printList(&quot;after erase a4&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    mlist.erase(mlist.begin());</span><br><span class="line">    printList(&quot;after earse begin()&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 排序:默认从小到大</span><br><span class="line">    mlist.sort();</span><br><span class="line">    printList(&quot;after sort&quot;, mlist);</span><br><span class="line">    //当然可以改成从大到小</span><br><span class="line">    mlist.sort(greater&lt;int&gt;());</span><br><span class="line">    printList(&quot;after sort big -&gt; small &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //顺序反转</span><br><span class="line">    mlist.reverse();</span><br><span class="line">    printList(&quot;after reverse &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除重复节点</span><br><span class="line">    mlist.unique();</span><br><span class="line">    printList(&quot;after unique&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //删除list中值为10的节点</span><br><span class="line">    mlist.remove(10);</span><br><span class="line">    printList(&quot;after remove 10:&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 删除list中值大于等于3的节点,这里使用了lamda表达式</span><br><span class="line">    mlist.remove_if([](int n)&#123;return n&gt;=3;&#125;);</span><br><span class="line">    printList(&quot;after remove &gt;=3 :&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;before clear the size of list is &quot;&lt;&lt; mlist.size()&lt;&lt;endl;</span><br><span class="line">    mlist.clear();</span><br><span class="line">    cout&lt;&lt;&quot;after clear the size of list is &quot;&lt;&lt; mlist.size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> mlist    1    2    3    4</span><br><span class="line"> mlist1    1    2    3</span><br><span class="line"> mlist2    1    2    3    4</span><br><span class="line"> mlist3    1    1    1    1    1</span><br><span class="line"> mlist4    1    2    3    4    5</span><br><span class="line"> mlist front: 1</span><br><span class="line"> mlist back: 4</span><br><span class="line"> print all elements by iterator: 1    2    3    4</span><br><span class="line"> mlist empty 0</span><br><span class="line"> mlist size() 4</span><br><span class="line"> mlist max_size 768614336404564650</span><br><span class="line"> insert begin():     9    10    1    2    3    4</span><br><span class="line"> push_front 10:     10    9    10    1    2    3    4</span><br><span class="line"> emplace_front 9:     9    10    9    10    1    2    3    4</span><br><span class="line"> pop_front :     10    9    10    1    2    3    4</span><br><span class="line"> push_back 10:     10    9    10    1    2    3    4    10</span><br><span class="line"> emplace_back 11    10    9    10    1    2    3    4    10    11</span><br><span class="line"> pop back    10    9    10    1    2    3    4    10</span><br><span class="line"> after erase a4    10    9    10    1    2    3    10</span><br><span class="line"> after earse begin()    9    10    1    2    3    10</span><br><span class="line"> after sort    1    2    3    9    10    10</span><br><span class="line"> after sort big -&gt; small     10    10    9    3    2    1</span><br><span class="line"> after reverse     1    2    3    9    10    10</span><br><span class="line"> after unique    1    2    3    9    10</span><br><span class="line"> after remove 10:    1    2    3    9</span><br><span class="line"> after remove &gt;=3 :    1    2</span><br><span class="line"> before clear the size of list is 2</span><br><span class="line"> after clear the size of list is 0</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第三篇.&lt;br&gt;主要测试了list相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="List" scheme="http://yoursite.com/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>deque的简单使用</title>
    <link href="http://yoursite.com/2020/02/06/deque%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/06/deque的简单使用/</id>
    <published>2020-02-06T05:41:30.000Z</published>
    <updated>2020-02-06T07:36:15.247Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第二篇.<br>主要测试了deque相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void printContainer(const char * msg,const T&amp; s)&#123;</span><br><span class="line">    cout&lt;&lt;msg&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    copy(s.begin(),s.end(),ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //三种声明方式</span><br><span class="line">    deque&lt;int&gt; s=&#123;1,2,3,4&#125;;</span><br><span class="line">    deque&lt;int&gt; s1&#123;1,2,3,4&#125;;</span><br><span class="line">    deque&lt;int&gt; s2(s.begin(),s.end()-1);</span><br><span class="line"></span><br><span class="line">    printContainer(&quot;deque s&quot;,s);</span><br><span class="line">    printContainer(&quot;deque s1&quot;,s1);</span><br><span class="line">    printContainer(&quot;deque s2 &quot;,s2);</span><br><span class="line">    </span><br><span class="line">    //两种获取对应位置元素的方式</span><br><span class="line">    cout&lt;&lt;&quot;s[0] &quot;&lt;&lt;s[0]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;a.at[0] &quot;&lt;&lt;s.at(0)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //打印出全部的元素</span><br><span class="line">    cout&lt;&lt;&quot;print all elements &quot;&lt;&lt;endl;</span><br><span class="line">    for(auto i:s)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;print all elements by iteror&quot;&lt;&lt;endl;</span><br><span class="line">    auto siter = s.begin();</span><br><span class="line">    while(siter!=s.end())&#123;</span><br><span class="line">        cout&lt;&lt;*siter&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        siter++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;s.front() &quot;&lt;&lt;s.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.back() &quot;&lt;&lt;s.back()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;s.begin() &quot;&lt;&lt;*s.begin()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.end()-s.begin() &quot;&lt;&lt;s.end()-s.begin()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;s.empty() &quot;&lt;&lt;s.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.size() &quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.max_size() &quot;&lt;&lt;s.max_size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //s.clear();</span><br><span class="line">    //cout&lt;&lt;&quot;after clear s.empty() &quot;&lt;&lt;s.empty()&lt;&lt;endl;  // 1</span><br><span class="line"></span><br><span class="line">    s.push_front(5);</span><br><span class="line">    printContainer(&quot;after push front 5: &quot;,s);</span><br><span class="line">    s.pop_front();</span><br><span class="line">    printContainer(&quot;after pop front: &quot;,s);</span><br><span class="line"></span><br><span class="line">    s.push_back(5);</span><br><span class="line">    printContainer(&quot;after push back5: &quot;,s);</span><br><span class="line">    s.pop_back();</span><br><span class="line">    printContainer(&quot;after pop back: &quot;,s);</span><br><span class="line"></span><br><span class="line">    s.emplace(s.begin()+2,5);</span><br><span class="line">    printContainer(&quot;emplace begin+2 &quot;,s);</span><br><span class="line"></span><br><span class="line">    s.emplace_back(6);</span><br><span class="line">    printContainer(&quot;emplace back&quot;,s);</span><br><span class="line"></span><br><span class="line">    s.erase(s.begin()+2);</span><br><span class="line">    printContainer(&quot;erase begin+2&quot;,s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //用列表容器1的内容给s赋值，将s输出</span><br><span class="line">    reverse(s.begin(),s.end());</span><br><span class="line">    printContainer(&quot;deque l by assign:&quot;,s);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> deque s    1 2 3 4</span><br><span class="line"> deque s1    1 2 3 4</span><br><span class="line"> deque s2     1 2 3</span><br><span class="line"> s[0] 1</span><br><span class="line"> a.at[0] 1</span><br><span class="line"> print all elements</span><br><span class="line"> 1    2    3    4</span><br><span class="line"> print all elements by iteror</span><br><span class="line"> 1    2    3    4</span><br><span class="line"> s.front() 1</span><br><span class="line"> s.back() 4</span><br><span class="line"> s.begin() 1</span><br><span class="line"> s.end()-s.begin() 4</span><br><span class="line"> s.empty() 0</span><br><span class="line"> s.size() 4</span><br><span class="line"> s.max_size() 4611686018427387903</span><br><span class="line"> after push front 5:     5 1 2 3 4</span><br><span class="line"> after pop front:     1 2 3 4</span><br><span class="line"> after push back5:     1 2 3 4 5</span><br><span class="line"> after pop back:     1 2 3 4</span><br><span class="line"> emplace begin+2     1 2 5 3 4</span><br><span class="line"> emplace back    1 2 5 3 4 6</span><br><span class="line"> erase begin+2    1 2 3 4 6</span><br><span class="line"> deque l by assign:    6 4 3 2 1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第二篇.&lt;br&gt;主要测试了deque相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Deque" scheme="http://yoursite.com/tags/Deque/"/>
    
  </entry>
  
</feed>
