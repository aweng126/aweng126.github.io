<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingwen&#39;s blog</title>
  
  <subtitle>没有输出的输入是不完整的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-06T09:41:17.313Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李庆文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>forward_list的简单使用</title>
    <link href="http://yoursite.com/2020/02/06/forward-list%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/06/forward-list的简单使用/</id>
    <published>2020-02-06T09:40:17.000Z</published>
    <updated>2020-02-06T09:41:17.313Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第四篇.<br>主要测试了forward_list相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">keypoints：</span><br><span class="line">1) 假设单向链表为： 1-&gt;2-&gt;3 则front位置是1，push_front,emplace_front,pop_front都是在此处操作的，</span><br><span class="line">2）没有size()函数，</span><br><span class="line">3）erase和erase函数需要使用c++20支持</span><br><span class="line">4）iterator不支持++，--，+number等操作。</span><br><span class="line">5）插入函数insert_after。</span><br><span class="line">6）forward_list为单向链表，而list是双向链表。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;forward_list&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printList(string s,const T&amp; mlist)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:mlist)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //常见的list的声明方式</span><br><span class="line">    forward_list&lt;int&gt; mlist&#123;1,2,3,4&#125;;</span><br><span class="line">    // 发现不能通过 list&lt;int&gt; mlist1(mlist.begin(),mlist.end()-2);这种方式声明，</span><br><span class="line">    // 也不能通过 list&lt;int&gt; mlist1(mlist.begin(),--mlist.end())这种方式声明,list是可以的。</span><br><span class="line">    forward_list&lt;int&gt; mlist1(mlist.begin(),mlist.end());</span><br><span class="line">    </span><br><span class="line">    forward_list&lt;int&gt; mlist2(mlist);</span><br><span class="line">    forward_list&lt;int&gt; mlist3(5,1);</span><br><span class="line">    forward_list&lt;int&gt; mlist4 = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    </span><br><span class="line">    printList(&quot;mlist&quot;, mlist);</span><br><span class="line">    printList(&quot;mlist1&quot;, mlist1);</span><br><span class="line">    printList(&quot;mlist2&quot;, mlist2);</span><br><span class="line">    printList(&quot;mlist3&quot;, mlist3);</span><br><span class="line">    printList(&quot;mlist4&quot;, mlist4);</span><br><span class="line">    </span><br><span class="line">    //front 获得第一个元素</span><br><span class="line">    cout&lt;&lt;&quot;mlist front: &quot;&lt;&lt;mlist.front()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //遍历通过iterator</span><br><span class="line">    cout&lt;&lt;&quot;print all elements by iterator: &quot;;</span><br><span class="line">    forward_list&lt;int&gt;::iterator a  = mlist.begin();</span><br><span class="line">    for(;a!=mlist.end();a++)&#123;</span><br><span class="line">        cout&lt;&lt;*a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // capacity相关 没有size()函数,为啥？此处存疑。</span><br><span class="line">    cout&lt;&lt;&quot;mlist empty &quot;&lt;&lt;mlist.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist max_size &quot;&lt;&lt;mlist.max_size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // Modifiers相关</span><br><span class="line">    //插入操作</span><br><span class="line">    mlist.insert_after(mlist.begin(), 10);</span><br><span class="line">    // 同样不能通过类似于 mlist.insert(mlist.begin()+2, 10);来插入元素</span><br><span class="line">    mlist.emplace_after(mlist.begin(), 9);</span><br><span class="line">    printList(&quot;insert begin(): &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //插入到头部</span><br><span class="line">    mlist.push_front(10);</span><br><span class="line">    printList(&quot;push_front 10: &quot;, mlist);</span><br><span class="line">    mlist.emplace_front(9);</span><br><span class="line">    printList(&quot;emplace_front 9: &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除头元素</span><br><span class="line">    mlist.pop_front();</span><br><span class="line">    printList(&quot;pop_front : &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//     erase 和erase_if 是c++20提供的</span><br><span class="line">//    auto a4 = find(mlist.begin(),mlist.end(),4);</span><br><span class="line">//    mlist.erase(a4);</span><br><span class="line">//    printList(&quot;after erase a4&quot;, mlist);</span><br><span class="line">//</span><br><span class="line">//    mlist.erase(mlist.begin());</span><br><span class="line">//    printList(&quot;after earse begin()&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // Operations 相关</span><br><span class="line">    // 排序:默认从小到大</span><br><span class="line">    mlist.sort();</span><br><span class="line">    printList(&quot;after sort&quot;, mlist);</span><br><span class="line">    //当然可以改成从大到小</span><br><span class="line">    mlist.sort(greater&lt;int&gt;());</span><br><span class="line">    printList(&quot;after sort big -&gt; small &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //顺序反转</span><br><span class="line">    mlist.reverse();</span><br><span class="line">    printList(&quot;after reverse &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除重复节点</span><br><span class="line">    mlist.unique();</span><br><span class="line">    printList(&quot;after unique&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //删除list中值为10的节点</span><br><span class="line">    mlist.remove(10);</span><br><span class="line">    printList(&quot;after remove 10:&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 删除list中值大于等于3的节点,这里使用了lamda表达式</span><br><span class="line">    mlist.remove_if([](int n)&#123;return n&gt;=3;&#125;);</span><br><span class="line">    printList(&quot;after remove &gt;=3 :&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;before clear mlist.empty() is &quot;&lt;&lt; mlist.empty()&lt;&lt;endl;</span><br><span class="line">    mlist.clear();</span><br><span class="line">    cout&lt;&lt;&quot;after clear mlist.empty() is &quot;&lt;&lt; mlist.empty()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> mlist    1    2    3    4</span><br><span class="line"> mlist1    1    2    3    4</span><br><span class="line"> mlist2    1    2    3    4</span><br><span class="line"> mlist3    1    1    1    1    1</span><br><span class="line"> mlist4    1    2    3    4    5</span><br><span class="line"> mlist front: 1</span><br><span class="line"> print all elements by iterator: 1    2    3    4</span><br><span class="line"> mlist empty 0</span><br><span class="line"> mlist max_size 1152921504606846975</span><br><span class="line"> insert begin():     1    9    10    2    3    4</span><br><span class="line"> push_front 10:     10    1    9    10    2    3    4</span><br><span class="line"> emplace_front 9:     9    10    1    9    10    2    3    4</span><br><span class="line"> pop_front :     10    1    9    10    2    3    4</span><br><span class="line"> after sort    1    2    3    4    9    10    10</span><br><span class="line"> after sort big -&gt; small     10    10    9    4    3    2    1</span><br><span class="line"> after reverse     1    2    3    4    9    10    10</span><br><span class="line"> after unique    1    2    3    4    9    10</span><br><span class="line"> after remove 10:    1    2    3    4    9</span><br><span class="line"> after remove &gt;=3 :    1    2</span><br><span class="line"> before clear mlist.empty() is 0</span><br><span class="line"> after clear mlist.empty() is 1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第四篇.&lt;br&gt;主要测试了forward_list相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Forward_list" scheme="http://yoursite.com/tags/Forward-list/"/>
    
  </entry>
  
  <entry>
    <title>list的简单使用</title>
    <link href="http://yoursite.com/2020/02/06/list%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/06/list的简单使用/</id>
    <published>2020-02-06T07:32:17.000Z</published>
    <updated>2020-02-06T07:34:23.693Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第三篇.<br>主要测试了list相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printList(string s,const T&amp; mlist)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:mlist)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //常见的list的声明方式</span><br><span class="line">    list&lt;int&gt; mlist&#123;1,2,3,4&#125;;</span><br><span class="line">    // 发现不能通过 list&lt;int&gt; mlist1(mlist.begin(),mlist.end()-2);这种方式声明，但是可以通过下面这种方式进行声明。此处存疑</span><br><span class="line">    list&lt;int&gt; mlist1(mlist.begin(),--mlist.end());</span><br><span class="line">    </span><br><span class="line">    list&lt;int&gt; mlist2(mlist);</span><br><span class="line">    list&lt;int&gt; mlist3(5,1);</span><br><span class="line">    list&lt;int&gt; mlist4 = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    </span><br><span class="line">    printList(&quot;mlist&quot;, mlist);</span><br><span class="line">    printList(&quot;mlist1&quot;, mlist1);</span><br><span class="line">    printList(&quot;mlist2&quot;, mlist2);</span><br><span class="line">    printList(&quot;mlist3&quot;, mlist3);</span><br><span class="line">    printList(&quot;mlist4&quot;, mlist4);</span><br><span class="line">    </span><br><span class="line">    //front 和back 获得第一个元素和最后一个元素</span><br><span class="line">    cout&lt;&lt;&quot;mlist front: &quot;&lt;&lt;mlist.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist back: &quot;&lt;&lt;mlist.back()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //遍历通过iterator</span><br><span class="line">    cout&lt;&lt;&quot;print all elements by iterator: &quot;;</span><br><span class="line">    list&lt;int&gt;::iterator a  = mlist.begin();</span><br><span class="line">    for(;a!=mlist.end();a++)&#123;</span><br><span class="line">        cout&lt;&lt;*a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // capacity相关</span><br><span class="line">    cout&lt;&lt;&quot;mlist empty &quot;&lt;&lt;mlist.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist size() &quot;&lt;&lt;mlist.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist max_size &quot;&lt;&lt;mlist.max_size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // Modifiers相关</span><br><span class="line">    //插入操作</span><br><span class="line">    mlist.insert(mlist.begin(), 10);</span><br><span class="line">    // 同样不能通过类似于 mlist.insert(mlist.begin()+2, 10);来插入元素</span><br><span class="line">    mlist.emplace(mlist.begin(), 9);</span><br><span class="line">    printList(&quot;insert begin(): &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //插入到头部</span><br><span class="line">    mlist.push_front(10);</span><br><span class="line">    printList(&quot;push_front 10: &quot;, mlist);</span><br><span class="line">    mlist.emplace_front(9);</span><br><span class="line">    printList(&quot;emplace_front 9: &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除头元素</span><br><span class="line">    mlist.pop_front();</span><br><span class="line">    printList(&quot;pop_front : &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 插入到尾部</span><br><span class="line">    mlist.push_back(10);</span><br><span class="line">    printList(&quot;push_back 10: &quot;, mlist);</span><br><span class="line">    mlist.emplace_back(11);</span><br><span class="line">    printList(&quot;emplace_back 11&quot;, mlist);</span><br><span class="line">    // 删除尾部元素</span><br><span class="line">    mlist.pop_back();</span><br><span class="line">    printList(&quot;pop back&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    auto a4 = find(mlist.begin(),mlist.end(),4);</span><br><span class="line">    mlist.erase(a4);</span><br><span class="line">    printList(&quot;after erase a4&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    mlist.erase(mlist.begin());</span><br><span class="line">    printList(&quot;after earse begin()&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 排序:默认从小到大</span><br><span class="line">    mlist.sort();</span><br><span class="line">    printList(&quot;after sort&quot;, mlist);</span><br><span class="line">    //当然可以改成从大到小</span><br><span class="line">    mlist.sort(greater&lt;int&gt;());</span><br><span class="line">    printList(&quot;after sort big -&gt; small &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //顺序反转</span><br><span class="line">    mlist.reverse();</span><br><span class="line">    printList(&quot;after reverse &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除重复节点</span><br><span class="line">    mlist.unique();</span><br><span class="line">    printList(&quot;after unique&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //删除list中值为10的节点</span><br><span class="line">    mlist.remove(10);</span><br><span class="line">    printList(&quot;after remove 10:&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 删除list中值大于等于3的节点,这里使用了lamda表达式</span><br><span class="line">    mlist.remove_if([](int n)&#123;return n&gt;=3;&#125;);</span><br><span class="line">    printList(&quot;after remove &gt;=3 :&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;before clear the size of list is &quot;&lt;&lt; mlist.size()&lt;&lt;endl;</span><br><span class="line">    mlist.clear();</span><br><span class="line">    cout&lt;&lt;&quot;after clear the size of list is &quot;&lt;&lt; mlist.size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> mlist    1    2    3    4</span><br><span class="line"> mlist1    1    2    3</span><br><span class="line"> mlist2    1    2    3    4</span><br><span class="line"> mlist3    1    1    1    1    1</span><br><span class="line"> mlist4    1    2    3    4    5</span><br><span class="line"> mlist front: 1</span><br><span class="line"> mlist back: 4</span><br><span class="line"> print all elements by iterator: 1    2    3    4</span><br><span class="line"> mlist empty 0</span><br><span class="line"> mlist size() 4</span><br><span class="line"> mlist max_size 768614336404564650</span><br><span class="line"> insert begin():     9    10    1    2    3    4</span><br><span class="line"> push_front 10:     10    9    10    1    2    3    4</span><br><span class="line"> emplace_front 9:     9    10    9    10    1    2    3    4</span><br><span class="line"> pop_front :     10    9    10    1    2    3    4</span><br><span class="line"> push_back 10:     10    9    10    1    2    3    4    10</span><br><span class="line"> emplace_back 11    10    9    10    1    2    3    4    10    11</span><br><span class="line"> pop back    10    9    10    1    2    3    4    10</span><br><span class="line"> after erase a4    10    9    10    1    2    3    10</span><br><span class="line"> after earse begin()    9    10    1    2    3    10</span><br><span class="line"> after sort    1    2    3    9    10    10</span><br><span class="line"> after sort big -&gt; small     10    10    9    3    2    1</span><br><span class="line"> after reverse     1    2    3    9    10    10</span><br><span class="line"> after unique    1    2    3    9    10</span><br><span class="line"> after remove 10:    1    2    3    9</span><br><span class="line"> after remove &gt;=3 :    1    2</span><br><span class="line"> before clear the size of list is 2</span><br><span class="line"> after clear the size of list is 0</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第三篇.&lt;br&gt;主要测试了list相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="List" scheme="http://yoursite.com/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>deque的简单使用</title>
    <link href="http://yoursite.com/2020/02/06/deque%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/06/deque的简单使用/</id>
    <published>2020-02-06T05:41:30.000Z</published>
    <updated>2020-02-06T07:36:15.247Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第二篇.<br>主要测试了deque相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void printContainer(const char * msg,const T&amp; s)&#123;</span><br><span class="line">    cout&lt;&lt;msg&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    copy(s.begin(),s.end(),ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //三种声明方式</span><br><span class="line">    deque&lt;int&gt; s=&#123;1,2,3,4&#125;;</span><br><span class="line">    deque&lt;int&gt; s1&#123;1,2,3,4&#125;;</span><br><span class="line">    deque&lt;int&gt; s2(s.begin(),s.end()-1);</span><br><span class="line"></span><br><span class="line">    printContainer(&quot;deque s&quot;,s);</span><br><span class="line">    printContainer(&quot;deque s1&quot;,s1);</span><br><span class="line">    printContainer(&quot;deque s2 &quot;,s2);</span><br><span class="line">    </span><br><span class="line">    //两种获取对应位置元素的方式</span><br><span class="line">    cout&lt;&lt;&quot;s[0] &quot;&lt;&lt;s[0]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;a.at[0] &quot;&lt;&lt;s.at(0)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //打印出全部的元素</span><br><span class="line">    cout&lt;&lt;&quot;print all elements &quot;&lt;&lt;endl;</span><br><span class="line">    for(auto i:s)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;print all elements by iteror&quot;&lt;&lt;endl;</span><br><span class="line">    auto siter = s.begin();</span><br><span class="line">    while(siter!=s.end())&#123;</span><br><span class="line">        cout&lt;&lt;*siter&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        siter++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;s.front() &quot;&lt;&lt;s.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.back() &quot;&lt;&lt;s.back()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;s.begin() &quot;&lt;&lt;*s.begin()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.end()-s.begin() &quot;&lt;&lt;s.end()-s.begin()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;s.empty() &quot;&lt;&lt;s.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.size() &quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.max_size() &quot;&lt;&lt;s.max_size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //s.clear();</span><br><span class="line">    //cout&lt;&lt;&quot;after clear s.empty() &quot;&lt;&lt;s.empty()&lt;&lt;endl;  // 1</span><br><span class="line"></span><br><span class="line">    s.push_front(5);</span><br><span class="line">    printContainer(&quot;after push front 5: &quot;,s);</span><br><span class="line">    s.pop_front();</span><br><span class="line">    printContainer(&quot;after pop front: &quot;,s);</span><br><span class="line"></span><br><span class="line">    s.push_back(5);</span><br><span class="line">    printContainer(&quot;after push back5: &quot;,s);</span><br><span class="line">    s.pop_back();</span><br><span class="line">    printContainer(&quot;after pop back: &quot;,s);</span><br><span class="line"></span><br><span class="line">    s.emplace(s.begin()+2,5);</span><br><span class="line">    printContainer(&quot;emplace begin+2 &quot;,s);</span><br><span class="line"></span><br><span class="line">    s.emplace_back(6);</span><br><span class="line">    printContainer(&quot;emplace back&quot;,s);</span><br><span class="line"></span><br><span class="line">    s.erase(s.begin()+2);</span><br><span class="line">    printContainer(&quot;erase begin+2&quot;,s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //用列表容器1的内容给s赋值，将s输出</span><br><span class="line">    reverse(s.begin(),s.end());</span><br><span class="line">    printContainer(&quot;deque l by assign:&quot;,s);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> deque s    1 2 3 4</span><br><span class="line"> deque s1    1 2 3 4</span><br><span class="line"> deque s2     1 2 3</span><br><span class="line"> s[0] 1</span><br><span class="line"> a.at[0] 1</span><br><span class="line"> print all elements</span><br><span class="line"> 1    2    3    4</span><br><span class="line"> print all elements by iteror</span><br><span class="line"> 1    2    3    4</span><br><span class="line"> s.front() 1</span><br><span class="line"> s.back() 4</span><br><span class="line"> s.begin() 1</span><br><span class="line"> s.end()-s.begin() 4</span><br><span class="line"> s.empty() 0</span><br><span class="line"> s.size() 4</span><br><span class="line"> s.max_size() 4611686018427387903</span><br><span class="line"> after push front 5:     5 1 2 3 4</span><br><span class="line"> after pop front:     1 2 3 4</span><br><span class="line"> after push back5:     1 2 3 4 5</span><br><span class="line"> after pop back:     1 2 3 4</span><br><span class="line"> emplace begin+2     1 2 5 3 4</span><br><span class="line"> emplace back    1 2 5 3 4 6</span><br><span class="line"> erase begin+2    1 2 3 4 6</span><br><span class="line"> deque l by assign:    6 4 3 2 1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第二篇.&lt;br&gt;主要测试了deque相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Deque" scheme="http://yoursite.com/tags/Deque/"/>
    
  </entry>
  
  <entry>
    <title>vector的简单使用</title>
    <link href="http://yoursite.com/2020/02/06/vector%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/06/vector的简单使用/</id>
    <published>2020-02-06T04:51:33.000Z</published>
    <updated>2020-02-06T05:47:24.953Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第一篇.<br>主要测试了vector相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double getAverage(const vector&lt;double&gt; &amp;arr)&#123;</span><br><span class="line">    double sum =0;</span><br><span class="line">    for (unsigned i=0;i&lt;arr.size();i++)&#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum/arr.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void printVector(const char * msg,T&amp; s)&#123;</span><br><span class="line">    cout&lt;&lt;msg&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:s)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&apos;\n&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //vector 初始化的方式</span><br><span class="line">    vector&lt;double&gt; arr =&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">    vector&lt;int&gt; arr1(5,1);</span><br><span class="line">    vector&lt;int&gt; arr2&#123;1,2,3,4,5&#125;;</span><br><span class="line">    auto arr3 = &#123;1,2,3&#125;;</span><br><span class="line">    vector&lt;int&gt; arr4(arr2.begin(),arr2.begin()+2);</span><br><span class="line">    vector&lt;int&gt; arr5(5);</span><br><span class="line">    </span><br><span class="line">    printVector(&quot;print initial content arr:&quot;,arr);   //1    2    3    4    5    6</span><br><span class="line">    printVector(&quot;print initial content arr1:&quot;,arr1); // 1    1    1    1    1</span><br><span class="line">    printVector(&quot;print initial content arr2:&quot;,arr2); // 1    2    3    4    5</span><br><span class="line">    printVector(&quot;print initial content arr3:&quot;,arr3); // 1    2    3</span><br><span class="line">    printVector(&quot;print initial content arr4:&quot;,arr4); // 1    2</span><br><span class="line">    printVector(&quot;print initial content arr5:&quot;,arr5); // 0    0    0    0    0</span><br><span class="line">    </span><br><span class="line">    //直接通过索引获取数据</span><br><span class="line">    cout&lt;&lt;&quot;arr[2]: \t&quot;&lt;&lt;arr[2]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;arr.at(2) \t &quot;&lt;&lt;arr.at(2)&lt;&lt;endl;</span><br><span class="line">    // 通过front获得头元素。通过back获得尾部元素</span><br><span class="line">    cout&lt;&lt;&quot;arr.front() \t&quot;&lt;&lt;arr.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;arr.back() \t&quot;&lt;&lt;arr.back()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;arr.data()\t&quot;&lt;&lt;*(arr.data()+1)&lt;&lt;endl; </span><br><span class="line">    // arr.data()返回值是一个指针，指向数组的第一个值</span><br><span class="line">    // arr.begin()返回值是一个iterator, 同样指向数组的第一个值。</span><br><span class="line">    cout&lt;&lt;&quot;*data() == *begin() &quot;&lt;&lt;(*arr.data()==*arr.begin())&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;arr.begin()\t&quot;&lt;&lt;*arr.begin()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // size()是获取当前vector的元素个数</span><br><span class="line">    cout&lt;&lt;&quot;arr.size()\t&quot;&lt;&lt;arr.size()&lt;&lt;endl;</span><br><span class="line">    // empty()是判断当前数组是否为空</span><br><span class="line">    cout&lt;&lt;&quot;arr.empty()\t&quot;&lt;&lt;arr.empty()&lt;&lt;endl;</span><br><span class="line">    // capacity() returns the number of elements </span><br><span class="line">    that can be held in currently allocated storage</span><br><span class="line">    cout&lt;&lt;&quot;arr.capacity()\t&quot;&lt;&lt;arr.capacity()&lt;&lt;endl;</span><br><span class="line">    // returns the maximum possible number of elements</span><br><span class="line">    cout&lt;&lt;&quot;arr.max_size()\t&quot;&lt;&lt;arr.max_size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    // 清空整个数组</span><br><span class="line">    arr.clear();</span><br><span class="line">    printVector(&quot;arr.clear()&quot;, arr);</span><br><span class="line"> </span><br><span class="line">    //insert 在对应位置前面添加一个元素，成为这个位置的元素</span><br><span class="line">    arr.insert(arr.begin(), 1);</span><br><span class="line">    printVector(&quot;insert begin \t&quot;, arr);</span><br><span class="line">    arr.insert(arr.begin(), 4);</span><br><span class="line">    printVector(&quot;insert begin&quot;, arr);</span><br><span class="line">    arr.insert(arr.end(),2);</span><br><span class="line">    printVector(&quot;insert end()\t&quot;,arr);</span><br><span class="line">    </span><br><span class="line">    //emplace 在对应位置前面添加一个元素,功能类似于insert.</span><br><span class="line">    //两者的区别在于insert插入的是一个对象，一个已经构建好的对象</span><br><span class="line">    // 而emplace可以直接传入参数，这里隐含一个构造函数。</span><br><span class="line">    arr.emplace(arr.begin(), 3);</span><br><span class="line">    printVector(&quot;emplace begin()&quot;, arr);</span><br><span class="line">    arr.emplace(arr.begin()+1,5);</span><br><span class="line">    printVector(&quot;emplace begin+1&quot;, arr);</span><br><span class="line">    </span><br><span class="line">    //erase：删除iteator所指向的元素。</span><br><span class="line">    arr.erase(arr.begin());</span><br><span class="line">    printVector(&quot;erase begin \t&quot;, arr);</span><br><span class="line">    arr.erase(arr.end()-1);</span><br><span class="line">    printVector(&quot;erase end-1&quot;,arr);</span><br><span class="line">    </span><br><span class="line">    // arr.begin()返回指向vector第一个元素的指针</span><br><span class="line">    // arr.end()返回指向vector最后一个元素再后面一个元素的指针。</span><br><span class="line">    printVector(&quot;print arr &quot;, arr);</span><br><span class="line">    cout&lt;&lt;&quot;arr.begin() \t&quot;&lt;&lt;*arr.begin()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;arr.end()-1 \t&quot;&lt;&lt;*(arr.end()-1)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;arr.end() \t&quot;&lt;&lt;*arr.end()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    // 通过iterator打印整个vector</span><br><span class="line">    cout&lt;&lt;&quot;print the vector&quot;&lt;&lt;endl;</span><br><span class="line">    // 下面两个构造方式等价，auto 是c++11的新特性。</span><br><span class="line">    //vector&lt;double&gt;::iterator a = arr.begin();</span><br><span class="line">    auto a = arr.begin();</span><br><span class="line">    while(a!=arr.end())&#123;</span><br><span class="line">        cout&lt;&lt;*a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // vector 添加一个元素到末尾</span><br><span class="line">    arr.push_back(6);</span><br><span class="line">    printVector(&quot;push back 6： &quot;, arr);</span><br><span class="line">    </span><br><span class="line">    // vector 删除最后一个元素</span><br><span class="line">    arr.pop_back();</span><br><span class="line">    printVector(&quot;pop back 6： &quot;, arr);</span><br><span class="line">    </span><br><span class="line">    // 先打印原来的数据。</span><br><span class="line">    printVector(&quot;former vector&quot;, arr);</span><br><span class="line">    </span><br><span class="line">    // 这个其实也是构造函数，得到arr树组的反序树组</span><br><span class="line">    vector&lt;int&gt; rarr(arr.rbegin(),arr.rend());</span><br><span class="line">    printVector(&quot;reverse arr&quot;, rarr);</span><br><span class="line">    </span><br><span class="line">    // 可以直接通过stl中的reverse方式来将原来的vector进行逆序</span><br><span class="line">    reverse(arr.begin(),arr.end());</span><br><span class="line">    printVector(&quot;reverse former arr&quot;, arr);</span><br><span class="line">    </span><br><span class="line">    // 调用前面的方法得到树组的平均数</span><br><span class="line">    cout&lt;&lt;&quot;average of arr:&quot;&lt;&lt;getAverage(arr)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果</span><br><span class="line"> print initial content arr:    1    2    3    4    5    6</span><br><span class="line"> print initial content arr1:    1    1    1    1    1</span><br><span class="line"> print initial content arr2:    1    2    3    4    5</span><br><span class="line"> print initial content arr3:    1    2    3</span><br><span class="line"> print initial content arr4:    1    2</span><br><span class="line"> print initial content arr5:    0    0    0    0    0</span><br><span class="line"> arr[2]:     3</span><br><span class="line"> arr.at(2)      3</span><br><span class="line"> arr.front()     1</span><br><span class="line"> arr.back()     6</span><br><span class="line"> arr.data()    2</span><br><span class="line"> *data() == *begin() 1</span><br><span class="line"> arr.begin()    1</span><br><span class="line"> arr.size()    6</span><br><span class="line"> arr.empty()    0</span><br><span class="line"> arr.capacity()    6</span><br><span class="line"> arr.max_size()    2305843009213693951</span><br><span class="line"> arr.clear()</span><br><span class="line"> insert begin         1</span><br><span class="line"> insert begin    4    1</span><br><span class="line"> insert end()        4    1    2</span><br><span class="line"> emplace begin()    3    4    1    2</span><br><span class="line"> emplace begin+1    3    5    4    1    2</span><br><span class="line"> erase begin         5    4    1    2</span><br><span class="line"> erase end-1    5    4    1</span><br><span class="line"> print arr     5    4    1</span><br><span class="line"> arr.begin()     5</span><br><span class="line"> arr.end()-1     1</span><br><span class="line"> arr.end()     2</span><br><span class="line"> print the vector</span><br><span class="line"> 5    4    1    push back 6：     5    4    1    6</span><br><span class="line"> pop back 6：     5    4    1</span><br><span class="line"> former vector    5    4    1</span><br><span class="line"> reverse arr    1    4    5</span><br><span class="line"> reverse former arr    1    4    5</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第一篇.&lt;br&gt;主要测试了vector相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Vector" scheme="http://yoursite.com/tags/Vector/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-孩子们的游戏</title>
    <link href="http://yoursite.com/2020/01/29/%E5%89%91%E6%8C%87offer-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
    <id>http://yoursite.com/2020/01/29/剑指offer-孩子们的游戏/</id>
    <published>2020-01-29T02:07:05.000Z</published>
    <updated>2020-01-29T02:27:46.816Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十七篇。<br>主要知识点为约瑟夫环，偏向于数学一点，值得认真仔细的看。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)<br>如果没有小朋友，请返回-1；</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>通过一个环形链表来循环跑圈，每次删除编号为m-1的节点，直到最后只剩下一个节点，就是想要的节点。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>约瑟夫环。<br>最开始是n个人，m个数字，如果从0开始编码，那么第一个删除的节点k = (m-1)%n,继续向后从0开始对k+1,k+2,……,0,1,……，n-2,n-1进行编号，则前后的对应关系如下。<br>X  -&gt; Y<br>k+1 -&gt; 0<br>k+2 -&gt; 1<br>……<br>0  -&gt; n-k-1<br>1  -&gt; n-k<br>……<br>n-1 -&gt; n-2<br>我们可以发现变化后的编号Y和变化前的编号有一定的对应关系，<br>Y = (X-k-1)%n,对以的X = (Y+k+1)%n,将k = (m-1)%n代入，X = (Y+m)%n，<br>我们将这个关系用函数表示，F(n,m)表示n个人每次删除第m个数字最后剩下的数字，则上面的关系就变成了F(n,m) = (F(n-1,m)+m)%n,同时很明显的F(1,m) = 0;<br>进而可以利用递归得到我们最后的解。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int LastRemaining_Solution(int n, int m)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n &lt; 1 || m &lt; 1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(n == 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // F[n] = (F[n - 1] + m) % n</span><br><span class="line">            return (LastRemaining_Solution(n-1,m)+m)%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十七篇。&lt;br&gt;主要知识点为约瑟夫环，偏向于数学一点，值得认真仔细的看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉搜索树与双向链表</title>
    <link href="http://yoursite.com/2020/01/28/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/01/28/剑指offer-二叉搜索树与双向链表/</id>
    <published>2020-01-28T03:55:29.000Z</published>
    <updated>2020-01-28T10:59:45.763Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十六篇。<br>主要知识点为二叉搜索树还有双向链表，这个题目个人感觉比较难，但是题目非常好。<br>值得我们认真且细致的去理解两者之间的关系，并将这个问题做出来。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>首先我们要明晰二叉搜索树和双向链表各自的特点。</li><li>然后在处理的时候可以将这个二叉搜索树分为三部分，左子树，根节点，右子树。我们的目标实际上就是将左子树转化成的双向链表链接上根节点再链接到右子树转化成的双向链表，所以自然就会想到用递归来实现。</li><li>最后就是细节的处理，要注意在链接左子树和根节点的时候，是将左子树的最大的节点和根节点链接起来，其实就是右下角的节点，<br>在链接根节点和右子树的时候，是将根节点和右子树中最小的节点进行链接，其实也就是最左下角的节点。</li></ul><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* Convert(TreeNode* pRootOfTree)&#123;</span><br><span class="line">         if(pRootOfTree==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">        if(pRootOfTree-&gt;left==NULL&amp;&amp;pRootOfTree-&gt;right==NULL)</span><br><span class="line">            return pRootOfTree;//如果是叶子结点则直接返回当前节点</span><br><span class="line">        TreeNode* left = Convert(pRootOfTree-&gt;left);//找到左子树最左端节点</span><br><span class="line">        TreeNode* curr = left;</span><br><span class="line">        </span><br><span class="line">        //找到左子树最右侧节点</span><br><span class="line">        while(curr!=NULL&amp;&amp;curr-&gt;right!=NULL)</span><br><span class="line">            curr=curr-&gt;right;</span><br><span class="line">        //连接根节点和左子树</span><br><span class="line">        if(curr!=NULL)&#123;</span><br><span class="line">            curr-&gt;right=pRootOfTree;</span><br><span class="line">            pRootOfTree-&gt;left = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //找到右子树最左端节点</span><br><span class="line">        TreeNode* right = Convert(pRootOfTree-&gt;right);</span><br><span class="line">        //连接根节点和右子树</span><br><span class="line">        if(right!=NULL)&#123;</span><br><span class="line">            pRootOfTree-&gt;right = right;</span><br><span class="line">            right-&gt;left = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        return left!=NULL?left:pRootOfTree;//返回最左边节点的位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十六篇。&lt;br&gt;主要知识点为二叉搜索树还有双向链表，这个题目个人感觉比较难，但是题目非常好。&lt;br&gt;值得我们认真且细致的去理解两者之间的关系，并将这个问题做出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinarySearchTree" scheme="http://yoursite.com/tags/BinarySearchTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-替换空格</title>
    <link href="http://yoursite.com/2020/01/28/%E5%89%91%E6%8C%87offer-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2020/01/28/剑指offer-替换空格/</id>
    <published>2020-01-28T03:21:42.000Z</published>
    <updated>2020-01-28T03:42:06.289Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十五篇。<br>主要知识点为字符串，平常就是一个调库可以解决的问题，这里要自己来实现。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>由于c++的char类型没有封装好的用来替换字符的方法，所以我们可以用python直接调用库来解决。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>其实可以再申请一段空间作为res，然后依次的遍历原来的char，碰到非空格就直接加到res中，碰到空格就加上“%20”，最后将原来的指针指向新的res即可。</p><h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>思路2存在一个问题就是需要再申请一段空间，其实可以直接在原来的char上进行操作。<br>按照正常情况，char字符串是以‘\0’为标识结束的，所以我们可以往后延长数据，延长（2*空格个数）个字节，因为本来的一个空格现在变成了‘20%’。<br>用两个指针分别指向原来的字符串和延长后字符串的最后一位，依次向前遍历，将非空格数据进行后移，将空格数据进行替换。<br>等到两个指针重合说明已经替换完成，从而这个问题就结束了。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    # s 源字符串 </span><br><span class="line">    # 直接调用替换函数 24ms 5868k</span><br><span class="line">    def replaceSpace(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        return s.replace(&apos; &apos;,&apos;%20&apos;)</span><br></pre></td></tr></table></figure><h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        int spaceNum = 0;</span><br><span class="line">        char *p = str;</span><br><span class="line">        while(*p != &apos;\0&apos;)&#123;</span><br><span class="line">            if(*p == &apos; &apos;)&#123;</span><br><span class="line">                spaceNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        char* last = p+spaceNum*2;</span><br><span class="line">        while(p != last)&#123;</span><br><span class="line">            if(*p == &apos; &apos;)&#123;</span><br><span class="line">                *(last--) = &apos;0&apos;;</span><br><span class="line">                *(last--) = &apos;2&apos;;</span><br><span class="line">                *(last--) = &apos;%&apos;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                *(last--) = *(p);</span><br><span class="line">            &#125;</span><br><span class="line">            p--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十五篇。&lt;br&gt;主要知识点为字符串，平常就是一个调库可以解决的问题，这里要自己来实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-剪绳子</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-剪绳子/</id>
    <published>2020-01-27T06:15:35.000Z</published>
    <updated>2020-01-27T08:45:58.079Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十四篇。<br>主要知识点为整数拆分，可以用贪心算法或者动态规划来解决。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="">题目描述</a></h2><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>输入描述:<br>输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）<br>输出描述:<br>输出答案。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1贪心算法"><a href="#思路1贪心算法" class="headerlink" title="思路1贪心算法"></a>思路1贪心算法</h3><p>设绳长为n，则有如下的结论</p><ol><li>n = 2,剪成2段，1*1 = 1</li><li>n = 3,剪成2段，1*2 = 2</li><li>n = 4,剪成2段，2*2 = 4</li><li>n = 5,剪成2段, 2*3 = 6</li><li>n = 6,剪成2段，3*3 = 9</li></ol><p>当n &gt; 5的时候3<em>(n-3)&gt; 2</em>(n-2)<br>所以答案就是尽可能的多剪长度为3的段,同时不要长度为1的段;如果有1，那就和3一起拼成一个4，切割成2和2。</p><h3 id="思路2动态规划"><a href="#思路2动态规划" class="headerlink" title="思路2动态规划"></a>思路2动态规划</h3><p>假设长度为n的绳子的结果为f(n)，如果我们切一刀,变为n-i和i两段，<br>那么f(n)应该等于f(n-i)*f(i),所以在计算后面的f值的时候，会用到前面的f值，<br>所以对前面的结果进行保存。自底向上的得到我们最后的解。<br>然后考虑到类似于2,3,4这种其实不切一刀要比切一刀的结果更大，所以在计算f(n)的时候要将i*(n-i)考虑在内，意味着说这段如果只切一刀（切完的两端不再进行进一步的切割，比如4就切成2和2，而不是f(2)*f(2)）会得到一个什么样的结果。<br>所以综合以上考虑,对于长为n的绳子，f(n) = max(f(n-i)*f(i),(n-i)*i), i的取值从1到n-1;</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h2 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cutRope(int number) &#123;</span><br><span class="line">        if(number == 2) return 1;</span><br><span class="line">        if(number == 3) return 2;</span><br><span class="line">        if(number == 4) return 4;</span><br><span class="line">        if(number == 5) return 6;</span><br><span class="line">        return 3*cutRope(number-3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h2 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cutRope(int number) &#123;</span><br><span class="line">        // 方法2 ：dp</span><br><span class="line">        vector&lt;int&gt; dp(number+1,0);</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2; i&lt;=number; i++)&#123;</span><br><span class="line">            for(int j = 1;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i] = max(dp[i],max(dp[i-j]*j,(i-j)*j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n^2),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十四篇。&lt;br&gt;主要知识点为整数拆分，可以用贪心算法或者动态规划来解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-机器人的运动范围</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-机器人的运动范围/</id>
    <published>2020-01-27T05:34:33.000Z</published>
    <updated>2020-01-27T05:49:12.498Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十三篇。<br>主要知识点为二维数组的遍历和元素的处理，这个题目和前面的那个矩阵中的路径题目是类似的。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题目和矩阵中寻找路径是类似的，<br>我们可以将这个题目要处理的数据范围抽象成为rows*cols的一个矩阵（或者第一象限），然后从一个结点开始出发，判断其四周的数据是不是合法的，类似于深度优先搜索对每个结点进行遍历。<br>同样的为了保证访问的数据不会重复，需要通过一个数组来保存每个数据之前是否已经被处理过。<br>这种处理方式比较经典，要多加锻炼。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int movingCount(int threshold, int rows, int cols)</span><br><span class="line">    &#123;</span><br><span class="line">        if(threshold &lt;= 0 || rows &lt;=0 || cols &lt;= 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bool *flags = new bool[rows*cols];</span><br><span class="line">        for(int i = 0; i &lt; rows * cols; i++)&#123;</span><br><span class="line">             flags[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(threshold,rows,cols,0,0,flags);</span><br><span class="line">    &#125;</span><br><span class="line">    int helper(int threshold,int rows,int cols,int i,int j,bool *flags)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if(checkToGo(threshold,rows,cols,i,j,flags))&#123;</span><br><span class="line">            flags[i*cols+j] = true;</span><br><span class="line">            res = 1+helper(threshold,rows,cols,i+1,j,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i-1,j,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i,j+1,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i,j-1,flags);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool checkToGo(int threshold,int rows,int cols,int i,int j,bool *flags)&#123;</span><br><span class="line">        if(i&gt;=0 &amp;&amp; i&lt;rows &amp;&amp; j&gt;=0 &amp;&amp; j&lt;cols &amp;&amp; checkThreshold(threshold,i,j) &amp;&amp; flags[i*cols+j] == false)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool checkThreshold(int threshold,int i,int j)&#123;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        while(i)&#123;</span><br><span class="line">            temp += i%10;</span><br><span class="line">            i = i/10;</span><br><span class="line">        &#125;</span><br><span class="line">        while(j)&#123;</span><br><span class="line">            temp += j%10;</span><br><span class="line">            j = j/10;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp&lt;=threshold;</span><br><span class="line">    &#125;</span><br><span class="line">    private:</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(cols*rows*lg(max(rows,cols)),空间复杂度为O(cols*rows)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十三篇。&lt;br&gt;主要知识点为二维数组的遍历和元素的处理，这个题目和前面的那个矩阵中的路径题目是类似的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-矩阵中的路径</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-矩阵中的路径/</id>
    <published>2020-01-27T04:55:04.000Z</published>
    <updated>2020-01-27T05:24:58.138Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十二篇。<br>主要知识点为数组，在矩阵中查找对应的字符串序列，类似于走迷宫或者找包围区间的题目。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历矩阵中的每个结点作为起始结点，然后从这个点开始向四周遍历，寻找字符串的下一个字符，如果字符串匹配到最后的结束标志’\0’,那就返回true,反之就返回false.<br>需要注意的一点是之前访问过的就不能访问了，所以需要找一个数组或者矩阵来标志这个节点之前是否已经访问过。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPath(char* matrix, int rows, int cols, char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(rows&lt;=0 || cols&lt;=0 || !str || !matrix) return false;</span><br><span class="line">        vector&lt;bool&gt; flags(rows*cols,0);</span><br><span class="line">        for(int i = 0; i &lt; rows; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; cols; j++)&#123;</span><br><span class="line">                if(helper(matrix,rows,cols,i,j,str,flags)) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool helper(char* matrix,int rows,int cols,int i,int j,char* str,vector&lt;bool&gt; flags)&#123;</span><br><span class="line">        if(*str == &apos;\0&apos;) return true;</span><br><span class="line">        if(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; rows &amp;&amp; j &lt; cols &amp;&amp; matrix[i*cols+j] == *str &amp;&amp; flags[i*cols+j] == false)&#123;</span><br><span class="line">            flags[i*cols+j] = true;</span><br><span class="line">            bool find = false;</span><br><span class="line">            find = helper(matrix,rows,cols,i,j+1,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i,j-1,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i+1,j,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i-1,j,str+1,flags);</span><br><span class="line">            if(find == false)&#123;</span><br><span class="line">                flags[i*cols+j] = false;</span><br><span class="line">            &#125;</span><br><span class="line">            return find;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(rows*cols*logn),空间复杂度为O(rows*cols)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十二篇。&lt;br&gt;主要知识点为数组，在矩阵中查找对应的字符串序列，类似于走迷宫或者找包围区间的题目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-滑动窗口的最大值</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-滑动窗口的最大值/</id>
    <published>2020-01-27T04:45:30.000Z</published>
    <updated>2020-01-27T04:52:29.790Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十一篇。<br>主要知识点为数组，题目看起来很炫酷，但是实际上就是一个给定区间的遍历找最大值而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接使用stl的max_element方法来获得对应区间的最大值。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>朴素算法，自己实现类似于max_element的方法。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">    &#123;</span><br><span class="line">       // 方法1: 直接使用stl中的max_element函数得到对应的窗口</span><br><span class="line">       if(num.size() == 0 || size &lt;=0 ||size&gt;num.size() ) return&#123;&#125;;</span><br><span class="line">       vector&lt;int&gt; res;</span><br><span class="line">       for(int i = 0; i&lt;=num.size()-size; i++)&#123;</span><br><span class="line">            int cur = *max_element(num.begin()+i,num.begin()+i+size);</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">    &#123;</span><br><span class="line">       // 方法2:朴素的方法依次向后比较窗口大小个元素</span><br><span class="line">       if(num.size() == 0 || size &lt;=0 ||size&gt;num.size() ) return&#123;&#125;;</span><br><span class="line">       vector&lt;int&gt; res;</span><br><span class="line">       for(int i = 0; i &lt;= num.size()-size; i++)&#123;</span><br><span class="line">           int temp = num[i];</span><br><span class="line">           for(int j = i+1; j&lt;i+size; j++)&#123;</span><br><span class="line">               if(num[j]&gt;temp)&#123;</span><br><span class="line">                   temp = num[j];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res.push_back(temp);</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十一篇。&lt;br&gt;主要知识点为数组，题目看起来很炫酷，但是实际上就是一个给定区间的遍历找最大值而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数据流中的中位数</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-数据流中的中位数/</id>
    <published>2020-01-27T02:44:08.000Z</published>
    <updated>2020-01-27T04:41:10.183Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十篇。<br>主要知识点为数组，依旧是数组遍历然后分析找中位数，比较简单。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="">题目描述</a></h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>找一个数组，用来存储所有插入的数据，并保持数组内的数据有序（可以用插入排序的方式）。<br>在获得中间数的时候，可以通过奇偶直接从数组中获取处理并返回。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Insert(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        mvec.push_back(num);</span><br><span class="line">        len++;</span><br><span class="line">        //sort(mvec.begin(),mvec.end());</span><br><span class="line">        int i = len;</span><br><span class="line">        for( ; i &gt;= 1; i--)&#123;</span><br><span class="line">            if(num&lt;=mvec[i])&#123;</span><br><span class="line">                mvec[i] = mvec[i-1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mvec[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double GetMedian()</span><br><span class="line">    &#123; </span><br><span class="line">        int mindex = (len-1)/2;</span><br><span class="line">        if(len%2 == 0)&#123;</span><br><span class="line">            return ((mvec[mindex]+(double)mvec[mindex+1])/2);  </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (double)mvec[mindex];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; mvec;</span><br><span class="line">    int len = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十篇。&lt;br&gt;主要知识点为数组，依旧是数组遍历然后分析找中位数，比较简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉搜索树的第k个结点</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-二叉搜索树的第k个结点/</id>
    <published>2020-01-27T01:50:33.000Z</published>
    <updated>2020-01-27T02:39:17.705Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十九篇。<br>主要知识点为二叉搜索树，二叉搜索树由于本身的特性，其中序遍历结果是有序的，<br>针对这一点，经常有题目出现。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。<br>例如（5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>中序遍历，将遍历的节点数据保存到一个数组中，然后返回数组的第K个节点即可。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>找一个全局计数器表示中序遍历到多少个节点，如果到第K个节点就可以直接返回当前结果了。如果没有到第K个节点，那么就返回NULL。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        if(!pRoot || k&lt;=0) return NULL; </span><br><span class="line">        inorder(pRoot,res);</span><br><span class="line">        if(res.size() &lt; k)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return res[k-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;TreeNode*&gt; res;</span><br><span class="line">    void inorder(TreeNode* root,vector&lt;TreeNode*&gt;&amp; res)&#123;</span><br><span class="line">        if(!root) return ;</span><br><span class="line">        if(root-&gt;left) inorder(root-&gt;left,res);</span><br><span class="line">        res.push_back(root);</span><br><span class="line">        if(root-&gt;right) inorder(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        if(!pRoot || k&lt;=0) return NULL; </span><br><span class="line">        inorder(pRoot,k);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    TreeNode* res = NULL;</span><br><span class="line">    void inorder(TreeNode* root,int k)&#123;</span><br><span class="line">        if(!root) return ;</span><br><span class="line">        if(root-&gt;left) inorder(root-&gt;left,k);</span><br><span class="line">        count++;</span><br><span class="line">        if(count == k)&#123;</span><br><span class="line">            res = root;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right) inorder(root-&gt;right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十九篇。&lt;br&gt;主要知识点为二叉搜索树，二叉搜索树由于本身的特性，其中序遍历结果是有序的，&lt;br&gt;针对这一点，经常有题目出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinarySearchTree" scheme="http://yoursite.com/tags/BinarySearchTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-序列化二叉树</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-序列化二叉树/</id>
    <published>2020-01-27T00:57:21.000Z</published>
    <updated>2020-01-27T01:39:38.236Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十八篇。<br>主要知识点为二叉树，针对于一棵给定的二叉树进行编码和解码。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先就是按照正常的先序遍历的思路对原来的二叉树进行存储，用,来隔离每个节点，用#来表示空节点。用递归的思路来进行编码。<br>解码的时候操作反过来，针对于之前编码生成的字符串，从头到尾依次遍历，通过<strong>,</strong>来对节点进行分离，通过#来判定当前节点为空，通过递归的方式生成之前的二叉树。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char* Serialize(TreeNode *root) &#123;   </span><br><span class="line">        if(!root) return &quot;#&quot;;</span><br><span class="line">        string r = to_string(root-&gt;val);</span><br><span class="line">        r.push_back(&apos;,&apos;);</span><br><span class="line">        char *left = Serialize(root-&gt;left);</span><br><span class="line">        char *right = Serialize(root-&gt;right);</span><br><span class="line">        char *ret = new char[strlen(left) + strlen(right) + r.size()];</span><br><span class="line">        strcpy(ret, r.c_str());</span><br><span class="line">        strcat(ret, left);</span><br><span class="line">        strcat(ret, right);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* Deserialize(char *str) &#123;</span><br><span class="line">        return decode(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    TreeNode* decode(char *&amp;str) &#123;</span><br><span class="line">        if(*str==&apos;#&apos;)&#123;</span><br><span class="line">            str++;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        int num = 0;</span><br><span class="line">        while(*str != &apos;,&apos;)</span><br><span class="line">            num = num*10 + (*(str++)-&apos;0&apos;);</span><br><span class="line">        str++;</span><br><span class="line">        TreeNode *root = new TreeNode(num);</span><br><span class="line">        root-&gt;left = decode(str);</span><br><span class="line">        root-&gt;right = decode(str);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十八篇。&lt;br&gt;主要知识点为二叉树，针对于一棵给定的二叉树进行编码和解码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-把二叉树打印成多行</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-把二叉树打印成多行/</id>
    <published>2020-01-26T10:58:48.000Z</published>
    <updated>2020-01-26T13:47:33.980Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十七篇。<br>主要知识点为二叉树，就是简单的层序遍历而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是简单的层序遍历。<br>用队列保存每一层的结果，方便遍历下一层，<br>同时本层的结果放到一个数组中进行存储。<br>所有层数组的集合就是我们的最终结果。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* root) &#123;</span><br><span class="line">            if(!root) return &#123;&#125;;</span><br><span class="line">            vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">            queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">            while(!q.empty())&#123;</span><br><span class="line">                vector&lt;int&gt; level;</span><br><span class="line">                for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                    auto a = q.front(); q.pop();</span><br><span class="line">                    level.push_back(a-&gt;val);</span><br><span class="line">                    if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                    if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(level);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十七篇。&lt;br&gt;主要知识点为二叉树，就是简单的层序遍历而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-按之字形顺序打印二叉树</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-按之字形顺序打印二叉树/</id>
    <published>2020-01-26T10:42:46.000Z</published>
    <updated>2020-01-26T10:57:29.949Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十六篇。<br>主要知识点为二叉树，就是层序遍历的变形而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>层序遍历的思路。<br>通过队列来保存每一层的节点，方便下一层的遍历,同时本层的结果要放在本层的数组中，<br>由于要之字形进行保存，也就是说奇数层和偶数层要分别处理，所以要记录层数,用于之后的判断。</p><ul><li>单数层添加的时候插入到本层数组的后面，实现从左到右依次添加的效果;</li><li>双数层添加的时候每次插入到数组的头部，实现类似从右往左添加的效果。</li></ul><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        int levelnum = 1;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; level;</span><br><span class="line">            for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                auto a = q.front(); q.pop();</span><br><span class="line">                if(levelnum%2 == 1)&#123;</span><br><span class="line">                   level.push_back(a-&gt;val);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                   level.insert(level.begin(),a-&gt;val);   </span><br><span class="line">                &#125;</span><br><span class="line">                if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">            levelnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十六篇。&lt;br&gt;主要知识点为二叉树，就是层序遍历的变形而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-对称的二叉树</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-对称的二叉树/</id>
    <published>2020-01-26T10:25:39.000Z</published>
    <updated>2020-01-26T10:41:28.309Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十五篇。<br>主要知识点为二叉树，就是简单的判断一棵树是不是对称二叉树。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>什么时候一棵树是对称的呢？<br>首先，根节点相同；<br>其次，如果左右子树都不存在，肯定是对称的；如果左右子树只存在一个，那么肯定是不对称的。<br>如果左右子树都存在，那么左子树是对称的，右子树也是对称的。<br>最后，通过辅助函数，递归调用，问题就可以得到解决。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetrical(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        return helper(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    bool helper(TreeNode* root1,TreeNode* root2)&#123;</span><br><span class="line">        if(!root1 &amp;&amp; !root2) return true;</span><br><span class="line">        if(!root1 || !root2) return false;</span><br><span class="line">        if(root1-&gt;val != root2-&gt;val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return helper(root1-&gt;left,root2-&gt;right) &amp;&amp; helper(root1-&gt;right,root2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十五篇。&lt;br&gt;主要知识点为二叉树，就是简单的判断一棵树是不是对称二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉树的下一个节点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-二叉树的下一个节点/</id>
    <published>2020-01-26T09:52:05.000Z</published>
    <updated>2020-01-26T10:24:39.244Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十四篇。<br>主要知识点为二叉树，查找二叉树中序遍历给定节点的下一个节点。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于给定的节点，</p><ol><li>如果存在右子树，那么给定节点中序遍历的下一个节点就是右子树的最左侧节点。</li><li>如果不存在右子树，那么就可能存在两种情况，<ol><li>当前节点是根节点的左子树，那么它中序遍历的下一个节点就是它的根节点。</li><li>当前节点是根节点的右子树，那么它中序遍历的下一个节点是当前所在左子树的根节点。</li></ol></li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeLinkNode *left;</span><br><span class="line">    struct TreeLinkNode *right;</span><br><span class="line">    struct TreeLinkNode *next;</span><br><span class="line">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeLinkNode* res;</span><br><span class="line">        // 当前节点存在右子树</span><br><span class="line">        if(pNode &amp;&amp; pNode-&gt;right)&#123;</span><br><span class="line">            TreeLinkNode* temp = pNode-&gt;right;</span><br><span class="line">            while(temp-&gt;left)&#123;</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = temp;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">         // 当前节点不存在右子树，</span><br><span class="line">           TreeLinkNode* par = pNode-&gt;next;</span><br><span class="line">           while(pNode-&gt;next &amp;&amp; par-&gt;right == pNode)&#123;</span><br><span class="line">               pNode = pNode-&gt;next;</span><br><span class="line">               par  = pNode-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           res = par;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十四篇。&lt;br&gt;主要知识点为二叉树，查找二叉树中序遍历给定节点的下一个节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-删除链表中重复的结点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-删除链表中重复的结点/</id>
    <published>2020-01-26T09:12:58.000Z</published>
    <updated>2020-02-04T13:15:17.074Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十三篇。<br>主要知识点为链表的遍历，去除重复元素。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>将整个链表进行遍历，通过map来保存每个节点出现的次数。之后再重建链表，链表结点的值仅仅对应于出现一次的元素。返回新链表即可。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>可以直接在原来的链表上进行操作，具体的思路如下：<br>首先在头节点之前建立一个帮助结点，帮助结点之后的就是我们真正的没有重复结点的链表。<br>然后我们从head结点开始向后遍历，如果碰到有相同元素，那么一直向后遍历，越过这些重复元素。如果元素值没有重复，那么就都向后遍历一个节点。直到遍历结束。</p><p>下面以1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5为例进行详细说明，<br>我们开始创建辅助节点将原来的链表变成-1-&gt;1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5,<br>然后有两个指针一个指针p指向之前的头节点1，一个指针last指向辅助节点-1，开始遍历。提醒一下，他们两个操作的可是同一个链表。</p><ol><li>1!=2,所以1不重复，所以p前移指向2，last前移指向1；</li><li>2!=3,所以2不重复，所以p前移指向3，last前移指向2；</li><li>3==3，所以3是重复的，这个时候p继续前移，直到指向第一个不是3的节点，也就是4，last的next指向4.（这样的话所有的3就已经被删除了）</li><li>4==4，所以4也是重复的，这个时候p继续前移，直到指向第一个不是4的节点，也就是5，last的next指向5，(这样的话所有的4就已经被删除了)</li><li>5已经没有后继节点了，所有结束。</li></ol><p>然后整个的链表就变成了-1-&gt;1-&gt;2-&gt;5,最后结果返回-1的next即可。<br>相比于前一种思路可以极大的提高空间同时提升效率。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>本题目的目标是1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5变成1-&gt;2-&gt;5，题目等同于<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">leetcode-83-RemoveDuplicatesfromSortedListII</a><br>但是也有类似的题目是从1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5变成1-&gt;2-&gt;3-&gt;4-&gt;5。比如<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">leetcode-82-RemoveDuplicatesfromSortedList</a></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* first = new ListNode(-1);</span><br><span class="line">        first-&gt;next = head;</span><br><span class="line">        ListNode* last = first;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">           if(p-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">               //如果有重复元素，那么就跳过。</span><br><span class="line">               int val = p-&gt;val;</span><br><span class="line">               while(p &amp;&amp; p-&gt;val == val)&#123;</span><br><span class="line">                   p = p-&gt;next;</span><br><span class="line">               &#125;   </span><br><span class="line">               //此时p指向不是之前相等值的第一个元素，但是不能保证这个值也不重复，</span><br><span class="line">               //所以此时继续进入到循环之中进行判断。</span><br><span class="line">               //通过last-&gt;next = p 删除了中间值为val的所有值。</span><br><span class="line">               last-&gt;next = p;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               // 如果不重复，那就直接链接到last上。p继续后移</span><br><span class="line">               last= p;</span><br><span class="line">               p = p-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        return first-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)<br>还可以这样写，速度会比上面的写法要快一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!pHead) return NULL;</span><br><span class="line">        ListNode* p = pHead;</span><br><span class="line">        ListNode* first = new ListNode(-1);</span><br><span class="line">        first-&gt;next = pHead;</span><br><span class="line">        ListNode* tail = first;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            if((p-&gt;next &amp;&amp; p-&gt;val != p-&gt;next-&gt;val) || !p-&gt;next)&#123;</span><br><span class="line">                tail = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                int a  = p-&gt;val;</span><br><span class="line">                while(p &amp;&amp; p-&gt;val == a)&#123;</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;next = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="扩展代码"><a href="#扩展代码" class="headerlink" title="扩展代码"></a>扩展代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        // 去掉重复元素,重复元素保留一次</span><br><span class="line">        if(!head) return NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">            if(p-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十三篇。&lt;br&gt;主要知识点为链表的遍历，去除重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-链表中环的入口节点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-链表中环的入口节点/</id>
    <published>2020-01-26T06:32:54.000Z</published>
    <updated>2020-01-26T09:11:24.060Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十二篇。<br>主要知识点为链表的遍历，同样的使用一个set就可以解决问题。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路非常清晰，从头开始遍历，遍历的时候先判断当前节点是否在set中，如果已经在，那么这个节点肯定就是那个入口节点。如果不在，继续向后遍历。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;ListNode*&gt; mset;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            if(mset.count(p)) return p;</span><br><span class="line">            mset.insert(p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十二篇。&lt;br&gt;主要知识点为链表的遍历，同样的使用一个set就可以解决问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
