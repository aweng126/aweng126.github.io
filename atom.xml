<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingwen&#39;s blog</title>
  
  <subtitle>没有输出的输入是不完整的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-15T02:20:24.694Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李庆文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>curl命令下载资源速度缓慢解决方案</title>
    <link href="http://yoursite.com/2020/12/15/curl%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90%E9%80%9F%E5%BA%A6%E7%BC%93%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2020/12/15/curl命令下载资源速度缓慢解决方案/</id>
    <published>2020-12-15T01:43:47.000Z</published>
    <updated>2020-12-15T02:20:24.694Z</updated>
    
    <content type="html"><![CDATA[<p>在服务器下载资源往往会通过curl或者wget命令，但是有时部分资源会因为网络问题下载缓慢甚至直接下载失败。<br>本文提出三种解决方案来解决这个问题。</p><a id="more"></a><h2 id="修改hosts文件解决DNS污染问题">修改hosts文件解决DNS污染问题</h2><p>类似于githubusercontent.com等网站会因为dns解析失败而不能访问成功。此时我们可以通过修改hosts文件来解决这个问题。</p><ol><li>打开网站<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">ipaddress</a>，输入不能访问的资源的地址，获取对应地址的ip地址。比如我们输入raw.githubusercontent.com网站<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20201215095532.png" alt=""><br><img src="https://cdn.kingwen.cn/qiniu_kwimg20201215095655.png" alt=""><br>可以看到对应的ip地址为199.232.96.133</li></ol><p>此时，我们修改/etc/hosts文件，在文件的最后添加如下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">199.232.96.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><p>从而事情就可以得到解决。</p><p>为方便大家使用，github的<a href="https://github.com/hawtim/blog/issues/10" target="_blank" rel="noopener">解决curl connection refused问题</a>的issue已经为我们总结了常见的几个更改的网址，我一并放在此处供大家使用，直接拷贝并追加到/etc/hosts文件中即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">199.232.68.133 raw.githubusercontent.com</span><br><span class="line">199.232.68.133 user-images.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars2.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure><h2 id="下载源码自行编译">下载源码自行编译</h2><p>有些package会提供多种方式供大家下载使用，比如yum安装、apt-get安装、brew安装，curl下载后sh安装。<br>除此之外，其实还有一种常见的安装方式就是项目会提供源代码，然后用户下载后自行通过make命令进行编译，之后再将对应的二进制执行程序复制到/usr/local/bin目录下。</p><h2 id="其他主机拷贝">其他主机拷贝</h2><p>可以通过scp命令将其他主机已经安装好的二进制文件复制到本机。相关scp的使用说明可以参见文章<a href="https://www.runoob.com/linux/linux-comm-scp.html" target="_blank" rel="noopener">Linux scp命令</a></p><p>我暂时知道的解决方式就上面三种，如果以后有其他方式可以再补充吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在服务器下载资源往往会通过curl或者wget命令，但是有时部分资源会因为网络问题下载缓慢甚至直接下载失败。&lt;br&gt;
本文提出三种解决方案来解决这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="curl" scheme="http://yoursite.com/tags/curl/"/>
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>cron表达式学习</title>
    <link href="http://yoursite.com/2020/12/09/learn-cron-expression/"/>
    <id>http://yoursite.com/2020/12/09/learn-cron-expression/</id>
    <published>2020-12-09T02:10:34.000Z</published>
    <updated>2020-12-09T02:22:49.879Z</updated>
    
    <content type="html"><![CDATA[<p>Cron语法经常用于定时任务的设定，如定时进行数据采集任务，定时进行数据备份任务等。<br>本文对cron表达式进行了简单介绍。</p><a id="more"></a><h2 id="语法说明">语法说明</h2><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201208212253.png" alt=""></p><ol><li>每个cron指令一般包含5个部分，分别对应分钟、小时、天、月、周。 每个部分用空格隔开。</li><li>每个部分的通用标志。</li></ol><ul><li>* : 表示任意值</li><li>, ：表示值的列表</li><li>- ：表示值的范围</li><li>/ ：表示值的步长</li></ul><ol start="3"><li>每个值的取值范围</li></ol><ul><li>分钟： 0 - 59</li><li>小时：0 - 23</li><li>天：1 - 31</li><li>月：1 - 12</li><li>周：0 - 6</li></ul><h2 id="举例说明">举例说明</h2><ol><li>每隔十分钟执行一次</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/10 * * * *</span><br></pre></td></tr></table></figure><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201208231301.png" alt=""><br>2. 双月中每周一周二的前两个小时每隔5分钟执行一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/5 0-2 * */2 1,2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201208231642.png" alt=""></p><h2 id="后续更新">后续更新</h2><p>本部分参考盖若博主的文章，属于cron语法使用的升级版。</p><ol><li>如果cron表达式中有6个值，则第一个表示秒。</li><li>如果cron表示式中有7个值，则最后一个表示年。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20201209100616.png" alt=""><br><img src="https://cdn.kingwen.cn/qiniu_kwimg20201209100647.png" alt=""></li></ol><h2 id="参考链接">参考链接</h2><ol><li><a href="https://crontab.guru/#*_*_*_*_*" target="_blank" rel="noopener">在线解析crontab guru</a></li><li><a href="https://www.gairuo.com/p/cron-expression-sheet" target="_blank" rel="noopener">盖若-Cron 定时任务表达式手册</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cron语法经常用于定时任务的设定，如定时进行数据采集任务，定时进行数据备份任务等。&lt;br&gt;
本文对cron表达式进行了简单介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="cron" scheme="http://yoursite.com/tags/cron/"/>
    
      <category term="自动化" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>jupyter设置多编程语言支持</title>
    <link href="http://yoursite.com/2020/10/17/jupyter%E8%AE%BE%E7%BD%AE%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/"/>
    <id>http://yoursite.com/2020/10/17/jupyter设置多编程语言支持/</id>
    <published>2020-10-17T12:28:47.000Z</published>
    <updated>2020-10-17T12:39:14.290Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要介绍如何设置jupyter notebook使其在支持python的基础上支持octave和R语言。</p><a id="more"></a><p><a href="https://github.com/jupyter/notebook" target="_blank" rel="noopener">jupyter notebook</a>是目前应用非常广泛的一个软件。它最大的亮点在于让用户可以即时编码，即时测试，即时调整，而且支持超过40种编程语言，详情可参考<a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="noopener">jupyter-kernels-list</a>。</p><h2 id="设置多编程语言支持">设置多编程语言支持</h2><h3 id="octave支持">octave支持</h3><ol><li>首先本地要安装octave, mac用户可以直接通过如下命令安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install octave</span><br></pre></td></tr></table></figure><p>其他系统可以自行参考<a href="https://www.gnu.org/software/octave/download" target="_blank" rel="noopener">octave安装教程</a><br>2. 安装jupyter和octave进行交互的octave_kernel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install octave_kernel</span><br></pre></td></tr></table></figure><p>更多细节可以参考<a href="https://github.com/Calysto/octave_kernel/blob/master/README.rst" target="_blank" rel="noopener">octave_kernel-Github</a></p><h3 id="R语言支持">R语言支持</h3><ol><li>本地安装R语言环境</li></ol><p>下载连接 <a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/" target="_blank" rel="noopener">tsinghua-cran-download</a></p><p>R语言官网<a href="https://www.r-project.org/" target="_blank" rel="noopener">R-project</a></p><ol start="2"><li>配置R语言kernel</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 进入R语言console</span><br><span class="line">R</span><br><span class="line"># 安装kernel</span><br><span class="line">install.packages(&apos;IRkernel&apos;)</span><br><span class="line">选择合适的源即可。</span><br><span class="line"># 为系统所有用户安装</span><br><span class="line">IRkernel::installspec(user = FALSE)</span><br></pre></td></tr></table></figure><h3 id="查看jupyter的内核支持">查看jupyter的内核支持</h3><ol><li>通过命令行查看</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter kernelspec list</span><br></pre></td></tr></table></figure><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016145435.png" alt=""></p><p>2.通过打开notebook新建文件来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016145812.png" alt=""></p><h2 id="bug记录">bug记录</h2><ol><li>configurations are cuurently only defined for the following language:</li></ol><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016114704.png" alt=""></p><ul><li>问题描述</li></ul><p>这个问题出现在我为本地jupyter新添加了R语言和octave语言的kernel.但是当我新建一个对应的文件的时候，就报错上面的错误。</p><ul><li>解决措施</li></ul><p>问题出现在autopep8插件上，这个插件仅仅支持python，所以在使用其他语言的时候就会报错，所以当我们在编写其他语言相关的文件时候，我们将这个插件关掉即可。</p><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016113535.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要介绍如何设置jupyter notebook使其在支持python的基础上支持octave和R语言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具推荐" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="jupyter" scheme="http://yoursite.com/tags/jupyter/"/>
    
      <category term="octave" scheme="http://yoursite.com/tags/octave/"/>
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>七牛云+PicGo制作博客图床</title>
    <link href="http://yoursite.com/2020/09/11/%E4%B8%83%E7%89%9B%E4%BA%91-PicGo%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/"/>
    <id>http://yoursite.com/2020/09/11/七牛云-PicGo制作博客图床/</id>
    <published>2020-09-11T11:54:19.000Z</published>
    <updated>2020-09-11T13:06:19.670Z</updated>
    
    <content type="html"><![CDATA[<p>用七牛云和PicGo给博客的图片安了一个家，七牛云真香！</p><a id="more"></a><p>对于所有写博客的同学来说，图床是一个必须要考虑的事情，最好图床可以稳定、便宜还要好用。</p><p>我从写博客以来，用过微博的图床(后来外链关闭了)，用过github搭建过图床（访问速度堪忧），用过简书做图床(平台现在越做越差)，后来就直接用有道云笔记了（但是只能自己看），一路走来，充满坎坷。</p><p>最近刚好有点时间，我就把自己的域名和服务器重新认证了一下，准备以后好好做点东西，所以图床的事情也必须要搞一下，于是本篇文章应运而生！</p><h2 id="前期准备">前期准备</h2><ol><li><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGO</a>：到releases下载最新版本的符合自己电脑的安装包，下载即可。注意下载的是稳定版本还是试用版本，带有beta的都是试用版本。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911200650.png" alt=""></li><li><a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a>对象存储：在七牛云新建存储空间，用来保存图片即可。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911201552.png" alt=""></li><li>实名认证后的域名。可以通过腾讯云或者阿里云进行域名购买，然后记得要到工信部认证。否则是不能对外提供服务的。</li></ol><h2 id="具体步骤">具体步骤</h2><h3 id="1-设置七牛云存储">1.设置七牛云存储</h3><ol><li>对象存储-&gt;空间管理-&gt;新建空间<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911201447.png" alt=""></li></ol><ul><li>存储空间名称：名称自定义即可。要注意长度</li><li>存储区域：自己选一个离自己比较近的区域即可。</li><li>访问控制：要设置为公开</li></ul><ol start="2"><li>设置自己的存储空间<br>刷新列表就可以看到自己刚刚新建的存储空间。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911201842.png" alt=""><br>这里其实最需要干的是要绑定自己的域名，七牛云仅仅提供了一个测试域名，只能有一个月的使用时间，之后便不能访问了。所以需要干的是选择设置，绑定自己的域名。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911202412.png" alt=""><br>具体绑定域名方法七牛云有详细的说明文档，以及https和cdn的绑定，按照说明指导就行。</li></ol><h3 id="2-设置PicGo">2. 设置PicGo</h3><ol><li>右键图标查看详情打开picGO设置面板，左侧图床设置选择七牛图床<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203034.png" alt=""></li></ol><ul><li>AccessKey和SecretKey：七牛云页面右上角个人中心的密钥管理里面可以设置<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203301.png" alt=""></li><li>存储空间名称：就是我们前面的存储空间的名称。注意我这里用的是我实际图床使用的名字kwimg，但是我前面演示的是dh-img，那个仅仅是演示。大家在设置的时候此处要和前面创建的保持一致。</li><li>设定访问网址：<br>如果是没有实际绑定自己的域名的话，可以在空间概览中查看。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203700.png" alt=""><br>如果是自己已经绑定好域名的话，是下面这个样子的。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203838.png" alt=""><br>还有需要注意的一点是需要自己在网址的前面加上(<strong>http:// 或者 https://</strong>)。</li><li>确认存储区域<br>这里和我们之前申请存储空间的时候选择的区域是相关的。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911204251.png" alt=""></li><li>设定网址后缀： 这个暂时不用设置</li><li>制定存储区域： 自己随便设置，仅仅是图片的url路径多点东西而已不重要。</li></ul><ol start="2"><li>设置快捷键<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911204718.png" alt=""></li><li>设置开机自启<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911204812.png" alt=""></li><li>接下来就可以非常开心的将图片提交到七牛云存储啦。</li></ol><ul><li>当我们截图之后直接通过快捷键上传图片，图片上传成功之后对应的markdown地址会在本地的粘贴板。直接在对应的markdown文件中ctrl+v就行啦。</li><li>如果想看之前提交过图片，可以左键点击图标查看；也可以右键查看详情，然后查看对应的相册，点击图片下面的三个按钮最左面一个就可以复制本张图片的markdown地址；中间一个可以修改url地址；最右面一个可以将本张图片在相册中删掉，但是七牛云存储中依然存在。<br><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911205205.png" alt=""></li></ul><h2 id="关于价格">关于价格</h2><p><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911205849.png" alt=""><br>如果仅仅是个人博客，而且访问量没有那么大的话，基本上就是免费的，七牛云真棒！！</p><p>ok,剩下的就是安心写博客啦,gogogo!</p><h2 id="参考文档">参考文档</h2><ol><li><a href="https://picgo.github.io/PicGo-Doc/zh/guide/" target="_blank" rel="noopener">PicGo-Guide文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用七牛云和PicGo给博客的图片安了一个家，七牛云真香！&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="PicGo" scheme="http://yoursite.com/tags/PicGo/"/>
    
      <category term="七牛云" scheme="http://yoursite.com/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
      <category term="图床" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>爬虫项目阶段性总结</title>
    <link href="http://yoursite.com/2020/07/18/data-scientist-grow-up/"/>
    <id>http://yoursite.com/2020/07/18/data-scientist-grow-up/</id>
    <published>2020-07-18T09:09:05.000Z</published>
    <updated>2020-07-18T09:29:51.835Z</updated>
    
    <content type="html"><![CDATA[<p>我对于爬虫项目的阶段性总结。<br>包含做项目时的流程、每个流程相关技术概述以及自己的学习经验。<br>方便自己后期查阅，也希望能给别人一点点指引。</p><a id="more"></a><h2 id="【前言】">【前言】</h2><ol><li>本学习计划仅作为参考，具体学习路线根据自己的实际情况酌情调整。</li><li>本学习路线图侧重数据工程师或者数据科学家路线，包括数据爬虫，清洗，存储，分析，展示等一系列流程。</li><li>本文档主要是给大黄写的，大黄写代码要加油啊！</li></ol><h2 id="完整的项目流程">完整的项目流程</h2><ol><li>确定项目内容：可以选择自己感兴趣的内容或者根据工作任务确定。</li><li>确定项目最终效果：根据目标效果反推出需要的数据。</li><li>确定数据源：根据想要的数据确定一个或者多个数据源</li><li>确定技术方案：分析数据源，确定需要的技术方案以及技术可行性。</li><li>开始动手！按照技术方案将数据进行采集，并最终实现预期的项目效果。</li></ol><h2 id="项目详细技术">项目详细技术</h2><h3 id="网页数据获取">网页数据获取</h3><p>本部分工作主要是用爬虫程序模拟浏览器访问对应的网站来获取网页html数据。</p><ol><li>发送请求获取网页数据。以python为例，可以通过类似于<a href="https://requests.readthedocs.io/en/master/" target="_blank" rel="noopener">requests</a>、urllib等package发送请求。</li><li>在正式编写代码前，要首先通过F12开发者选项（chrome浏览器）分析请求内容。或者直接通过网站页面右键-&gt;检查-&gt;network面板进行查看。</li></ol><ul><li>分析请求的url，查看是否存在跳转，是否需要登陆，如果需要登陆则考虑模拟登陆或者保存cookie或者使用cookie池。</li><li>查看能否直接请求对应的api获取目标数据,如果不能,再考虑请求网页原始数据再将目标数据解析出来。</li><li>对于模拟登陆，可以通过输入一个错误的用户名和密码来获得真正的url请求情况，否则可能因为成功跳转而看不到相关内容；</li></ul><ol start="3"><li>注意各种反爬虫措施的处理，包括伪造请求头、设置请求间隔时间、设置ip代理,携带cookie信息等等</li></ol><h3 id="网页解析">网页解析</h3><p>本部分工作是将网页对应的html页面内容进行解析。重点是灵活使用各种解析库，将想要的数据提取出来。<br>其中解析库主要包括<a href="https://www.runoob.com/xpath/xpath-syntax.html" target="_blank" rel="noopener">xpath</a>,<a href="https://www.crummy.com/software/BeautifulSoup/doc" target="_blank" rel="noopener">bs4</a>，<a href="https://pythonhosted.org/pyquery/" target="_blank" rel="noopener">pyquery</a>等，还可以结合正则表达式、字符串操作等多种方式对网页内容进行解析。</p><h3 id="数据处理">数据处理</h3><p>网页解析出来的内容数据可能存在数据缺失、数据格式不一致等问题。所以需要进行数据处理操作。</p><ul><li>数据缺失问题：删除整条数据、填充特殊值、填充中位数、填充众数、数据拟合等</li><li>数据格式不一致问题：确定数据统一格式，包括单位、格式等</li></ul><h3 id="数据存储">数据存储</h3><p>将处理好的数据进行数据存储，方便后期使用。</p><ul><li>关系型数据库：mysql、oracle等</li><li>文档型数据库：mongodb</li><li>图数据库：neo4j</li><li>内存数据库： redis<br>个人比较倾向于爬虫处理后的结果暂时放到mongdb中，原因就是方便读写。等数据处理结束之后可以根据数据类型以及对外服务的类型决定放到图数据库或者关系型数据库。</li></ul><h3 id="数据分析">数据分析</h3><p>根据预期的项目效果对已经爬取的数据进行数据分析。</p><ul><li>按照不同类别进行划分，比如不同的地域，不同季节，不同人群等。</li><li>按照时间线进行分析，比如平均身高，平均薪酬等。</li><li>按照其他统计学的知识对数据进行处理并分析。</li></ul><h3 id="数据展示">数据展示</h3><p>数据分析的结果要通过合适的方式进行展示。</p><ul><li>ppt、word等办公软件。考虑内嵌图表或者截图插入</li><li>个人网站、个人博客等。考虑使用<a href="https://echarts.apache.org/examples/zh/index.html" target="_blank" rel="noopener">echarts.js</a>或者<a href="https://observablehq.com/@d3/gallery" target="_blank" rel="noopener">d3.js</a>等图表库，效果非常好。</li></ul><h3 id="结论">结论</h3><p>我们研究或者调研的内容告诉我们什么内容，说明了什么道理，给我们什么启示，这个也应该作为我们整个项目的一部分进行说明。</p><h2 id="技术进一步提升">技术进一步提升</h2><p>上面介绍的技术仅仅适应于数据量较小的常规数据采集路线。下面说一下其中可以进行扩展和提升的部分。</p><h3 id="爬虫框架的使用">爬虫框架的使用</h3><p>数据采集是一个比较常见的需求，所以程序员们开发出了很多方便扩展的爬虫框架，比如<a href="https://docs.scrapy.org/en/latest/intro/tutorial.html" target="_blank" rel="noopener">scrapy</a>、<a href="http://docs.pyspider.org/en/latest/" target="_blank" rel="noopener">pyspider</a>、<a href="https://scrapy-redis.readthedocs.io/en/stable/" target="_blank" rel="noopener">scrapy-redis</a>、<a href="https://scrapy-cluster.readthedocs.io/en/latest/topics/introduction/overview.html" target="_blank" rel="noopener">scrapy-cluster</a>等，可以让我们将重点放在处理核心业务上。</p><h3 id="docker的使用">docker的使用</h3><p>docker可以认为是一个轻量的虚拟机，通过镜像来创建实例，每个实例彼此隔离彼此独立，从而可以让程序员摆脱编程开发测试部署环境不一致的问题，同时方便进行横向扩展。在我们项目构造出对应的镜像之后，便会由镜像在手，天下我有的豪气。<br>在使用新的组件之前，可以先去<a href="https://hub.docker.com/" target="_blank" rel="noopener">dockerhub</a>看看，之后尽量所有的项目要通过docker进行部署，用dockerfile来进行定义。让项目组件化，这样就可以解耦合，从而方便扩展和升级。</p><p>爬虫过程的每一个步骤都可以单独拿出来交给对应的docker镜像来处理。看自己最后的需求进行不同粒度的分解。</p><h3 id="大数据组件">大数据组件</h3><p>在数据清洗、数据分析的时候如果数据量太大，可以和大数据平台进行对接，包括hadoop、mapreduce等，然后将对应的结果保存起来供进一步使用。</p><p>大数据平台的东西由很多，而且环境部署比较麻烦，所以本部分强烈建议使用docker进行部署，然后在部署的时候要注意不同实例之间的通信。</p><h3 id="分布式爬虫部署">分布式爬虫部署</h3><p>当数据量太大，单机爬虫的速率就远远不能满足我们的需求，这个时候就可以考虑使用分布式爬虫，将很多台主机一起来爬取想要的数据，上面说的爬虫框架sacrpy就是单机版本的，scrapy-redis就是在scrapy的基础上添加redis用来做爬取队列，可以作为分布式爬虫使用，scrapy-cluster是在scrapy-redis的基础上添加大数据组件kafka从而与大数据平台对接，也属于分布式爬虫。scrapyd可以用来方便的部署分布式爬虫程序。<a href="https://docs.gerapy.com/en/latest/" target="_blank" rel="noopener">Gerapy</a>也值得关注。</p><h3 id="APP内容的爬取">APP内容的爬取</h3><p>本部分我没有做过，但是我知道有很多库，包括Charles、mitmproxy、Appium等，可以对手机app进行抓包，从而采集到想要的数据。</p><h2 id="学习经验">学习经验</h2><ol><li>要以项目为主导，no bb，show your code！！</li><li>善于使用搜索引擎google、bing</li><li>学会使用<a href="https://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a>查找bug</li><li>尽量通过官方文档学习新的技术</li><li>合理使用github这个宝库</li><li>找一本好的参考资料比如<a href="https://item.jd.com/12333540.html" target="_blank" rel="noopener">Python 3网络爬虫开发实战</a>以及网站<a href="https://cuiqingcai.com/" target="_blank" rel="noopener">静觅-崔庆才</a></li></ol><p>最后，开始动手吧！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我对于爬虫项目的阶段性总结。&lt;br&gt;
包含做项目时的流程、每个流程相关技术概述以及自己的学习经验。&lt;br&gt;
方便自己后期查阅，也希望能给别人一点点指引。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="spider" scheme="http://yoursite.com/tags/spider/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Docker-容器内安装vim编辑器</title>
    <link href="http://yoursite.com/2020/06/15/docker-4-install-vim-in-container/"/>
    <id>http://yoursite.com/2020/06/15/docker-4-install-vim-in-container/</id>
    <published>2020-06-15T07:40:03.000Z</published>
    <updated>2020-06-15T08:01:47.410Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章将会介绍在container中安装vim编辑器。<br>需要注意在正式开发时要通过dockerfile来进行所有环境的设置。</p><a id="more"></a><p>在有些容器中使用vim命令的时候，会提示如下错误。</p><blockquote><p>vim: command not found</p></blockquote><p>说明容器中没有安装vim.<br>我们可以通过如下命令进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure><p>如果安装的时候报错，报错信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package vim</span><br></pre></td></tr></table></figure><p>可以通过如下命令来解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章将会介绍在container中安装vim编辑器。&lt;br&gt;
需要注意在正式开发时要通过dockerfile来进行所有环境的设置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Docker提升-实现原理</title>
    <link href="http://yoursite.com/2020/06/15/docker-3-principle/"/>
    <id>http://yoursite.com/2020/06/15/docker-3-principle/</id>
    <published>2020-06-15T07:05:44.000Z</published>
    <updated>2020-06-15T07:16:39.901Z</updated>
    
    <content type="html"><![CDATA[<p>docker镜像是一个特殊的文件系统。<br>本篇文章将介绍如何docker镜像的层级结构，同时学习如何查看中间层镜像。</p><a id="more"></a><h2 id="docker的原理">docker的原理</h2><p>Docker 的镜像就是它的文件系统，一个镜像可以放在另外一个镜像的上层，那么位于下层的就是它的父镜像。所以，Docker 会存在很多镜像层，每个镜像层都是只读的，并且不会改变。当我们创建一个新的容器时，Docker 会构建出一个镜像栈，并在栈的最顶层添加一个读写层，如图所示。<br><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdbf9e98a71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>其中中间的这些镜像层就是intermediate image，是不能被删除的。</p><h2 id="如何查看中间层镜像">如何查看中间层镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查看镜像</span><br><span class="line">docker image ls</span><br><span class="line">//查看所有镜像（包含中间层镜像）</span><br><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure><p>带参数a选项的命令输出的结果中含有none:none标签的镜像都是intermediate image(中间层镜像)，这些镜像会被其他镜像所使用，是不能被随意删除的。</p><h2 id="none-none-标签镜像">none:none 标签镜像</h2><p>具有none:none 标签的景象都是intermediate image吗？ 其实不是，还有一类镜像是dangling image（悬虚镜像），通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>命令展示出来的镜像也会包含none:none标签的镜像，这就是dangling image.</p><p>那么dangling image是如何产生的呢？<br>比如我们最开始通过如下命令构造一个名称为test:v1的镜像，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t test:v1 .</span><br></pre></td></tr></table></figure><p>然后我们后期对代码进行了修改，所以我们会重新构造一个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t test:v1 .</span><br></pre></td></tr></table></figure><p>我们没有为它分配新的名字，新构造的镜像还是叫做test:v1。这个时候原来的test:v1就会成为dangling image，根本没用，而且会占用存储空间。</p><p>可以通过如下命令将所有的玄虚镜像删掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h2 id="写在最后">写在最后</h2><p>记得多关注一下docker的help文档,以查看镜像命令为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  log docker image ls --help</span><br><span class="line"></span><br><span class="line">Usage:  docker image ls [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">List images</span><br><span class="line"></span><br><span class="line">Aliases:</span><br><span class="line">  ls, images, list</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">      --digests         Show digests</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print images using a Go template</span><br><span class="line">      --no-trunc        Don&apos;t truncate output</span><br><span class="line">  -q, --quiet           Only show numeric IDs</span><br></pre></td></tr></table></figure><p>可以看到-a选项后面说，默认是隐藏intermediate images的。所以我们就可以了解到存在intermediate images 而且还可以通过在原命令的后面加参数a来查看中间层镜像。</p><p>更细节的原理可以查看这篇文章<a href="https://www.projectatomic.io/blog/2015/07/what-are-docker-none-none-images/" target="_blank" rel="noopener">What are Docker <none>:<none> images?</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker镜像是一个特殊的文件系统。&lt;br&gt;
本篇文章将介绍如何docker镜像的层级结构，同时学习如何查看中间层镜像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="principle" scheme="http://yoursite.com/tags/principle/"/>
    
  </entry>
  
  <entry>
    <title>Docker进阶-Dockerfile的编写和使用</title>
    <link href="http://yoursite.com/2020/06/15/docker-2-dockerfile/"/>
    <id>http://yoursite.com/2020/06/15/docker-2-dockerfile/</id>
    <published>2020-06-15T06:55:13.000Z</published>
    <updated>2020-06-15T08:02:45.217Z</updated>
    
    <content type="html"><![CDATA[<p>在实际开发中完全使用他人构造好的镜像是不现实的。<br>所以本篇文章我们将会学习Dockerfile的知识，从而学习如何构造符合项目要求的镜像。</p><a id="more"></a><h2 id="Dockerfile文档展示">Dockerfile文档展示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">RUN apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y python3-pip python3-dev</span><br><span class="line"></span><br><span class="line"># We copy just the requirements.txt first to leverage Docker cache</span><br><span class="line">COPY ./requirements.txt /app/requirements.txt</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">RUN python3 -m pip install --upgrade pip</span><br><span class="line">RUN pip3 install -r requirements.txt</span><br><span class="line"></span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"># ENTRYPOINT [ &quot;python3&quot; ]</span><br><span class="line"></span><br><span class="line">CMD [ &quot;python3&quot;, &quot;main.py&quot; ]</span><br></pre></td></tr></table></figure><h2 id="逐行命令解释">逐行命令解释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1. FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">FROM 关键字会初始化一个image构造，并为后续的所有操作设置基础镜像，，上面的例子表示，该image是以ubuntu:16.04为基础构建的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. RUN apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y python3-pip python3-dev</span><br><span class="line"></span><br><span class="line">RUN 会在上一层的基础上添加新的layer,并将结果提交给下一层。RUN命令有两种形式。一种是shell格式，格式如下</span><br><span class="line">RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)</span><br><span class="line"></span><br><span class="line">另一种是exec格式，格式如下</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)</span><br><span class="line"></span><br><span class="line">&amp;&amp; \ 并不是Docker独有的，只是告诉linux这两条命令要一起执行，而不是执行两次，这样就只会产生一层layer,如果有两个RUN，那么就会产生两个中间层。 </span><br><span class="line"></span><br><span class="line">3. COPY ./requirements.txt /app/requirements.txt</span><br><span class="line">COPY 命令同样有两种形式，可以实现将源文件复制到目标位置，支持正则表达式。</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br><span class="line"></span><br><span class="line">4. WORKDIR /app</span><br><span class="line">- WORKDIR 会设置当前的工作目录，在本条指令之后的RUN, CMD, ENTRYPOINT, COPY 和 ADD目录都是在当前目录下执行的。</span><br><span class="line">- WORKDIR 可以出现多次，从而更换shell的执行路径</span><br><span class="line"></span><br><span class="line">5. RUN python3 -m pip install --upgrade pip</span><br><span class="line">6. RUN pip3 install -r requirements.txt</span><br><span class="line">RUN命令的shell形式，更新pip同时安装依赖。</span><br><span class="line"></span><br><span class="line">7. COPY . /app</span><br><span class="line">复制命令 将当前目录的所有文件复制到/app目录下</span><br><span class="line"></span><br><span class="line">8.CMD [ &quot;python3&quot;, &quot;main.py&quot; ]</span><br><span class="line">CMD的作用是提供容器的默认指令，也就是我们docker run 的最后一个参数。CMD有三种形式，在一个Dockerfile中，如果有多个CMD指令，那么只有最后一个CMD命令会起作用。</span><br><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)</span><br><span class="line">CMD command param1 param2 (shell form)</span><br><span class="line"></span><br><span class="line">如果CMD命令后只有参数，没有可执行的命令，那么它肯定是配合ENTRYPOINT使用的。同时要注意，如果是配合ENTRYPOINT的时候，CMD和ENTRYPOINT都要使用使用 JSON array 格式。如果用ENTRYPOINT进行改写，则如下所示。</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ &quot;python&quot; ]</span><br><span class="line">CMD [ &quot;main.py&quot; ]</span><br></pre></td></tr></table></figure><h2 id="打包镜像">打包镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t kuakua:latest .</span><br><span class="line"> -t 设置镜像名称和标签，如果标签没有设定，默认是latest</span><br><span class="line"> .  在当前目录寻找Dockerfile进行镜像打包。</span><br></pre></td></tr></table></figure><h2 id="运行容器">运行容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> docker run -d -p 5001:5000 --name kuakua -v /Users/liqingwen/workplace/temp/kuakua/log:/log kuakua:latest</span><br><span class="line"></span><br><span class="line">// 详细解释</span><br><span class="line">-d  表示以守护进程的形式进行执行，后台运行</span><br><span class="line">-p 5001:5000 将容器的5000端口映射到宿主机的5001端口</span><br><span class="line">--name kuakua 将当前容器命名为kuakua</span><br><span class="line">-v bind mount a volumn 将容器的log目录和本地的/Users/liqingwen/workplace/temp/kuakua/log做一个映射。如果容器端log目录下有内容更新，则本地的log目录也会同步更新。</span><br><span class="line">kuakua:latest 镜像名称</span><br></pre></td></tr></table></figure><h2 id="项目地址">项目地址</h2><p>本项目完整代码已经在github开源，项目地址<a href="https://github.com/aweng126/TestProject/tree/master/kuakua" target="_blank" rel="noopener">夸夸机器人</a>,欢迎大家去尝试一下。</p><h2 id="参考">参考</h2><ol><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">dockerfile 官方参考文档</a></li><li><a href="https://runnable.com/docker/python/dockerize-your-flask-application" target="_blank" rel="noopener">Dockerize your Flask Application</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际开发中完全使用他人构造好的镜像是不现实的。&lt;br&gt;
所以本篇文章我们将会学习Dockerfile的知识，从而学习如何构造符合项目要求的镜像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="dockerfile" scheme="http://yoursite.com/tags/dockerfile/"/>
    
  </entry>
  
  <entry>
    <title>Docker初探-认识并使用docker</title>
    <link href="http://yoursite.com/2020/06/15/docker-fundamentals/"/>
    <id>http://yoursite.com/2020/06/15/docker-fundamentals/</id>
    <published>2020-06-15T03:14:10.000Z</published>
    <updated>2020-06-15T06:45:56.831Z</updated>
    
    <content type="html"><![CDATA[<p>docker是目前最流行的虚拟化技术。<br>本篇文章主要介绍docker的基本概念以及初步尝试使用docker技术。</p><a id="more"></a><h2 id="docker是什么">docker是什么</h2><p>Docker 属于 Linux容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p><p>Docker将应用程序与该程序的依赖，打包在一个文件里面。只要运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。</p><h2 id="docker好在哪">docker好在哪</h2><ol><li>更高效的利用系统资源</li><li>更快速的启动时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>容易迁移、维护和扩展</li></ol><h2 id="docker专有名词">docker专有名词</h2><ol><li>镜像，image, 包括各种环境的定义和说明。</li><li>容器，container, 是一个镜像的运行实体，不同容器之间是相互隔离的。</li><li>仓库，镜像的仓库，用于用户发布自己的镜像或者查找自己需要的镜像，目前最大的公开仓库为<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker hub</a>,一个项目star越多，说明项目越好越稳定。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdab4a554d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="常用命令">常用命令</h2><h3 id="启动docker">启动docker</h3><p>如果是mac或者windows用户，可以直接使用Docker Desktop来可视化处理<br>如果是linux用户，需要通过命令行来启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start/stop/restart</span><br></pre></td></tr></table></figure><h3 id="使用docker">使用docker</h3><ol><li>help帮助命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image --help</span><br></pre></td></tr></table></figure><p>通过这条命令可以查看与docker的镜像相关的命令<br>将image替换为container，则可以查看到关于container的相关帮助。<br>同时，可以进一步查看相关命令的细节，比如下面的命令就可以查看image下prune命令的细节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune --help</span><br></pre></td></tr></table></figure><ol start="2"><li>搜索并拉取镜像</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 搜索与ubuntu相关的image</span><br><span class="line">docker search ubuntu</span><br><span class="line"></span><br><span class="line">// 拉取镜像到本地</span><br><span class="line">docker pull ubuntu</span><br><span class="line"></span><br><span class="line">// 如果没有特别声明tag,会默认使用latest标签。</span><br><span class="line">// 当然可以去docker hub去查找image并查看更加细节的东西，比如版本信息，然后在拉取的时候可以指定版本。</span><br><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure><ol start="3"><li>列出当前本地的所有镜像</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">或者</span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>如果想同时查看中间层镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images -a</span><br><span class="line">或者</span><br><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure><ol start="4"><li>删除本地镜像</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 删除固定的某个镜像</span><br><span class="line">docker rmi imageid</span><br><span class="line">docker image rm imageid</span><br><span class="line"></span><br><span class="line">//删除所有玄虚镜像</span><br><span class="line">docker image prune</span><br><span class="line"></span><br><span class="line">// 删除所有玄虚镜像和未使用的景象</span><br><span class="line">docker image prune -a</span><br><span class="line"></span><br><span class="line">// 删除所有仓库名为redis的镜像</span><br><span class="line">docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure><ol start="5"><li>启动一个容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 从image启动一个容器</span><br><span class="line">docker run -it --name ubuntu  ubuntu:18.04  /bin/bash</span><br><span class="line"> -i : Keep STDIN open even if not attached 即使没有连接，也要保持标准输入保持打开状态</span><br><span class="line"> -t : Allocate a pseudo-TTY  分配一个伪tty</span><br><span class="line"> -name ubuntu : 为当前容器分配名字为ubuntu</span><br><span class="line"> ubuntu:18.04 ：要运行的镜像</span><br><span class="line"> /bin/bash ：要执行的命令。</span><br><span class="line"></span><br><span class="line">还有一个参数非常常见 </span><br><span class="line"> -d : Run container in background and print container ID 在后台运行容器，且打印容器id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 把之前停止的容器重新启动</span><br><span class="line">docker start containerid</span><br><span class="line">docker attach containerid</span><br></pre></td></tr></table></figure><p>使用docker run命令来启动容器，docker在后台运行的标准操作包括</p><pre><code>1. 检查本地是否存在指定的镜像，不存在则从公有仓库下载2. 使用镜像创建并启动容器3.分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层4.从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中去5.从地址池分配一个ip地址给容器6.执行用户指定的应用程序7.执行完毕之后容器被终止</code></pre><p>需要注意的是，对于容器要执行的命令而言，如果执行结束，那么容器就会关闭。</p><ol start="6"><li>查看当前正在运行的容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>如果还想查看已经退出的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><ol start="7"><li>连接一个执行之中的容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container exec -it containerid</span><br></pre></td></tr></table></figure><ol start="8"><li>退出正在运行的容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctrl + D</span><br><span class="line">或者</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><ol start="9"><li>查看镜像所占空间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><ol start="10"><li>删除某些名称中含有dingms的container</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm $(docker ps -a |grep dingms | awk &apos;&#123;print $1&#125;&apos;)</span><br></pre></td></tr></table></figure><ol start="11"><li>守护态进程<br>很多时候，需要让docker在后台运行而不是直接把结果输出到当前宿主下面，这个时候可以用守护态运行。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 没有使用守护态，始终在本地终端输出</span><br><span class="line">docker run  ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line"></span><br><span class="line">//使用守护态,不在本地终端输出，但是在最后结果输出</span><br><span class="line">docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">// 查看当前contain</span><br><span class="line">docker container ls</span><br><span class="line">docker container logs containerid</span><br></pre></td></tr></table></figure><ol start="12"><li>终止某个容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop containerid</span><br></pre></td></tr></table></figure><p>对于正在运行中的容器，重新启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container restart containerid</span><br></pre></td></tr></table></figure><ol start="13"><li>进入容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker attach containerid</span><br><span class="line"></span><br><span class="line">docker exec -it containerid bash</span><br><span class="line"></span><br><span class="line">用attach进入终端之后，如果exit会直接让容器终止。</span><br><span class="line">但是exec通过exit退出之后，容器不会终止。</span><br></pre></td></tr></table></figure><ol start="14"><li>镜像打包和加载</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 打包镜像</span><br><span class="line">docker save -o ~/Desktop/kuakua.tar kuakua:latest</span><br><span class="line">// 加载tar包到对应的镜像</span><br><span class="line">docker load -i ~/Desktop/kuakua.tar</span><br></pre></td></tr></table></figure><ol start="15"><li>导出和导入容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 导出容器快照文件到本地文件</span><br><span class="line">docker export containerid &gt; name.tar</span><br><span class="line">// 从容器快照文件再导入为镜像</span><br><span class="line">cat name.tar | docker import - test/name:v1.0</span><br><span class="line">// 查看所属镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p>从网上找到一个非常棒的图<br><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdbf14142a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2 id="参考文章">参考文章</h2><ol><li><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">Docker 从入门到实践</a></li><li><a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="noopener">Docker-cli官方文档</a></li><li><a href="https://juejin.im/post/5cacbfd7e51d456e8833390c#heading-0" target="_blank" rel="noopener">30 分钟快速入门 Docker 教程</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker是目前最流行的虚拟化技术。&lt;br&gt;
本篇文章主要介绍docker的基本概念以及初步尝试使用docker技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>go-get碰到timeout怎么办</title>
    <link href="http://yoursite.com/2020/04/23/go-micro-bug-io-timeout/"/>
    <id>http://yoursite.com/2020/04/23/go-micro-bug-io-timeout/</id>
    <published>2020-04-23T12:49:48.000Z</published>
    <updated>2020-04-23T13:42:28.357Z</updated>
    
    <content type="html"><![CDATA[<p>go get 下载资源的时候下载缓慢甚至遇到timeout,可以通过设置代理的方式来解决。</p><a id="more"></a><p>通过如下命令可以查看go对应的各类变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure><p>我们重点要看.GO111MODULE这两个选项。</p><ol><li>GOPROXY: 代表是使用代理。</li><li>GO111MODULE: 表示是否使用module.在Go1.11版本之后就非常推荐使用go module 来管理依赖了。所以非常推荐使用。</li></ol><h2 id="Linux-或者-Mac环境下">Linux 或者 Mac环境下</h2><p>直接修改环境变量就可以啦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line">export GO111MODULE=on</span><br><span class="line">export GOPROXY=https://goproxy.io </span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>通过go env再查看一下，上面的路径是否生效。若已经生效，则重新 go get 下载资源即可。</p><h2 id="GO-Land-开发">GO Land 开发</h2><p>GO111MODULE=ON还是要通过上面的方式进行设定。</p><p>如果是使用goland,还可以依次的点击如下选项设置proxy。<br>GOLAND-&gt;Preferences-&gt;Go-&gt;Go modules(vgo)-&gt;选中Enable Go module integration.<br>同时设置proxy的值为 <a href="https://goproxy.io" target="_blank" rel="noopener">https://goproxy.io</a> 或者 <a href="https://goproxy.cn" target="_blank" rel="noopener">https://goproxy.cn</a>,direct<br>点击apply就行。</p><p>通过go env再查看一下，上面的路径是否生效。若已经生效，则重新 go get 下载资源即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go get 下载资源的时候下载缓慢甚至遇到timeout,可以通过设置代理的方式来解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Bugs" scheme="http://yoursite.com/categories/Bugs/"/>
    
    
      <category term="go-micro" scheme="http://yoursite.com/tags/go-micro/"/>
    
      <category term="timout" scheme="http://yoursite.com/tags/timout/"/>
    
      <category term="proxy" scheme="http://yoursite.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>【微服务Go-micro第三篇】相关概念解释</title>
    <link href="http://yoursite.com/2020/04/23/go-micro-3-concept-interpretation/"/>
    <id>http://yoursite.com/2020/04/23/go-micro-3-concept-interpretation/</id>
    <published>2020-04-23T10:51:33.000Z</published>
    <updated>2020-04-23T11:06:52.405Z</updated>
    
    <content type="html"><![CDATA[<p>在搭建环境的时候其实我就有很多疑问了，怎么有这么多概念？<br>微服务、RPC, gRPC, protoc等等，它们都是啥？本篇文章来进行比较详细的解释。</p><a id="more"></a><h2 id="微服务">微服务</h2><p>使用一套小服务来开发单个应用的方式，每个服务运行在独立的进程里，一般采用轻量级的通讯机制互联，并且它们可以通过自动化的方式部署。</p><h2 id="RPC">RPC</h2><ol><li>远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议</li><li>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li><li>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用</li></ol><h2 id="gRPC">gRPC</h2><ol><li>gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统</li><li>gRPC客户端和服务端可以在多种环境中运行和交互，例如用java写一个服务端，可以用go语言写客户端调用</li></ol><h2 id="protobuff">protobuff</h2><ol><li>gRPC可以实现微服务，将大的项目拆分为多个小且独立的业务模块，也就是服务，各服务间使用高效的protobuf协议进行RPC调用，gRPC默认使用protocol  buffer，这是google开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如JSON）</li><li>可以用proto files创建gRPC服务，用message类型来定义方法参数和返回类型</li></ol><h2 id="个人理解">个人理解</h2><p>结合这里和我们上一篇的文章，我们可以得到以下结论</p><ol><li>我们是使用了proto file(user.proto)来定义对应的方法和返回类型，其中message结构来定义接收参数和返回参数的名称以及类型。 service结构来定义对应的远程调用的方法和接受的对应的参数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service user&#123;</span><br><span class="line">        rpc RegisterUser(RegisterUserReq) returns (RegisterUserRsp)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserReq&#123;</span><br><span class="line">        string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserRsp&#123;</span><br><span class="line">        string status = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>protoc命令会按照proto文件中声明的message的格式构造传输对象。gRPC的服务器端和客户端都遵守protocal buffer协议，在客户端会序列化请求对象，在服务端反序列化请求对象，服务器端处理完成之后，序列化响应对象，客户端再反序列化响应对象。所以共同遵守protocal buff 协议让客户端和服务器端可以方便地进行通信，即使最后客户端和服务器端是用不同的语言来实现的也没有关系。</li></ol><h2 id="protobuf语法">protobuf语法</h2><h3 id="简单介绍">简单介绍</h3><ol><li>以.proto结尾</li><li>Message命名采用驼峰命名方式，字段命名采用小写字母加下划线分隔方式</li><li>结构定义可以包含：message、service、enum</li><li>可以通过required表示这个参数是必须的，optional表示这个参数是可选的。通过default表示这个参数的默认值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; // </span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;</span><br><span class="line">  optional int32 page_number = 2;</span><br><span class="line">  optional int32 result_per_page = 3 [default = 10];</span><br><span class="line">  enum Corpus &#123;</span><br><span class="line">    UNIVERSAL = 0;</span><br><span class="line">    WEB = 1;</span><br><span class="line">    IMAGES = 2;</span><br><span class="line">    LOCAL = 3;</span><br><span class="line">    NEWS = 4;</span><br><span class="line">    PRODUCTS = 5;</span><br><span class="line">    VIDEO = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  optional Corpus corpus = 4 [default = UNIVERSAL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service SearchService &#123;</span><br><span class="line">        rpc Search (SearchRequest) returns (SearchResponse) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>更多使用方式可以参见下面的两个链接。</p><h3 id="参考链接">参考链接</h3><ol><li><a href="https://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="noopener">[译]Protobuf 语法指南</a></li><li><a href="http://www.topgoer.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Protobuf%E8%AF%AD%E6%B3%95.html" target="_blank" rel="noopener">1. Protobuf语法</a></li></ol><h2 id="Go-micro">Go-micro</h2><h3 id="什么是go-micro">什么是go-micro</h3><p>go-micro是一个框架，提供了分布式开发所需要的核心需求，包括RPC和基于事件驱动的通信。设计理念是可插拔。</p><h3 id="Go-micro特点">Go-micro特点</h3><ol><li>服务发现：自动服务注册和命名解析。服务发现是微服务开发中的核心，当服务A要与服务B协作时，它得知道服务B在哪里。目前默认的服务发现机制是组播multicast DNS (mdns，组播)，是一种零配置网络。</li><li>负载均衡：在服务发现的基础上构建客户端的负载均衡。当我们查找一个服务发现它有多个节点时，我们需要一种机制来决定最终路由到哪一个节点。默认使用random hashed load balancing来提供服务的负载均衡。如果出现问题，那么go-micro会尝试使用其他节点。</li><li>消息编码：基于内容类型动态编码消息，客户端和服务器端将会使用基于内容类型的编解码器来对Go语言的类型进行无缝隙的编解码。客户端可以编码并发送各种类型额消息，客户端和服务器端默认能够处理这些消息，默认包含 protobuf and json。</li><li>请求/相应：RPC通信是基于双向信息流的请求和相应。go-micro提供一种同步的抽象。一个发送给服务的请求会被自动的解析、负载均衡、拨号、转成字节流。默认传输是通过gRPC。</li><li>异步信息：发布订阅机制在异步通信和事件驱动架构中非常重要，事件通知在微服务开发中占有重要地位。默认的消息传递系统是http事件消息代理。</li><li>可插拔： Go Micro为每个分布式系统抽象出接口。因此，Go Micro的接口都是可插拔的，允许其在运行时不可知的情况下仍可支持。所以只要实现接口，可以在内部使用任何的技术。更多插件请参考：<a href="http://github.com/micro/go-plugins" target="_blank" rel="noopener">github.com/micro/go-plugins</a></li></ol><h3 id="go-micro通信流程">go-micro通信流程</h3><ol><li>Server监听客户端的调用，对Brocker推送过来的信息进行处理。并且Server端需要向Register注册自己的存在或消亡，这样Client才能知道自己的状态</li><li>Register服务的注册的发现，Client端从Register中得到Server的信息，然后每次调用都根据算法选择一个的Server进行通信，当然通信是要经过编码/解码，选择传输协议等一系列过程的</li><li>如果有需要通知所有的Server端可以使用Brocker进行信息的推送，Brocker 信息队列进行信息的接收和发布</li></ol><h3 id="go-micro接口">go-micro接口</h3><p>go-micro之所以可以高度订制和他的框架结构是分不开的，go-micro由8个关键的interface组成，每一个interface都可以根据自己的需求重新实现，这8个主要的inteface也构成了go-micro的框架结构<br><img src="http://www.topgoer.com/static/wei/6/1.png" alt=""></p><h3 id="go-micro-接口详解">go-micro 接口详解</h3><h4 id="Transort通信接口">Transort通信接口</h4><p>通信相关接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type Socket interface &#123;</span><br><span class="line">   Recv(*Message) error</span><br><span class="line">   Send(*Message) error</span><br><span class="line">   Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Client interface &#123;</span><br><span class="line">   Socket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Listener interface &#123;</span><br><span class="line">   Addr() string</span><br><span class="line">   Close() error</span><br><span class="line">   Accept(func(Socket)) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Transport interface &#123;</span><br><span class="line">   Dial(addr string, opts ...DialOption) (Client, error)</span><br><span class="line">   Listen(addr string, opts ...ListenOption) (Listener, error)</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Codec编码接口">Codec编码接口</h4><p>编解码，底层也是protobuf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Codec interface &#123;</span><br><span class="line">   ReadHeader(*Message, MessageType) error</span><br><span class="line">   ReadBody(interface&#123;&#125;) error</span><br><span class="line">   Write(*Message, interface&#123;&#125;) error</span><br><span class="line">   Close() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.1.3. Registry注册接口<br>服务注册发现的实现：etcd、consul、mdns、kube-DNS、zk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Registry interface &#123;</span><br><span class="line">   Register(*Service, ...RegisterOption) error</span><br><span class="line">   Deregister(*Service) error</span><br><span class="line">   GetService(string) ([]*Service, error)</span><br><span class="line">   ListServices() ([]*Service, error)</span><br><span class="line">   Watch(...WatchOption) (Watcher, error)</span><br><span class="line">   String() string</span><br><span class="line">   Options() Options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Selector负载均衡">Selector负载均衡</h4><p>根据不同算法请求主机列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Selector interface &#123;</span><br><span class="line">   Init(opts ...Option) error</span><br><span class="line">   Options() Options</span><br><span class="line">   // Select returns a function which should return the next node</span><br><span class="line">   Select(service string, opts ...SelectOption) (Next, error)</span><br><span class="line">   // Mark sets the success/error against a node</span><br><span class="line">   Mark(service string, node *registry.Node, err error)</span><br><span class="line">   // Reset returns state back to zero for a service</span><br><span class="line">   Reset(service string)</span><br><span class="line">   // Close renders the selector unusable</span><br><span class="line">   Close() error</span><br><span class="line">   // Name of the selector</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Broker发布订阅接口">Broker发布订阅接口</h4><p>pull push watch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Broker interface &#123;</span><br><span class="line">   Options() Options</span><br><span class="line">   Address() string</span><br><span class="line">   Connect() error</span><br><span class="line">   Disconnect() error</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Publish(string, *Message, ...PublishOption) error</span><br><span class="line">   Subscribe(string, Handler, ...SubscribeOption) (Subscriber, error)</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Client客户端接口">Client客户端接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Client interface &#123;</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Options() Options</span><br><span class="line">   NewMessage(topic string, msg interface&#123;&#125;, opts ...MessageOption) Message</span><br><span class="line">   NewRequest(service, method string, req interface&#123;&#125;, reqOpts ...RequestOption) Request</span><br><span class="line">   Call(ctx context.Context, req Request, rsp interface&#123;&#125;, opts ...CallOption) error</span><br><span class="line">   Stream(ctx context.Context, req Request, opts ...CallOption) (Stream, error)</span><br><span class="line">   Publish(ctx context.Context, msg Message, opts ...PublishOption) error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Server服务端接口">Server服务端接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Server interface &#123;</span><br><span class="line">   Options() Options</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Handle(Handler) error</span><br><span class="line">   NewHandler(interface&#123;&#125;, ...HandlerOption) Handler</span><br><span class="line">   NewSubscriber(string, interface&#123;&#125;, ...SubscriberOption) Subscriber</span><br><span class="line">   Subscribe(Subscriber) error</span><br><span class="line">   Register() error</span><br><span class="line">   Deregister() error</span><br><span class="line">   Start() error</span><br><span class="line">   Stop() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Serveice接口">Serveice接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Service interface &#123;</span><br><span class="line">   Init(...Option)</span><br><span class="line">   Options() Options</span><br><span class="line">   Client() client.Client</span><br><span class="line">   Server() server.Server</span><br><span class="line">   Run() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.topgoer.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1/GoMicro%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">Go Micro接口详解</a></p><h2 id="总结">总结</h2><p>看了上面那么多概念，我们可以稍微做一下梳理和总结。</p><ol><li>我们对业务需求进行梳理划分，分解一个一个的单一职责的任务，我们分别通过一个<strong>微服务</strong>来实现对应的任务。</li><li><strong>go-micro</strong>是一个可以用来实现微服务的框架，设计理念是可插拔，什么意思呢，就是组件可以随时替换，有多种实现方式。go-micro的整理设计逻辑如下图所示。<br><img src="http://www.topgoer.com/static/wei/6/1.png" alt=""></li><li>微服务在实现过程中是有一定的技术要求的。</li></ol><ul><li>服务注册与发现：用户想调用一个服务，必须首先找到这个服务，所以对于一个服务而言，就必须在开启时要进行注册，go-micro让Registry来负责这个任务，而Registry有多种实现方式，可以参见下表，而我们搭建环境的时候就用的<strong>etcd</strong>。</li><li>要进行负载均衡。用户在找同一个服务的时候可能会有多个节点实现这个服务，所以需要根据相应的<a href="https://blog.csdn.net/lihao21/article/details/54695471" target="_blank" rel="noopener">负载均衡机制</a>进行节点选择。这部分就由Selector来负责。</li><li>要进行消息编解码，不同的service在调用的时候是需要传递数据的，数据在编码和解码上要有统一的规则，从而进行序列化和反序列化。编解码支持json和<strong>protobuff</strong>。这部分的编解码工作由Codec来负责。我们在用go-micro编写微服务时，我们会按照protobuf的语法来编写<strong>proto file</strong>，然后通过protoc,protoc-gen-go,protoc-gen-mico来生成对应的消息对象以及相应服务的API.</li><li>要进行通信：这部分由transort来负责。</li><li>Broker主要对异步信息进行处理</li></ul><p>4.这几部分具体有哪些实现呢？可以看<a href="https://github.com/micro/go-plugins" target="_blank" rel="noopener">go-plugins</a>这个库中的插件的集合。</p><table><thead><tr><th>Directory</th><th>Description</th></tr></thead><tbody><tr><td>Broker</td><td>PubSub messaging; NATS, NSQ, RabbitMQ, Kafka</td></tr><tr><td>Client</td><td>RPC Clients; gRPC, HTTP</td></tr><tr><td>Codec</td><td>Message Encoding; BSON, Mercury</td></tr><tr><td>Micro</td><td>Micro Toolkit Plugins</td></tr><tr><td>Registry</td><td>Service Discovery; Etcd, Gossip, NATS</td></tr><tr><td>Selector</td><td>Load balancing; Label, Cache, Static</td></tr><tr><td>Server</td><td>RPC Servers; gRPC, HTTP</td></tr><tr><td>Transport</td><td>Bidirectional Streaming; NATS, RabbitMQ</td></tr><tr><td>Wrapper</td><td>Middleware; Circuit Breakers, Rate Limiting, Tracing, Monitoring</td></tr></tbody></table><ol start="5"><li>对我们而言如何使用go-micro呢？</li></ol><ul><li>根据服务需求来写好proto file</li><li>根据proto file 生成对应的传输对象以及服务端和客户端的api</li><li>编写服务器端和客户端代码</li><li>执行服务器端和客户端代码</li></ul><p>注意：在执行的时候可以指定最下面一层的各个组件，具体指定方式可以通过命令行指定或者设置环境变量或者直接在文件中写死等方式，更加详细的内容可以查看<a href="https://github.com/micro/go-plugins/blob/master/README.md" target="_blank" rel="noopener">Go-Plugins-README</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在搭建环境的时候其实我就有很多疑问了，怎么有这么多概念？&lt;br&gt;
微服务、RPC, gRPC, protoc等等，它们都是啥？本篇文章来进行比较详细的解释。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="go-micro" scheme="http://yoursite.com/tags/go-micro/"/>
    
  </entry>
  
  <entry>
    <title>【微服务Go-micro第二篇】protoc到底干了啥</title>
    <link href="http://yoursite.com/2020/04/22/go-micro-2-protoc-task/"/>
    <id>http://yoursite.com/2020/04/22/go-micro-2-protoc-task/</id>
    <published>2020-04-22T13:41:41.000Z</published>
    <updated>2020-04-22T13:49:59.214Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要介绍上一篇文章中利用protoc命令生成proto文件对应的另外两个文件的过程，<br>并简单介绍在实际业务中如何使用这两个文件。</p><a id="more"></a><h1>先说结论</h1><p>上一节我们通过下面的命令使得 user.proto</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=. --micro_out=. --go_out=. proto/greeter.proto</span><br></pre></td></tr></table></figure><p>生成了如下两个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.pb.go  user.pb.micro.go</span><br></pre></td></tr></table></figure><p>我们现在可以解释为什么会出现这种情况啦。</p><ol><li><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">protoc</a>是一个代码生成的工具，它其实可以生成多种语言对应的文件,包括但是不限于c++,java,js,python,c#,当然也包括Go。</li><li>可以根据命令的参数格式发现–go_out实际上就是将生成的go语言的文件放到当前目录。然后–micro_out就是将生成的微服务的文件放到当前目录，所以就生成了上面的两个文件。</li><li>具体是怎么生成的呢？先说生成的go文件，这个文件我看了一下其实主要就是对于proto文件中的message进行编写。因为这个message将会是之后服务器和客户端进行通信的对象结构，所以有一些通用的方法，比如结构体定义，string方法等，在后面微服务的时候可以调用它。再说生成的micro文件，这个文件会针对于service中rpc的定义进行展开。会提供客户端和服务器端对应的api。</li><li>先说服务器端api的调用和对应api的使用。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type UserHandler interface &#123;</span><br><span class="line">        RegisterUser(context.Context, *RegisterUserReq, *RegisterUserRsp) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RegisterUserHandler(s server.Server, hdlr UserHandler, opts ...server.HandlerOption) error &#123;</span><br><span class="line">        type user interface &#123;</span><br><span class="line">                RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error</span><br><span class="line">        &#125;</span><br><span class="line">        type User struct &#123;</span><br><span class="line">                user</span><br><span class="line">        &#125;</span><br><span class="line">        h := &amp;userHandler&#123;hdlr&#125;</span><br><span class="line">        return s.Handle(s.NewHandler(&amp;User&#123;h&#125;, opts...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userHandler struct &#123;</span><br><span class="line">        UserHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *userHandler) RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error &#123;</span><br><span class="line">        return h.UserHandler.RegisterUser(ctx, in, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server端api主要要创建一个服务，然后针对于这个服务提供handler方法，对应的handler要实现接口RegisterUser中的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type User struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func(user *User)  RegisterUser(ctx context.Context, req  *proto.RegisterUserReq,  rsp *proto.RegisterUserRsp) (error)&#123;</span><br><span class="line">        rsp.Status =&quot;ok&quot;+req.Name</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建服务</span><br><span class="line">service := micro.NewService(</span><br><span class="line">                micro.Name(&quot;user&quot;),</span><br><span class="line">        )</span><br><span class="line">proto.RegisterUserHandler(service.Server(), new(User))</span><br></pre></td></tr></table></figure><p>更详细的代码可以查看后面的main.go<br>5. 再说客户端的api和对应api的使用<br>生成的客户端的api如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type UserService interface &#123;</span><br><span class="line">        RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userService struct &#123;</span><br><span class="line">        c    client.Client</span><br><span class="line">        name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewUserService(name string, c client.Client) UserService&#123;```&#125;</span><br><span class="line"></span><br><span class="line">func (c *userService) RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error) &#123;···&#125;</span><br></pre></td></tr></table></figure><p>所以在我们使用的时候，要首先通过NewUserService得到对应的service,然后调用RegisterUser方法来得到请求结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">userService := proto.NewUserService(&quot;user&quot;, service.Client())</span><br><span class="line"></span><br><span class="line">// Call the userregister</span><br><span class="line">rsp, err := userService.RegisterUser(context.TODO(), &amp;proto.RegisterUserReq&#123;Name: &quot;John&quot;&#125;)</span><br></pre></td></tr></table></figure><p>更加详细的代码可以参见后面client.go中的代码。</p><h1>具体代码</h1><h2 id="1-user-proto">1.  user.proto</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service user&#123;</span><br><span class="line">        rpc RegisterUser(RegisterUserReq) returns (RegisterUserRsp)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserReq&#123;</span><br><span class="line">        string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserRsp&#123;</span><br><span class="line">        string status = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-user-pb-go">2. user.pb.go</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">// Code generated by protoc-gen-go. DO NOT EDIT.</span><br><span class="line">// versions:</span><br><span class="line">//      protoc-gen-go v1.21.0</span><br><span class="line">//      protoc        v3.11.4</span><br><span class="line">// source: proto/user.proto</span><br><span class="line"></span><br><span class="line">package user</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        proto &quot;github.com/golang/protobuf/proto&quot;</span><br><span class="line">        protoreflect &quot;google.golang.org/protobuf/reflect/protoreflect&quot;</span><br><span class="line">        protoimpl &quot;google.golang.org/protobuf/runtime/protoimpl&quot;</span><br><span class="line">        reflect &quot;reflect&quot;</span><br><span class="line">        sync &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">        // Verify that this generated code is sufficiently up-to-date.</span><br><span class="line">        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)</span><br><span class="line">        // Verify that runtime/protoimpl is sufficiently up-to-date.</span><br><span class="line">        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// This is a compile-time assertion that a sufficiently up-to-date version</span><br><span class="line">// of the legacy proto package is being used.</span><br><span class="line">const _ = proto.ProtoPackageIsVersion4</span><br><span class="line"></span><br><span class="line">type RegisterUserReq struct &#123;</span><br><span class="line">        state         protoimpl.MessageState</span><br><span class="line">        sizeCache     protoimpl.SizeCache</span><br><span class="line">        unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">        Name string `protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) Reset() &#123;</span><br><span class="line">        *x = RegisterUserReq&#123;&#125;</span><br><span class="line">        if protoimpl.UnsafeEnabled &#123;</span><br><span class="line">                mi := &amp;file_proto_user_proto_msgTypes[0]</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                ms.StoreMessageInfo(mi)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) String() string &#123;</span><br><span class="line">        return protoimpl.X.MessageStringOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*RegisterUserReq) ProtoMessage() &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) ProtoReflect() protoreflect.Message &#123;</span><br><span class="line">        mi := &amp;file_proto_user_proto_msgTypes[0]</span><br><span class="line">        if protoimpl.UnsafeEnabled &amp;&amp; x != nil &#123;</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                if ms.LoadMessageInfo() == nil &#123;</span><br><span class="line">                        ms.StoreMessageInfo(mi)</span><br><span class="line">                &#125;</span><br><span class="line">                return ms</span><br><span class="line">        &#125;</span><br><span class="line">        return mi.MessageOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Deprecated: Use RegisterUserReq.ProtoReflect.Descriptor instead.</span><br><span class="line">func (*RegisterUserReq) Descriptor() ([]byte, []int) &#123;</span><br><span class="line">        return file_proto_user_proto_rawDescGZIP(), []int&#123;0&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) GetName() string &#123;</span><br><span class="line">        if x != nil &#123;</span><br><span class="line">                return x.Name</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RegisterUserRsp struct &#123;</span><br><span class="line">        state         protoimpl.MessageState</span><br><span class="line">        sizeCache     protoimpl.SizeCache</span><br><span class="line">        unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">        Status string `protobuf:&quot;bytes,1,opt,name=status,proto3&quot; json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) Reset() &#123;</span><br><span class="line">        *x = RegisterUserRsp&#123;&#125;</span><br><span class="line">        if protoimpl.UnsafeEnabled &#123;</span><br><span class="line">                mi := &amp;file_proto_user_proto_msgTypes[1]</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                ms.StoreMessageInfo(mi)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) String() string &#123;</span><br><span class="line">        return protoimpl.X.MessageStringOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*RegisterUserRsp) ProtoMessage() &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) ProtoReflect() protoreflect.Message &#123;</span><br><span class="line">        mi := &amp;file_proto_user_proto_msgTypes[1]</span><br><span class="line">        if protoimpl.UnsafeEnabled &amp;&amp; x != nil &#123;</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                if ms.LoadMessageInfo() == nil &#123;</span><br><span class="line">                        ms.StoreMessageInfo(mi)</span><br><span class="line">                &#125;</span><br><span class="line">                return ms</span><br><span class="line">        &#125;</span><br><span class="line">        return mi.MessageOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Deprecated: Use RegisterUserRsp.ProtoReflect.Descriptor instead.</span><br><span class="line">func (*RegisterUserRsp) Descriptor() ([]byte, []int) &#123;</span><br><span class="line">        return file_proto_user_proto_rawDescGZIP(), []int&#123;1&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) GetStatus() string &#123;</span><br><span class="line">        if x != nil &#123;</span><br><span class="line">                return x.Status</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var File_proto_user_proto protoreflect.FileDescriptor</span><br><span class="line"></span><br><span class="line">var file_proto_user_proto_rawDesc = []byte&#123;</span><br><span class="line">        0x0a, 0x10, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f,</span><br><span class="line">        0x74, 0x6f, 0x22, 0x25, 0x0a, 0x0f, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73,</span><br><span class="line">        0x65, 0x72, 0x52, 0x65, 0x71, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,</span><br><span class="line">        0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x29, 0x0a, 0x0f, 0x52, 0x65, 0x67,</span><br><span class="line">        0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x73, 0x70, 0x12, 0x16, 0x0a, 0x06,</span><br><span class="line">        0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74,</span><br><span class="line">         0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x73, 0x70, 0x12, 0x16, 0x0a, 0x06,</span><br><span class="line">        0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74,</span><br><span class="line">        0x61, 0x74, 0x75, 0x73, 0x32, 0x3c, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x34, 0x0a, 0x0c,</span><br><span class="line">        0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x12, 0x10, 0x2e, 0x52,</span><br><span class="line">        0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x1a, 0x10,</span><br><span class="line">        0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x73, 0x70,</span><br><span class="line">        0x22, 0x00, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">        file_proto_user_proto_rawDescOnce sync.Once</span><br><span class="line">        file_proto_user_proto_rawDescData = file_proto_user_proto_rawDesc</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func file_proto_user_proto_rawDescGZIP() []byte &#123;</span><br><span class="line">        file_proto_user_proto_rawDescOnce.Do(func() &#123;</span><br><span class="line">                file_proto_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_user_proto_rawDescData)</span><br><span class="line">        &#125;)</span><br><span class="line">        return file_proto_user_proto_rawDescData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var file_proto_user_proto_msgTypes = make([]protoimpl.MessageInfo, 2)</span><br><span class="line">var file_proto_user_proto_goTypes = []interface&#123;&#125;&#123;</span><br><span class="line">        (*RegisterUserReq)(nil), // 0: RegisterUserReq</span><br><span class="line">        (*RegisterUserRsp)(nil), // 1: RegisterUserRsp</span><br><span class="line">&#125;</span><br><span class="line">var file_proto_user_proto_depIdxs = []int32&#123;</span><br><span class="line">        0, // 0: user.RegisterUser:input_type -&gt; RegisterUserReq</span><br><span class="line">        1, // 1: user.RegisterUser:output_type -&gt; RegisterUserRsp</span><br><span class="line">        1, // [1:2] is the sub-list for method output_type</span><br><span class="line">        0, // [0:1] is the sub-list for method input_type</span><br><span class="line">        0, // [0:0] is the sub-list for extension type_name</span><br><span class="line">        0, // [0:0] is the sub-list for extension extendee</span><br><span class="line">        0, // [0:0] is the sub-list for field type_name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123; file_proto_user_proto_init() &#125;</span><br><span class="line">func file_proto_user_proto_init() &#123;</span><br><span class="line">        if File_proto_user_proto != nil &#123;</span><br><span class="line">                return</span><br><span class="line">        &#125;</span><br><span class="line">        if !protoimpl.UnsafeEnabled &#123;</span><br><span class="line">                file_proto_user_proto_msgTypes[0].Exporter = func(v interface&#123;&#125;, i int) interface&#123;&#125; &#123;</span><br><span class="line">                        switch v := v.(*RegisterUserReq); i &#123;</span><br><span class="line">                        case 0:</span><br><span class="line">                                return &amp;v.state</span><br><span class="line">                        case 1:</span><br><span class="line">                                return &amp;v.sizeCache</span><br><span class="line">                        case 2:</span><br><span class="line">                                return &amp;v.unknownFields</span><br><span class="line">                        default:</span><br><span class="line">                                return nil</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                file_proto_user_proto_msgTypes[1].Exporter = func(v interface&#123;&#125;, i int) interface&#123;&#125; &#123;</span><br><span class="line">                        switch v := v.(*RegisterUserRsp); i &#123;</span><br><span class="line">                        case 0:</span><br><span class="line">                                return &amp;v.state</span><br><span class="line">                        case 1:</span><br><span class="line">                                return &amp;v.sizeCache</span><br><span class="line">                        case 2:</span><br><span class="line">                                return &amp;v.unknownFields</span><br><span class="line">                        default:</span><br><span class="line">                                return nil</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        type x struct&#123;&#125;</span><br><span class="line">        out := protoimpl.TypeBuilder&#123;</span><br><span class="line">                File: protoimpl.DescBuilder&#123;</span><br><span class="line">                        GoPackagePath: reflect.TypeOf(x&#123;&#125;).PkgPath(),</span><br><span class="line">                        RawDescriptor: file_proto_user_proto_rawDesc,</span><br><span class="line">                        NumEnums:      0,</span><br><span class="line">                        NumMessages:   2,</span><br><span class="line">                        NumExtensions: 0,</span><br><span class="line">                        NumServices:   1,</span><br><span class="line">                &#125;,</span><br><span class="line">                GoTypes:           file_proto_user_proto_goTypes,</span><br><span class="line">                DependencyIndexes: file_proto_user_proto_depIdxs,</span><br><span class="line">                MessageInfos:      file_proto_user_proto_msgTypes,</span><br><span class="line">        &#125;.Build()</span><br><span class="line">        File_proto_user_proto = out.File</span><br><span class="line">        file_proto_user_proto_rawDesc = nil</span><br><span class="line">        file_proto_user_proto_goTypes = nil</span><br><span class="line">        file_proto_user_proto_depIdxs = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-user-pb-micro-go">3. user.pb.micro.go</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// Code generated by protoc-gen-micro. DO NOT EDIT.</span><br><span class="line">// source: proto/user.proto</span><br><span class="line"></span><br><span class="line">package user</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        fmt &quot;fmt&quot;</span><br><span class="line">        proto &quot;github.com/golang/protobuf/proto&quot;</span><br><span class="line">        math &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        context &quot;context&quot;</span><br><span class="line">        api &quot;github.com/micro/go-micro/v2/api&quot;</span><br><span class="line">        client &quot;github.com/micro/go-micro/v2/client&quot;</span><br><span class="line">        server &quot;github.com/micro/go-micro/v2/server&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Reference imports to suppress errors if they are not otherwise used.</span><br><span class="line">var _ = proto.Marshal</span><br><span class="line">var _ = fmt.Errorf</span><br><span class="line">var _ = math.Inf</span><br><span class="line"></span><br><span class="line">// This is a compile-time assertion to ensure that this generated file</span><br><span class="line">// is compatible with the proto package it is being compiled against.</span><br><span class="line">// A compilation error at this line likely means your copy of the</span><br><span class="line">// proto package needs to be updated.</span><br><span class="line">const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package</span><br><span class="line"></span><br><span class="line">// Reference imports to suppress errors if they are not otherwise used.</span><br><span class="line">var _ api.Endpoint</span><br><span class="line">var _ context.Context</span><br><span class="line">var _ client.Option</span><br><span class="line">var _ server.Option</span><br><span class="line"></span><br><span class="line">// Api Endpoints for User service</span><br><span class="line"></span><br><span class="line">func NewUserEndpoints() []*api.Endpoint &#123;</span><br><span class="line">        return []*api.Endpoint&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Client API for User service</span><br><span class="line"></span><br><span class="line">type UserService interface &#123;</span><br><span class="line">        RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userService struct &#123;</span><br><span class="line">        c    client.Client</span><br><span class="line">        name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewUserService(name string, c client.Client) UserService &#123;</span><br><span class="line">        return &amp;userService&#123;</span><br><span class="line">                c:    c,</span><br><span class="line">                name: name,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *userService) RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error) &#123;</span><br><span class="line">        req := c.c.NewRequest(c.name, &quot;User.RegisterUser&quot;, in)</span><br><span class="line">        out := new(RegisterUserRsp)</span><br><span class="line">        err := c.c.Call(ctx, req, out, opts...)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">                        return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">        return out, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Server API for User service</span><br><span class="line"></span><br><span class="line">type UserHandler interface &#123;</span><br><span class="line">        RegisterUser(context.Context, *RegisterUserReq, *RegisterUserRsp) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RegisterUserHandler(s server.Server, hdlr UserHandler, opts ...server.HandlerOption) error &#123;</span><br><span class="line">        type user interface &#123;</span><br><span class="line">                RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error</span><br><span class="line">        &#125;</span><br><span class="line">        type User struct &#123;</span><br><span class="line">                user</span><br><span class="line">        &#125;</span><br><span class="line">        h := &amp;userHandler&#123;hdlr&#125;</span><br><span class="line">        return s.Handle(s.NewHandler(&amp;User&#123;h&#125;, opts...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userHandler struct &#123;</span><br><span class="line">        UserHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *userHandler) RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error &#123;</span><br><span class="line">        return h.UserHandler.RegisterUser(ctx, in, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-main-go">4. main.go</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;datatown/proto&quot;</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(user *User)  RegisterUser(ctx context.Context, req  *proto.RegisterUserReq,  rsp *proto.RegisterUserRsp) (error)&#123;</span><br><span class="line">        rsp.Status =&quot;ok&quot;+req.Name</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service. Optionally include some options here.</span><br><span class="line">        service := micro.NewService(</span><br><span class="line">                micro.Name(&quot;user&quot;),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // Init will parse the command line flags.</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Register handler</span><br><span class="line">        proto.RegisterUserHandler(service.Server(), new(User))</span><br><span class="line"></span><br><span class="line">        // Run the server</span><br><span class="line">        if err := service.Run(); err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-client-go">5. client.go</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;datatown/proto&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service</span><br><span class="line">        service := micro.NewService(micro.Name(&quot;user.client&quot;))</span><br><span class="line">        // Initialise the client and parse command line flags</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Create new user service  client</span><br><span class="line">        userService := proto.NewUserService(&quot;user&quot;, service.Client())</span><br><span class="line"></span><br><span class="line">        // Call the userregister</span><br><span class="line">        rsp, err := userService.RegisterUser(context.TODO(), &amp;proto.RegisterUserReq&#123;Name: &quot;John&quot;&#125;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Print response</span><br><span class="line">        fmt.Println(rsp.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要介绍上一篇文章中利用protoc命令生成proto文件对应的另外两个文件的过程，&lt;br&gt;
并简单介绍在实际业务中如何使用这两个文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="go-micro" scheme="http://yoursite.com/tags/go-micro/"/>
    
      <category term="protoc" scheme="http://yoursite.com/tags/protoc/"/>
    
  </entry>
  
  <entry>
    <title>【微服务Go-micro第一篇】环境配置</title>
    <link href="http://yoursite.com/2020/04/22/go-micro-1-build-environment/"/>
    <id>http://yoursite.com/2020/04/22/go-micro-1-build-environment/</id>
    <published>2020-04-22T04:50:21.000Z</published>
    <updated>2020-04-22T04:56:36.523Z</updated>
    
    <content type="html"><![CDATA[<p>go-micro 是一个基于Go语言的分布式框架，可以用来对外提供微服务。<br>本篇文章介绍如何在linux系统下进行环境配置，并写好自己的第一个helloworld程序。</p><a id="more"></a><h2 id="一、依赖安装">一、依赖安装</h2><ol><li>依赖安装 protoc-gen-micro</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 依赖</span><br><span class="line">go get github.com/micro/micro/v2/cmd/protoc-gen-micro@master </span><br><span class="line"></span><br><span class="line">// 上述包依赖两个protoc 和protoc-gen-go </span><br><span class="line"></span><br><span class="line">// 第一个依赖安装</span><br><span class="line">//[protobuf下载](https://github.com/protocolbuffers/protobuf/releases)</span><br><span class="line">wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.4/protoc-3.11.4-linux-x86_64.zip</span><br><span class="line"></span><br><span class="line">unzip protoc-3.11.4-linux-x86_64.zip -d /root/go/gotool/</span><br><span class="line"></span><br><span class="line">// 路径修改</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line">PATH=/root/go/gotool/bin:$PATH</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line">// 检查是否安装成功，如果出现版本号，则说明安装成功。</span><br><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二个依赖protoc-gen-go的安装</span><br><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><ol start="2"><li>依赖安装 etcd</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/etcd-io/etcd/releases/download/v3.4.7/etcd-v3.4.7-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzf etcd-v3.4.7-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">cp etcd* /usr/local/bin/</span><br><span class="line"></span><br><span class="line">// 通过如下命令来启动</span><br><span class="line">etcd</span><br></pre></td></tr></table></figure><p>要声明etcd来进行注册服务，在bash_profile中添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MICRO_REGISTRY=etcd</span><br></pre></td></tr></table></figure><p>如果碰到用go get 命令报403错误可以使用代理来解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line">//添加如下内容</span><br><span class="line"></span><br><span class="line">export GOPROXY=https://goproxy.io // 设置代理</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><ol start="3"><li>通过go-module来管理依赖<br>在bash_profile中添加如下内容</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br></pre></td></tr></table></figure><h2 id="二、helloworld程序">二、helloworld程序</h2><h3 id="2-1-官方实例的helloworld">2.1 官方实例的helloworld</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/micro/micro/v2 </span><br><span class="line"></span><br><span class="line">git clone https://github.com/micro/examples.git</span><br><span class="line">cd examples/service</span><br><span class="line">go run main.go</span><br><span class="line">go run main.go --run_client</span><br></pre></td></tr></table></figure><p>结果会出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello john</span><br></pre></td></tr></table></figure><p>说明实验成功。</p><h3 id="2-2-自己编写helloworld测试">2.2 自己编写helloworld测试</h3><ol><li>构造项目</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 建立项目</span><br><span class="line">mkdir hello &amp;&amp; cd  hello</span><br><span class="line"></span><br><span class="line">// 利用模块来管理相关的依赖。 </span><br><span class="line">go mod init hello</span><br></pre></td></tr></table></figure><ol start="2"><li>编写服务原型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在hello目录下建立服务原型</span><br><span class="line">mkdir proto</span><br><span class="line">vim proto/greeter.proto</span><br></pre></td></tr></table></figure><p>greeter.proto 内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service Greeter &#123;</span><br><span class="line">    rpc Hello(Request) returns (Response) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">    string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    string greeting = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>根据服务原型生成对应的代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在hello目录下执行</span><br><span class="line"> protoc --proto_path=. --micro_out=. --go_out=. proto/greeter.proto</span><br></pre></td></tr></table></figure><p>此时在hello/proto目录下会有三个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greeter.pb.go  </span><br><span class="line">greeter.pb.micro.go </span><br><span class="line">greeter.proto</span><br></pre></td></tr></table></figure><ol start="4"><li>编写main.go文件作为服务器代码。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vim main.go</span><br><span class="line">// 内容如下</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;hello/proto&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Greeter struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (g *Greeter) Hello(ctx context.Context, req *proto.Request, rsp *proto.Response) error &#123;</span><br><span class="line">        rsp.Greeting = &quot;Hello &quot; + req.Name</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service. Optionally include some options here.</span><br><span class="line">        service := micro.NewService(</span><br><span class="line">                micro.Name(&quot;greeter&quot;),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // Init will parse the command line flags.</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Register handler</span><br><span class="line">        proto.RegisterGreeterHandler(service.Server(), new(Greeter))</span><br><span class="line"></span><br><span class="line">        // Run the server</span><br><span class="line">        if err := service.Run(); err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>编写client.go文件作为客户端代码。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vim client.go</span><br><span class="line">// 内容如下</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;hello/proto&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service</span><br><span class="line">        service := micro.NewService(micro.Name(&quot;greeter.client&quot;))</span><br><span class="line">        // Initialise the client and parse command line flags</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Create new greeter client</span><br><span class="line">        greeter := proto.NewGreeterService(&quot;greeter&quot;, service.Client())</span><br><span class="line"></span><br><span class="line">        // Call the greeter</span><br><span class="line">        rsp, err := greeter.Hello(context.TODO(), &amp;proto.Request&#123;Name: &quot;kingwen&quot;&#125;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Print response</span><br><span class="line">        fmt.Println(rsp.Greeting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>运行程序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">etcd </span><br><span class="line">go main.go</span><br><span class="line">go client.go</span><br></pre></td></tr></table></figure><p>结果出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.kingwen。</span><br></pre></td></tr></table></figure><p>说明程序搭建成功。</p><p>最后看一下代码结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── client.go</span><br><span class="line">├── default.etcd</span><br><span class="line">│   └── member</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── proto</span><br><span class="line">    ├── greeter.pb.go</span><br><span class="line">    ├── greeter.pb.micro.go</span><br><span class="line">    └── greeter.proto</span><br></pre></td></tr></table></figure><h2 id="三、参考链接">三、参考链接</h2><ol><li><a href="https://xueyuanjun.com/post/21585" target="_blank" rel="noopener">基于 Go Module 管理依赖并将注册中心调整为 Etcd</a></li><li><a href="https://github.com/micro/go-micro" target="_blank" rel="noopener">go-micro-github地址</a></li><li><a href="https://micro.mu/docs/go-helloworld.html" target="_blank" rel="noopener">micro官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go-micro 是一个基于Go语言的分布式框架，可以用来对外提供微服务。&lt;br&gt;
本篇文章介绍如何在linux系统下进行环境配置，并写好自己的第一个helloworld程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
      <category term="Go-micro" scheme="http://yoursite.com/tags/Go-micro/"/>
    
  </entry>
  
  <entry>
    <title>scrapy-断点调试</title>
    <link href="http://yoursite.com/2020/04/08/scrapy-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2020/04/08/scrapy-断点调试/</id>
    <published>2020-04-08T03:17:04.000Z</published>
    <updated>2020-04-08T05:28:22.673Z</updated>
    
    <content type="html"><![CDATA[<p>因为平时我们在写代码的时候都会依靠于debug来进行调试，<br>那么一般通过命令行启动的scrapy项目要如何进行dubug呢？</p><a id="more"></a><p>用pycharm来解决这个问题的方式也比较简单。</p><ol><li>正常加断点</li><li>要编写一个run.py文件来模拟命令行启动,文件和spiders目录同级，内容如下。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from scrapy import cmdline</span><br><span class="line"></span><br><span class="line">name = &apos;spidername&apos;</span><br><span class="line">cmd = &apos;scrapy crawl &#123;0&#125;&apos;.format(name)</span><br><span class="line">cmdline.execute(cmd.split())</span><br></pre></td></tr></table></figure><ol start="3"><li>点击右上角的debug来执行即可。</li></ol><p>再说一下debug的三个选项</p><ol><li>step into : 单步执行，遇到子函数就进入子函数。</li><li>step over: 单步执行，遇到子函数不进入，而是完成子函数之后返回到当前位置，等同于处理一条命令。</li><li>step out: 单步执行，但是已经进入到子函数了，下面的部分不再单步执行而是返回到调用子函数的位置。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为平时我们在写代码的时候都会依靠于debug来进行调试，&lt;br&gt;
那么一般通过命令行启动的scrapy项目要如何进行dubug呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
      <category term="debug" scheme="http://yoursite.com/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Bug-scrapy-数据错位</title>
    <link href="http://yoursite.com/2020/04/08/Bug-scrapy-%E6%95%B0%E6%8D%AE%E9%94%99%E4%BD%8D/"/>
    <id>http://yoursite.com/2020/04/08/Bug-scrapy-数据错位/</id>
    <published>2020-04-08T02:34:43.000Z</published>
    <updated>2020-04-08T03:15:10.660Z</updated>
    
    <content type="html"><![CDATA[<p>在用scrapy进行数据爬取的时候，发现通过meta传递的数据不匹配，最后发现是深拷贝和浅拷贝的问题。</p><a id="more"></a><h2 id="Bug详情">Bug详情</h2><p>yield Request中传递的meta是浅拷贝，所以当我们有多条请求等待处理的时候，前面请求传递的meta会被后面请求传递的meta修改（他们指向同一个对象），所以就会造成前后不匹配。<br>解决方式就是将其浅拷贝变成深拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">···</span><br><span class="line">def parse(self, response):</span><br><span class="line">     yield Request(url=new_url, meta=&#123;&apos;item&apos;: copy.deepcopy(item)&#125;, callback=self.another_parse)</span><br></pre></td></tr></table></figure><p>同理，如果下载的时候下载item的时候也报错的话，也要记得将item的传递变成深拷贝即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 原来是yield item ,变成如下的样子即可。</span><br><span class="line">yield copy.deepcopy(item)</span><br></pre></td></tr></table></figure><h2 id="参考链接">参考链接</h2><p>1.<a href="https://www.jianshu.com/p/42f22085f4c5" target="_blank" rel="noopener">scrapy里面item传递数据后数据不正确的问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用scrapy进行数据爬取的时候，发现通过meta传递的数据不匹配，最后发现是深拷贝和浅拷贝的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
      <category term="bug" scheme="http://yoursite.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>python-域名抽取</title>
    <link href="http://yoursite.com/2020/04/04/python-%E5%9F%9F%E5%90%8D%E6%8A%BD%E5%8F%96/"/>
    <id>http://yoursite.com/2020/04/04/python-域名抽取/</id>
    <published>2020-04-04T13:47:58.000Z</published>
    <updated>2020-04-04T14:56:02.129Z</updated>
    
    <content type="html"><![CDATA[<p>在看scrapy-cluster源码的时候发现了一个非常实用的包-tldextract，<br>可以非常方便的抽取出一个url的域名作为redis的key的一部分，感觉很神奇。所以记录一下。</p><a id="more"></a><p>对于一个网址而言，比如 <a href="http://www.kingwen.cn" target="_blank" rel="noopener">www.kingwen.cn</a>，可以分为三部分。www, kingwen, cn。分别称为二级域名，域名，后缀。tldextract(top-level domain)这个包就可以帮我们非常快的解决这个问题。</p><h2 id="安装tldextract包">安装tldextract包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tldextract</span><br></pre></td></tr></table></figure><h2 id="使用tldextract包">使用tldextract包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import tldextract</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    url = &apos;www.kingwen.cn&apos;</span><br><span class="line">    res = tldextract.extract(url)</span><br><span class="line">    print(res.subdomain, res.domain, res.suffix) # www kingwen cn</span><br><span class="line">    print(res.registered_domain) # kingwen.cn</span><br><span class="line">    url1 = &apos;localhost:8080/hello&apos;</span><br><span class="line">    res = tldextract.extract(url1)</span><br><span class="line">    print(res.subdomain, res.domain, res.suffix) # &apos;&apos;  localhost  &apos;&apos;</span><br></pre></td></tr></table></figure><h2 id="源码实现">源码实现</h2><p>主要分为三部分。</p><ul><li>首先是进行切割，将输入的url进行划分，利用# ？ @  : 等特殊符号进行不断的划分，最后将主体的域名部分提取出来。</li><li>其次将前一部分的主体域名通过’.'进行划分，形成对应的list。然后按照从位置i匹配到末尾元素的原则找到符合suffix字典（预先定义好的7336条）的第一个位置i.然后返回i。</li><li>最后 list[i:]就是suffix. list[:i-1]就是subdomain. list[i]就是domain.从而问题得到解决。</li></ul><p>尽管比较简单，但是比较实用，所以就记录一下。<br>在以后用到的时候可以省去很多烦恼。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看scrapy-cluster源码的时候发现了一个非常实用的包-tldextract，&lt;br&gt;
可以非常方便的抽取出一个url的域名作为redis的key的一部分，感觉很神奇。所以记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="domain" scheme="http://yoursite.com/tags/domain/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Bug-Scrapy-Filtered_offsite_request</title>
    <link href="http://yoursite.com/2020/03/31/bug-Filtered-offsite-request-Scrapy/"/>
    <id>http://yoursite.com/2020/03/31/bug-Filtered-offsite-request-Scrapy/</id>
    <published>2020-03-31T01:58:03.000Z</published>
    <updated>2020-03-31T09:11:37.138Z</updated>
    
    <content type="html"><![CDATA[<p>在写爬虫的时候遇见了一个bug,报错信息为 Filtered offsite request domain[‘mydomain’],<br>从网上找到了答案并成功解决了问题，特别记录一下。</p><a id="more"></a><h2 id="检查allowed-domains">检查allowed_domains</h2><p>要去查看自己爬取的url是否符合我们的domain。如果我们要爬取的网站的网址为 <a href="https://www.example.com/1.html%EF%BC%8C" target="_blank" rel="noopener">https://www.example.com/1.html，</a> 那么我们就需要添加example.com到我们写好的爬虫中的allow_domains的list列表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allowed_domains = [&apos;example.com&apos;]</span><br></pre></td></tr></table></figure><p>看一下<a href="https://docs.scrapy.org/en/latest/topics/spiders.html" target="_blank" rel="noopener">Scrapy官方文档</a>的解释。</p><blockquote><p><strong>allowed_domains</strong><br>An optional list of strings containing domains that this spider is allowed to crawl. Requests for URLs not belonging to the domain names specified in this list (or their subdomains) won’t be followed if OffsiteMiddleware is enabled.</p></blockquote><p>如果设置进行url过滤,那么对于要新添加到爬取队列中的所有的url中必须包含allow_domains中的一个域名才可以，否则这个url就会被舍弃。</p><h2 id="设置-dont-filte-True">设置 dont_filte=True</h2><p>可以直接停止scrapy对于url的过滤。也就是在新生成的Request中添加 dont_filte=True，比如下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line"> yield Request(url=&apos;https://example.com&apos;, dont_filter=True, callback=self.parse2)</span><br><span class="line">def parse2(self, response):</span><br><span class="line"> pass</span><br></pre></td></tr></table></figure><p>看一下<a href="https://docs.scrapy.org/en/latest/topics/request-response.html" target="_blank" rel="noopener">Scrapy官方文档</a>的解释：</p><blockquote><p>dont_filter (boolean) – indicates that this request should not be filtered by the scheduler. This is used when you want to perform an identical request multiple times, to ignore the duplicates filter. Use it with care, or you will get into crawling loops. Default to False.</p></blockquote><p>这个方法就比较粗暴，就直接不对url进行过滤。那么也就是说对于所有的爬取到的url都会进行重新爬取，但是如果一旦有url是重复的，可能就会陷入循环。所以尽量不要采用这么暴力的方式。这也是scrapy默认将其设置为False的一个原因。</p><p>PS:一定要细心，我个人出现的问题是我想当然的设置了域名，然后真实网站的域名和我设置的域名差一个字母，所以最后就报错了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写爬虫的时候遇见了一个bug,报错信息为 Filtered offsite request domain[‘mydomain’],&lt;br&gt;
从网上找到了答案并成功解决了问题，特别记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
      <category term="bug" scheme="http://yoursite.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>priority_queue的简单使用</title>
    <link href="http://yoursite.com/2020/02/08/priority-queue%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/08/priority-queue的简单使用/</id>
    <published>2020-02-08T07:56:04.000Z</published>
    <updated>2020-02-08T08:00:08.516Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第十篇.<br>主要测试了priority_queue相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><p>优先队列，也是对容器的一个封装，形成的adapter,默认每次最先获得所有值中的最大值。<br>每次插入一个新元素或者pop出一个元素之后，剩下的元素都会重新排一次序。<br>可以改变compare函数使其变成最小堆，从而每次可以获得最小值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // 声明</span><br><span class="line">    priority_queue&lt;int&gt; pq; // 默认是最大堆，可以通过下面的方式声明为最大堆。</span><br><span class="line">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq1;</span><br><span class="line">    </span><br><span class="line">    // 也可以通过如下方式直接将一个容器内的所有元素装进priority_queue中。</span><br><span class="line">    vector&lt;int&gt; a = &#123;1,4,2,3&#125;;</span><br><span class="line">    priority_queue&lt;int&gt; pq2(less&lt;int&gt;(),a); // 最大堆</span><br><span class="line">    cout&lt;&lt;&quot;qp2.top():&quot;&lt;&lt;pq2.top()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">//    下面这种方式为什么不行？？此处存疑。</span><br><span class="line">//    priority_queue&lt;int&gt; pq3(greater&lt;int&gt;(),a); //最小堆</span><br><span class="line">//    cout&lt;&lt;pq3.top()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //下面针对pq进行操作演示</span><br><span class="line">    pq.push(2);</span><br><span class="line">    pq.push(1);</span><br><span class="line">    pq.emplace(3);</span><br><span class="line">    pq.emplace(4);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;pq.size()&quot;&lt;&lt;pq.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;pq.empty()&quot;&lt;&lt;pq.empty()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    pq.pop();</span><br><span class="line">    cout&lt;&lt;&quot;after pop,pq.size()&quot;&lt;&lt;pq.size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // 遍历: priority_queue默认是最大堆，每次的通过top()获得的元素就是最大值。</span><br><span class="line">    cout&lt;&lt;&quot;pq = &quot;;</span><br><span class="line">    while(!pq.empty())&#123;</span><br><span class="line">        cout&lt;&lt;pq.top()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果。</span><br><span class="line"> qp2.top():4</span><br><span class="line"> pq.size()4</span><br><span class="line"> pq.empty()0</span><br><span class="line"> after pop,pq.size()3</span><br><span class="line"> pq = 3    2    1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第十篇.&lt;br&gt;
主要测试了priority_queue相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Priority_queue" scheme="http://yoursite.com/tags/Priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>stack的简单使用</title>
    <link href="http://yoursite.com/2020/02/08/stack%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/08/stack的简单使用/</id>
    <published>2020-02-08T06:58:02.000Z</published>
    <updated>2020-02-08T07:04:26.641Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第九篇.<br>主要测试了stack相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><p>严格来讲，stack其实也不算是容器，它是在容器的基础上进行疯转从而具备后进先出(LIFO)特性的adapter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // 声明</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line">    stack&lt;int&gt; s1(&#123;1,2,3&#125;);</span><br><span class="line">    stack&lt;int&gt; s2(s1);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;s2= &quot;;</span><br><span class="line">     while(!s2.empty())&#123;</span><br><span class="line">         cout&lt;&lt;s2.top()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">         s2.pop();</span><br><span class="line">     &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //操作</span><br><span class="line">    cout&lt;&lt;&quot;s.empty(): &quot;&lt;&lt;s.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.size(): &quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    // 这里也需要注意一下，必须在确认stack中元素个数不为0的情况下，</span><br><span class="line">    // 才可以使用s.top()来获取栈顶元素，否则就会报错。</span><br><span class="line">    //cout&lt;&lt;&quot;s.top():&quot;&lt;&lt;s.top()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    s.push(1);</span><br><span class="line">    s.emplace(2);</span><br><span class="line">    cout&lt;&lt;&quot;after push2 s.size(): &quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push2 s.empty(): &quot;&lt;&lt;s.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push2 top element is\t&quot;&lt;&lt;s.top()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s.pop();</span><br><span class="line">    cout&lt;&lt;&quot;after pop(),s.size():&quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after pop(),s.top():&quot;&lt;&lt;s.top()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s.push(3);</span><br><span class="line">    s.push(4);</span><br><span class="line">    s.push(5);</span><br><span class="line">    // 遍历</span><br><span class="line">    cout&lt;&lt;&quot;after push 345,s= &quot;;</span><br><span class="line">    while(!s.empty())&#123;</span><br><span class="line">        cout&lt;&lt;s.top()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> s2= 3    2    1</span><br><span class="line"> s.empty(): 1</span><br><span class="line"> s.size(): 0</span><br><span class="line"> after push2 s.size(): 2</span><br><span class="line"> after push2 s.empty(): 0</span><br><span class="line"> after push2 top element is    2</span><br><span class="line"> after pop(),s.size():1</span><br><span class="line"> after pop(),s.top():1</span><br><span class="line"> after push 345,s= 5    4    3    1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第九篇.&lt;br&gt;
主要测试了stack相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>queue的简单使用</title>
    <link href="http://yoursite.com/2020/02/08/queue%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/08/queue的简单使用/</id>
    <published>2020-02-08T06:34:31.000Z</published>
    <updated>2020-02-08T06:38:54.733Z</updated>
    
    <content type="html"><![CDATA[<p>本文为c++容器系列第八篇.<br>主要测试了queue相关的方法，主要作为代码备份方便之后遗忘时查询。</p><a id="more"></a><p>准确来讲，queue并不是容器，而是在容器的基础上进行了一定封装的adapter.符合先进先出(FIFO)的特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // 声明</span><br><span class="line">    queue&lt;int&gt; q ;</span><br><span class="line">    queue&lt;int&gt; q1(&#123;1,2,3,4&#125;);</span><br><span class="line">    queue&lt;int&gt; q2(q1);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;q2: &quot;;</span><br><span class="line">    while(q2.size() != 0)&#123;</span><br><span class="line">         cout&lt;&lt;q2.front()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">         q2.pop();</span><br><span class="line">     &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // 其他操作。 如果队列为空，那么调用front和back的时候就会报错，</span><br><span class="line">    // 所以给我们的警示就是在通过front和back方法获取队列元素的时候，需要提前确定内部是存在对应的元素的。</span><br><span class="line">    //cout&lt;&lt;&quot;q.front():&quot;&lt;&lt;q.front()&lt;&lt;endl;</span><br><span class="line">    //cout&lt;&lt;&quot;q.back():&quot;&lt;&lt;q.back()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;q.empty():&quot;&lt;&lt;q.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;q.size():&quot;&lt;&lt;q.size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    q.push(1);</span><br><span class="line">    q.emplace(2);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;after push q.front():&quot;&lt;&lt;q.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push q.back():&quot;&lt;&lt;q.back()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push q.empty():&quot;&lt;&lt;q.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push q.size():&quot;&lt;&lt;q.size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    q.pop();</span><br><span class="line">    cout&lt;&lt;&quot;after pop(): &quot;;</span><br><span class="line">    while(q.size() != 0)&#123;</span><br><span class="line">        cout&lt;&lt;q.front()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果</span><br><span class="line"> q2: 1    2    3    4</span><br><span class="line"> q.empty():1</span><br><span class="line"> q.size():0</span><br><span class="line"> after push q.front():1</span><br><span class="line"> after push q.back():2</span><br><span class="line"> after push q.empty():0</span><br><span class="line"> after push q.size():2</span><br><span class="line"> after pop(): 2    Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为c++容器系列第八篇.&lt;br&gt;
主要测试了queue相关的方法，主要作为代码备份方便之后遗忘时查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
  </entry>
  
</feed>
