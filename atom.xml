<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingwen&#39;s blog</title>
  
  <subtitle>没有输出的输入是不完整的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-28T10:59:45.763Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李庆文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer-二叉搜索树与双向链表</title>
    <link href="http://yoursite.com/2020/01/28/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/01/28/剑指offer-二叉搜索树与双向链表/</id>
    <published>2020-01-28T03:55:29.000Z</published>
    <updated>2020-01-28T10:59:45.763Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十六篇。<br>主要知识点为二叉搜索树还有双向链表，这个题目个人感觉比较难，但是题目非常好。<br>值得我们认真且细致的去理解两者之间的关系，并将这个问题做出来。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>首先我们要明晰二叉搜索树和双向链表各自的特点。</li><li>然后在处理的时候可以将这个二叉搜索树分为三部分，左子树，根节点，右子树。我们的目标实际上就是将左子树转化成的双向链表链接上根节点再链接到右子树转化成的双向链表，所以自然就会想到用递归来实现。</li><li>最后就是细节的处理，要注意在链接左子树和根节点的时候，是将左子树的最大的节点和根节点链接起来，其实就是右下角的节点，<br>在链接根节点和右子树的时候，是将根节点和右子树中最小的节点进行链接，其实也就是最左下角的节点。</li></ul><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* Convert(TreeNode* pRootOfTree)&#123;</span><br><span class="line">         if(pRootOfTree==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">        if(pRootOfTree-&gt;left==NULL&amp;&amp;pRootOfTree-&gt;right==NULL)</span><br><span class="line">            return pRootOfTree;//如果是叶子结点则直接返回当前节点</span><br><span class="line">        TreeNode* left = Convert(pRootOfTree-&gt;left);//找到左子树最左端节点</span><br><span class="line">        TreeNode* curr = left;</span><br><span class="line">        </span><br><span class="line">        //找到左子树最右侧节点</span><br><span class="line">        while(curr!=NULL&amp;&amp;curr-&gt;right!=NULL)</span><br><span class="line">            curr=curr-&gt;right;</span><br><span class="line">        //连接根节点和左子树</span><br><span class="line">        if(curr!=NULL)&#123;</span><br><span class="line">            curr-&gt;right=pRootOfTree;</span><br><span class="line">            pRootOfTree-&gt;left = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //找到右子树最左端节点</span><br><span class="line">        TreeNode* right = Convert(pRootOfTree-&gt;right);</span><br><span class="line">        //连接根节点和右子树</span><br><span class="line">        if(right!=NULL)&#123;</span><br><span class="line">            pRootOfTree-&gt;right = right;</span><br><span class="line">            right-&gt;left = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        return left!=NULL?left:pRootOfTree;//返回最左边节点的位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十六篇。&lt;br&gt;主要知识点为二叉搜索树还有双向链表，这个题目个人感觉比较难，但是题目非常好。&lt;br&gt;值得我们认真且细致的去理解两者之间的关系，并将这个问题做出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinarySearchTree" scheme="http://yoursite.com/tags/BinarySearchTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-替换空格</title>
    <link href="http://yoursite.com/2020/01/28/%E5%89%91%E6%8C%87offer-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2020/01/28/剑指offer-替换空格/</id>
    <published>2020-01-28T03:21:42.000Z</published>
    <updated>2020-01-28T03:42:06.289Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十五篇。<br>主要知识点为字符串，平常就是一个调库可以解决的问题，这里要自己来实现。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>由于c++的char类型没有封装好的用来替换字符的方法，所以我们可以用python直接调用库来解决。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>其实可以再申请一段空间作为res，然后依次的遍历原来的char，碰到非空格就直接加到res中，碰到空格就加上“%20”，最后将原来的指针指向新的res即可。</p><h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>思路2存在一个问题就是需要再申请一段空间，其实可以直接在原来的char上进行操作。<br>按照正常情况，char字符串是以‘\0’为标识结束的，所以我们可以往后延长数据，延长（2*空格个数）个字节，因为本来的一个空格现在变成了‘20%’。<br>用两个指针分别指向原来的字符串和延长后字符串的最后一位，依次向前遍历，将非空格数据进行后移，将空格数据进行替换。<br>等到两个指针重合说明已经替换完成，从而这个问题就结束了。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    # s 源字符串 </span><br><span class="line">    # 直接调用替换函数 24ms 5868k</span><br><span class="line">    def replaceSpace(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        return s.replace(&apos; &apos;,&apos;%20&apos;)</span><br></pre></td></tr></table></figure><h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        int spaceNum = 0;</span><br><span class="line">        char *p = str;</span><br><span class="line">        while(*p != &apos;\0&apos;)&#123;</span><br><span class="line">            if(*p == &apos; &apos;)&#123;</span><br><span class="line">                spaceNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        char* last = p+spaceNum*2;</span><br><span class="line">        while(p != last)&#123;</span><br><span class="line">            if(*p == &apos; &apos;)&#123;</span><br><span class="line">                *(last--) = &apos;0&apos;;</span><br><span class="line">                *(last--) = &apos;2&apos;;</span><br><span class="line">                *(last--) = &apos;%&apos;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                *(last--) = *(p);</span><br><span class="line">            &#125;</span><br><span class="line">            p--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十五篇。&lt;br&gt;主要知识点为字符串，平常就是一个调库可以解决的问题，这里要自己来实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-剪绳子</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-剪绳子/</id>
    <published>2020-01-27T06:15:35.000Z</published>
    <updated>2020-01-27T08:45:58.079Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十四篇。<br>主要知识点为整数拆分，可以用贪心算法或者动态规划来解决。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="">题目描述</a></h2><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>输入描述:<br>输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）<br>输出描述:<br>输出答案。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1贪心算法"><a href="#思路1贪心算法" class="headerlink" title="思路1贪心算法"></a>思路1贪心算法</h3><p>设绳长为n，则有如下的结论</p><ol><li>n = 2,剪成2段，1*1 = 1</li><li>n = 3,剪成2段，1*2 = 2</li><li>n = 4,剪成2段，2*2 = 4</li><li>n = 5,剪成2段, 2*3 = 6</li><li>n = 6,剪成2段，3*3 = 9</li></ol><p>当n &gt; 5的时候3<em>(n-3)&gt; 2</em>(n-2)<br>所以答案就是尽可能的多剪长度为3的段,同时不要长度为1的段;如果有1，那就和3一起拼成一个4，切割成2和2。</p><h3 id="思路2动态规划"><a href="#思路2动态规划" class="headerlink" title="思路2动态规划"></a>思路2动态规划</h3><p>假设长度为n的绳子的结果为f(n)，如果我们切一刀,变为n-i和i两段，<br>那么f(n)应该等于f(n-i)*f(i),所以在计算后面的f值的时候，会用到前面的f值，<br>所以对前面的结果进行保存。自底向上的得到我们最后的解。<br>然后考虑到类似于2,3,4这种其实不切一刀要比切一刀的结果更大，所以在计算f(n)的时候要将i*(n-i)考虑在内，意味着说这段如果只切一刀（切完的两端不再进行进一步的切割，比如4就切成2和2，而不是f(2)*f(2)）会得到一个什么样的结果。<br>所以综合以上考虑,对于长为n的绳子，f(n) = max(f(n-i)*f(i),(n-i)*i), i的取值从1到n-1;</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h2 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cutRope(int number) &#123;</span><br><span class="line">        if(number == 2) return 1;</span><br><span class="line">        if(number == 3) return 2;</span><br><span class="line">        if(number == 4) return 4;</span><br><span class="line">        if(number == 5) return 6;</span><br><span class="line">        return 3*cutRope(number-3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h2 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cutRope(int number) &#123;</span><br><span class="line">        // 方法2 ：dp</span><br><span class="line">        vector&lt;int&gt; dp(number+1,0);</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2; i&lt;=number; i++)&#123;</span><br><span class="line">            for(int j = 1;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i] = max(dp[i],max(dp[i-j]*j,(i-j)*j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n^2),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十四篇。&lt;br&gt;主要知识点为整数拆分，可以用贪心算法或者动态规划来解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-机器人的运动范围</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-机器人的运动范围/</id>
    <published>2020-01-27T05:34:33.000Z</published>
    <updated>2020-01-27T05:49:12.498Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十三篇。<br>主要知识点为二维数组的遍历和元素的处理，这个题目和前面的那个矩阵中的路径题目是类似的。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题目和矩阵中寻找路径是类似的，<br>我们可以将这个题目要处理的数据范围抽象成为rows*cols的一个矩阵（或者第一象限），然后从一个结点开始出发，判断其四周的数据是不是合法的，类似于深度优先搜索对每个结点进行遍历。<br>同样的为了保证访问的数据不会重复，需要通过一个数组来保存每个数据之前是否已经被处理过。<br>这种处理方式比较经典，要多加锻炼。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int movingCount(int threshold, int rows, int cols)</span><br><span class="line">    &#123;</span><br><span class="line">        if(threshold &lt;= 0 || rows &lt;=0 || cols &lt;= 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bool *flags = new bool[rows*cols];</span><br><span class="line">        for(int i = 0; i &lt; rows * cols; i++)&#123;</span><br><span class="line">             flags[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(threshold,rows,cols,0,0,flags);</span><br><span class="line">    &#125;</span><br><span class="line">    int helper(int threshold,int rows,int cols,int i,int j,bool *flags)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if(checkToGo(threshold,rows,cols,i,j,flags))&#123;</span><br><span class="line">            flags[i*cols+j] = true;</span><br><span class="line">            res = 1+helper(threshold,rows,cols,i+1,j,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i-1,j,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i,j+1,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i,j-1,flags);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool checkToGo(int threshold,int rows,int cols,int i,int j,bool *flags)&#123;</span><br><span class="line">        if(i&gt;=0 &amp;&amp; i&lt;rows &amp;&amp; j&gt;=0 &amp;&amp; j&lt;cols &amp;&amp; checkThreshold(threshold,i,j) &amp;&amp; flags[i*cols+j] == false)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool checkThreshold(int threshold,int i,int j)&#123;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        while(i)&#123;</span><br><span class="line">            temp += i%10;</span><br><span class="line">            i = i/10;</span><br><span class="line">        &#125;</span><br><span class="line">        while(j)&#123;</span><br><span class="line">            temp += j%10;</span><br><span class="line">            j = j/10;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp&lt;=threshold;</span><br><span class="line">    &#125;</span><br><span class="line">    private:</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(cols*rows*lg(max(rows,cols)),空间复杂度为O(cols*rows)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十三篇。&lt;br&gt;主要知识点为二维数组的遍历和元素的处理，这个题目和前面的那个矩阵中的路径题目是类似的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-矩阵中的路径</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-矩阵中的路径/</id>
    <published>2020-01-27T04:55:04.000Z</published>
    <updated>2020-01-27T05:24:58.138Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十二篇。<br>主要知识点为数组，在矩阵中查找对应的字符串序列，类似于走迷宫或者找包围区间的题目。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历矩阵中的每个结点作为起始结点，然后从这个点开始向四周遍历，寻找字符串的下一个字符，如果字符串匹配到最后的结束标志’\0’,那就返回true,反之就返回false.<br>需要注意的一点是之前访问过的就不能访问了，所以需要找一个数组或者矩阵来标志这个节点之前是否已经访问过。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPath(char* matrix, int rows, int cols, char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(rows&lt;=0 || cols&lt;=0 || !str || !matrix) return false;</span><br><span class="line">        vector&lt;bool&gt; flags(rows*cols,0);</span><br><span class="line">        for(int i = 0; i &lt; rows; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; cols; j++)&#123;</span><br><span class="line">                if(helper(matrix,rows,cols,i,j,str,flags)) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool helper(char* matrix,int rows,int cols,int i,int j,char* str,vector&lt;bool&gt; flags)&#123;</span><br><span class="line">        if(*str == &apos;\0&apos;) return true;</span><br><span class="line">        if(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; rows &amp;&amp; j &lt; cols &amp;&amp; matrix[i*cols+j] == *str &amp;&amp; flags[i*cols+j] == false)&#123;</span><br><span class="line">            flags[i*cols+j] = true;</span><br><span class="line">            bool find = false;</span><br><span class="line">            find = helper(matrix,rows,cols,i,j+1,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i,j-1,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i+1,j,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i-1,j,str+1,flags);</span><br><span class="line">            if(find == false)&#123;</span><br><span class="line">                flags[i*cols+j] = false;</span><br><span class="line">            &#125;</span><br><span class="line">            return find;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(rows*cols*logn),空间复杂度为O(rows*cols)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十二篇。&lt;br&gt;主要知识点为数组，在矩阵中查找对应的字符串序列，类似于走迷宫或者找包围区间的题目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-滑动窗口的最大值</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-滑动窗口的最大值/</id>
    <published>2020-01-27T04:45:30.000Z</published>
    <updated>2020-01-27T04:52:29.790Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十一篇。<br>主要知识点为数组，题目看起来很炫酷，但是实际上就是一个给定区间的遍历找最大值而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接使用stl的max_element方法来获得对应区间的最大值。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>朴素算法，自己实现类似于max_element的方法。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">    &#123;</span><br><span class="line">       // 方法1: 直接使用stl中的max_element函数得到对应的窗口</span><br><span class="line">       if(num.size() == 0 || size &lt;=0 ||size&gt;num.size() ) return&#123;&#125;;</span><br><span class="line">       vector&lt;int&gt; res;</span><br><span class="line">       for(int i = 0; i&lt;=num.size()-size; i++)&#123;</span><br><span class="line">            int cur = *max_element(num.begin()+i,num.begin()+i+size);</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">    &#123;</span><br><span class="line">       // 方法2:朴素的方法依次向后比较窗口大小个元素</span><br><span class="line">       if(num.size() == 0 || size &lt;=0 ||size&gt;num.size() ) return&#123;&#125;;</span><br><span class="line">       vector&lt;int&gt; res;</span><br><span class="line">       for(int i = 0; i &lt;= num.size()-size; i++)&#123;</span><br><span class="line">           int temp = num[i];</span><br><span class="line">           for(int j = i+1; j&lt;i+size; j++)&#123;</span><br><span class="line">               if(num[j]&gt;temp)&#123;</span><br><span class="line">                   temp = num[j];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res.push_back(temp);</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十一篇。&lt;br&gt;主要知识点为数组，题目看起来很炫酷，但是实际上就是一个给定区间的遍历找最大值而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数据流中的中位数</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-数据流中的中位数/</id>
    <published>2020-01-27T02:44:08.000Z</published>
    <updated>2020-01-27T04:41:10.183Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六十篇。<br>主要知识点为数组，依旧是数组遍历然后分析找中位数，比较简单。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="">题目描述</a></h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>找一个数组，用来存储所有插入的数据，并保持数组内的数据有序（可以用插入排序的方式）。<br>在获得中间数的时候，可以通过奇偶直接从数组中获取处理并返回。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Insert(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        mvec.push_back(num);</span><br><span class="line">        len++;</span><br><span class="line">        //sort(mvec.begin(),mvec.end());</span><br><span class="line">        int i = len;</span><br><span class="line">        for( ; i &gt;= 1; i--)&#123;</span><br><span class="line">            if(num&lt;=mvec[i])&#123;</span><br><span class="line">                mvec[i] = mvec[i-1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mvec[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double GetMedian()</span><br><span class="line">    &#123; </span><br><span class="line">        int mindex = (len-1)/2;</span><br><span class="line">        if(len%2 == 0)&#123;</span><br><span class="line">            return ((mvec[mindex]+(double)mvec[mindex+1])/2);  </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (double)mvec[mindex];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; mvec;</span><br><span class="line">    int len = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六十篇。&lt;br&gt;主要知识点为数组，依旧是数组遍历然后分析找中位数，比较简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉搜索树的第k个结点</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-二叉搜索树的第k个结点/</id>
    <published>2020-01-27T01:50:33.000Z</published>
    <updated>2020-01-27T02:39:17.705Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十九篇。<br>主要知识点为二叉搜索树，二叉搜索树由于本身的特性，其中序遍历结果是有序的，<br>针对这一点，经常有题目出现。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。<br>例如（5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>中序遍历，将遍历的节点数据保存到一个数组中，然后返回数组的第K个节点即可。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>找一个全局计数器表示中序遍历到多少个节点，如果到第K个节点就可以直接返回当前结果了。如果没有到第K个节点，那么就返回NULL。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        if(!pRoot || k&lt;=0) return NULL; </span><br><span class="line">        inorder(pRoot,res);</span><br><span class="line">        if(res.size() &lt; k)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return res[k-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;TreeNode*&gt; res;</span><br><span class="line">    void inorder(TreeNode* root,vector&lt;TreeNode*&gt;&amp; res)&#123;</span><br><span class="line">        if(!root) return ;</span><br><span class="line">        if(root-&gt;left) inorder(root-&gt;left,res);</span><br><span class="line">        res.push_back(root);</span><br><span class="line">        if(root-&gt;right) inorder(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        if(!pRoot || k&lt;=0) return NULL; </span><br><span class="line">        inorder(pRoot,k);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    TreeNode* res = NULL;</span><br><span class="line">    void inorder(TreeNode* root,int k)&#123;</span><br><span class="line">        if(!root) return ;</span><br><span class="line">        if(root-&gt;left) inorder(root-&gt;left,k);</span><br><span class="line">        count++;</span><br><span class="line">        if(count == k)&#123;</span><br><span class="line">            res = root;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right) inorder(root-&gt;right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十九篇。&lt;br&gt;主要知识点为二叉搜索树，二叉搜索树由于本身的特性，其中序遍历结果是有序的，&lt;br&gt;针对这一点，经常有题目出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinarySearchTree" scheme="http://yoursite.com/tags/BinarySearchTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-序列化二叉树</title>
    <link href="http://yoursite.com/2020/01/27/%E5%89%91%E6%8C%87offer-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/27/剑指offer-序列化二叉树/</id>
    <published>2020-01-27T00:57:21.000Z</published>
    <updated>2020-01-27T01:39:38.236Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十八篇。<br>主要知识点为二叉树，针对于一棵给定的二叉树进行编码和解码。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先就是按照正常的先序遍历的思路对原来的二叉树进行存储，用,来隔离每个节点，用#来表示空节点。用递归的思路来进行编码。<br>解码的时候操作反过来，针对于之前编码生成的字符串，从头到尾依次遍历，通过<strong>,</strong>来对节点进行分离，通过#来判定当前节点为空，通过递归的方式生成之前的二叉树。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char* Serialize(TreeNode *root) &#123;   </span><br><span class="line">        if(!root) return &quot;#&quot;;</span><br><span class="line">        string r = to_string(root-&gt;val);</span><br><span class="line">        r.push_back(&apos;,&apos;);</span><br><span class="line">        char *left = Serialize(root-&gt;left);</span><br><span class="line">        char *right = Serialize(root-&gt;right);</span><br><span class="line">        char *ret = new char[strlen(left) + strlen(right) + r.size()];</span><br><span class="line">        strcpy(ret, r.c_str());</span><br><span class="line">        strcat(ret, left);</span><br><span class="line">        strcat(ret, right);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* Deserialize(char *str) &#123;</span><br><span class="line">        return decode(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    TreeNode* decode(char *&amp;str) &#123;</span><br><span class="line">        if(*str==&apos;#&apos;)&#123;</span><br><span class="line">            str++;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        int num = 0;</span><br><span class="line">        while(*str != &apos;,&apos;)</span><br><span class="line">            num = num*10 + (*(str++)-&apos;0&apos;);</span><br><span class="line">        str++;</span><br><span class="line">        TreeNode *root = new TreeNode(num);</span><br><span class="line">        root-&gt;left = decode(str);</span><br><span class="line">        root-&gt;right = decode(str);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十八篇。&lt;br&gt;主要知识点为二叉树，针对于一棵给定的二叉树进行编码和解码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-把二叉树打印成多行</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-把二叉树打印成多行/</id>
    <published>2020-01-26T10:58:48.000Z</published>
    <updated>2020-01-26T13:47:33.980Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十七篇。<br>主要知识点为二叉树，就是简单的层序遍历而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是简单的层序遍历。<br>用队列保存每一层的结果，方便遍历下一层，<br>同时本层的结果放到一个数组中进行存储。<br>所有层数组的集合就是我们的最终结果。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* root) &#123;</span><br><span class="line">            if(!root) return &#123;&#125;;</span><br><span class="line">            vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">            queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">            while(!q.empty())&#123;</span><br><span class="line">                vector&lt;int&gt; level;</span><br><span class="line">                for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                    auto a = q.front(); q.pop();</span><br><span class="line">                    level.push_back(a-&gt;val);</span><br><span class="line">                    if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                    if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(level);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十七篇。&lt;br&gt;主要知识点为二叉树，就是简单的层序遍历而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-按之字形顺序打印二叉树</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-按之字形顺序打印二叉树/</id>
    <published>2020-01-26T10:42:46.000Z</published>
    <updated>2020-01-26T10:57:29.949Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十六篇。<br>主要知识点为二叉树，就是层序遍历的变形而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>层序遍历的思路。<br>通过队列来保存每一层的节点，方便下一层的遍历,同时本层的结果要放在本层的数组中，<br>由于要之字形进行保存，也就是说奇数层和偶数层要分别处理，所以要记录层数,用于之后的判断。</p><ul><li>单数层添加的时候插入到本层数组的后面，实现从左到右依次添加的效果;</li><li>双数层添加的时候每次插入到数组的头部，实现类似从右往左添加的效果。</li></ul><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        int levelnum = 1;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; level;</span><br><span class="line">            for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                auto a = q.front(); q.pop();</span><br><span class="line">                if(levelnum%2 == 1)&#123;</span><br><span class="line">                   level.push_back(a-&gt;val);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                   level.insert(level.begin(),a-&gt;val);   </span><br><span class="line">                &#125;</span><br><span class="line">                if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">            levelnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十六篇。&lt;br&gt;主要知识点为二叉树，就是层序遍历的变形而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-对称的二叉树</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-对称的二叉树/</id>
    <published>2020-01-26T10:25:39.000Z</published>
    <updated>2020-01-26T10:41:28.309Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十五篇。<br>主要知识点为二叉树，就是简单的判断一棵树是不是对称二叉树。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>什么时候一棵树是对称的呢？<br>首先，根节点相同；<br>其次，如果左右子树都不存在，肯定是对称的；如果左右子树只存在一个，那么肯定是不对称的。<br>如果左右子树都存在，那么左子树是对称的，右子树也是对称的。<br>最后，通过辅助函数，递归调用，问题就可以得到解决。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetrical(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        return helper(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    bool helper(TreeNode* root1,TreeNode* root2)&#123;</span><br><span class="line">        if(!root1 &amp;&amp; !root2) return true;</span><br><span class="line">        if(!root1 || !root2) return false;</span><br><span class="line">        if(root1-&gt;val != root2-&gt;val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return helper(root1-&gt;left,root2-&gt;right) &amp;&amp; helper(root1-&gt;right,root2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十五篇。&lt;br&gt;主要知识点为二叉树，就是简单的判断一棵树是不是对称二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉树的下一个节点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-二叉树的下一个节点/</id>
    <published>2020-01-26T09:52:05.000Z</published>
    <updated>2020-01-26T10:24:39.244Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十四篇。<br>主要知识点为二叉树，查找二叉树中序遍历给定节点的下一个节点。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于给定的节点，</p><ol><li>如果存在右子树，那么给定节点中序遍历的下一个节点就是右子树的最左侧节点。</li><li>如果不存在右子树，那么就可能存在两种情况，<ol><li>当前节点是根节点的左子树，那么它中序遍历的下一个节点就是它的根节点。</li><li>当前节点是根节点的右子树，那么它中序遍历的下一个节点是当前所在左子树的根节点。</li></ol></li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeLinkNode *left;</span><br><span class="line">    struct TreeLinkNode *right;</span><br><span class="line">    struct TreeLinkNode *next;</span><br><span class="line">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeLinkNode* res;</span><br><span class="line">        // 当前节点存在右子树</span><br><span class="line">        if(pNode &amp;&amp; pNode-&gt;right)&#123;</span><br><span class="line">            TreeLinkNode* temp = pNode-&gt;right;</span><br><span class="line">            while(temp-&gt;left)&#123;</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = temp;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">         // 当前节点不存在右子树，</span><br><span class="line">           TreeLinkNode* par = pNode-&gt;next;</span><br><span class="line">           while(pNode-&gt;next &amp;&amp; par-&gt;right == pNode)&#123;</span><br><span class="line">               pNode = pNode-&gt;next;</span><br><span class="line">               par  = pNode-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           res = par;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十四篇。&lt;br&gt;主要知识点为二叉树，查找二叉树中序遍历给定节点的下一个节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-删除链表中重复的结点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-删除链表中重复的结点/</id>
    <published>2020-01-26T09:12:58.000Z</published>
    <updated>2020-01-26T09:49:24.987Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十三篇。<br>主要知识点为链表的遍历，去除重复元素。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>将整个链表进行遍历，通过map来保存每个节点出现的次数。之后再重建链表，链表结点的值仅仅对应于出现一次的元素。返回新链表即可。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>可以直接在原来的链表上进行操作，具体的思路如下：<br>首先在头节点之前建立一个帮助结点，帮助结点之后的就是我们真正的没有重复结点的链表。<br>然后我们从head结点开始向后遍历，如果碰到有相同元素，那么一直向后遍历，越过这些重复元素。如果元素值没有重复，那么就都向后遍历一个节点。直到遍历结束。</p><p>下面以1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5为例进行详细说明，<br>我们开始创建辅助节点将原来的链表变成-1-&gt;1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5,<br>然后有两个指针一个指针p指向之前的头节点1，一个指针last指向辅助节点-1，开始遍历。提醒一下，他们两个操作的可是同一个链表。</p><ol><li>1!=2,所以1不重复，所以p前移指向2，last前移指向1；</li><li>2!=3,所以2不重复，所以p前移指向3，last前移指向2；</li><li>3==3，所以3是重复的，这个时候p继续前移，直到指向第一个不是3的节点，也就是4，last的next指向4.（这样的话所有的3就已经被删除了）</li><li>4==4，所以4也是重复的，这个时候p继续前移，直到指向第一个不是4的节点，也就是5，last的next指向5，(这样的话所有的4就已经被删除了)</li><li>5已经没有后继节点了，所有结束。</li></ol><p>然后整个的链表就变成了-1-&gt;1-&gt;2-&gt;5,最后结果返回-1的next即可。<br>相比于前一种思路可以极大的提高空间同时提升效率。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>本题目的目标是1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5变成1-&gt;2-&gt;5，题目等同于<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">leetcode-83-RemoveDuplicatesfromSortedListII</a><br>但是也有类似的题目是从1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5变成1-&gt;2-&gt;3-&gt;4-&gt;5。比如<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">leetcode-82-RemoveDuplicatesfromSortedList</a></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* first = new ListNode(-1);</span><br><span class="line">        first-&gt;next = head;</span><br><span class="line">        ListNode* last = first;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">           if(p-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">               //如果有重复元素，那么就跳过。</span><br><span class="line">               int val = p-&gt;val;</span><br><span class="line">               while(p &amp;&amp; p-&gt;val == val)&#123;</span><br><span class="line">                   p = p-&gt;next;</span><br><span class="line">               &#125;   </span><br><span class="line">               //此时p指向不是之前相等值的第一个元素，但是不能保证这个值也不重复，</span><br><span class="line">               //所以此时继续进入到循环之中进行判断。</span><br><span class="line">               //通过last-&gt;next = p 删除了中间值为val的所有值。</span><br><span class="line">               last-&gt;next = p;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               // 如果不重复，那就直接链接到last上。p继续后移</span><br><span class="line">               last= p;</span><br><span class="line">               p = p-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        return first-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><h3 id="扩展代码"><a href="#扩展代码" class="headerlink" title="扩展代码"></a>扩展代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        // 去掉重复元素,重复元素保留一次</span><br><span class="line">        if(!head) return NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">            if(p-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十三篇。&lt;br&gt;主要知识点为链表的遍历，去除重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-链表中环的入口节点</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-链表中环的入口节点/</id>
    <published>2020-01-26T06:32:54.000Z</published>
    <updated>2020-01-26T09:11:24.060Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十二篇。<br>主要知识点为链表的遍历，同样的使用一个set就可以解决问题。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路非常清晰，从头开始遍历，遍历的时候先判断当前节点是否在set中，如果已经在，那么这个节点肯定就是那个入口节点。如果不在，继续向后遍历。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;ListNode*&gt; mset;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            if(mset.count(p)) return p;</span><br><span class="line">            mset.insert(p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十二篇。&lt;br&gt;主要知识点为链表的遍历，同样的使用一个set就可以解决问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-字符流中第一个不重复的字符</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-字符流中第一个不重复的字符/</id>
    <published>2020-01-26T06:26:41.000Z</published>
    <updated>2020-01-26T06:31:29.225Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十一篇。<br>主要知识点为字符串中每个字符的出现次数，同样的题目其实已经出现很多次了，相信大家都已经可以做到手到擒来了。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>输出描述:<br>如果当前字符流没有存在出现一次的字符，返回#字符。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于插入的每个字符都进行一次保存，然后对于每个字符出现的次数都可以通过map来保存出现次数，最后遍历一遍map找到第一个出现次数为1的字符就可以了。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string s = &quot;&quot;;</span><br><span class="line">    map&lt;char,int&gt; mmap;</span><br><span class="line">  //Insert one char from stringstream</span><br><span class="line">    void Insert(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">       s += ch;</span><br><span class="line">       if(mmap[ch])&#123;</span><br><span class="line">           mmap[ch]++;</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           mmap[ch] = 1;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //return the first appearence once char in current stringstream</span><br><span class="line">    char FirstAppearingOnce()</span><br><span class="line">    &#123;</span><br><span class="line">        for(char a:s)&#123;</span><br><span class="line">            if(mmap[a] == 1)</span><br><span class="line">               return a;</span><br><span class="line">        &#125;</span><br><span class="line">        return &apos;#&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十一篇。&lt;br&gt;主要知识点为字符串中每个字符的出现次数，同样的题目其实已经出现很多次了，相信大家都已经可以做到手到擒来了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-表示数值的字符串</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-表示数值的字符串/</id>
    <published>2020-01-26T06:11:42.000Z</published>
    <updated>2020-01-26T06:23:36.824Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五十篇。<br>主要知识点为字符串，重点在于细心，认真的去判断成为数值的条件，然后再去做题就比较快。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目主要要考虑以下的问题</p><ol><li>小数点，正负号，指数标志可能会出现多次的问题。解决方式是设置一个标志，用来记录它们之前是否已经出现。</li><li>直接以小数点或者指数标志或者正负号结尾：解决方式在每个条件结束的时候进行一次是否到结尾的判断</li><li>string以‘\0’为标志结束。可以用来结束循环。</li><li>非法字符的问题。 对于前面没有处理的其他的非法情况都直接返回false</li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumeric(char* string)</span><br><span class="line">    &#123;</span><br><span class="line">        if(string == NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 应对仅仅只有+或者-的情况</span><br><span class="line">        if(*string == &apos;+&apos; || *string == &apos;-&apos;)&#123;</span><br><span class="line">            string++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //标记小数点、整数部分、指数部分是否存在，</span><br><span class="line">        bool point = false, numint = false, nume = false;</span><br><span class="line">        while(*string != &apos;\0&apos;)&#123;</span><br><span class="line">            //处理小数</span><br><span class="line">            if(*string == &apos;.&apos;)&#123;</span><br><span class="line">                if( point || nume) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                string++;</span><br><span class="line">                point = true;</span><br><span class="line">                if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //处理科学计数法</span><br><span class="line">            else if(*string == &apos;E&apos; || *string == &apos;e&apos;)&#123;</span><br><span class="line">                if(numint == false || nume)&#123;</span><br><span class="line">                     return false;</span><br><span class="line">                &#125;</span><br><span class="line">                string++; </span><br><span class="line">                nume = true;</span><br><span class="line">                if(*string == &apos;+&apos; || *string == &apos;-&apos;)&#123;</span><br><span class="line">                    string++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //处理正常数据</span><br><span class="line">            else if(*string &gt;= &apos;0&apos; &amp;&amp; *string &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                numint = true;</span><br><span class="line">                string++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五十篇。&lt;br&gt;主要知识点为字符串，重点在于细心，认真的去判断成为数值的条件，然后再去做题就比较快。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-正则表达式匹配</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-正则表达式匹配/</id>
    <published>2020-01-26T05:50:50.000Z</published>
    <updated>2020-01-26T06:05:32.779Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十九篇。<br>这个题目比较难，甚至我觉得是整个剑指offer里面最难的一道题目了，<br>也是参考了网上的答案加上自己的理解来解决这道题目，no more talk, show you code!</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题目其实关注的点比较多，下面一个一个来说</p><ol><li>匹配串或者模式串为空的情况</li><li>字符串是以’\0’为标志结束的</li><li><strong>.</strong>的处理，可以表示任何一个字符,要注意此时匹配串是不是已经到了结尾</li><li><em>号的处理，由于</em>可以表示它前面的字符出现0次，1次，甚至多次，所以这个时候就会让模式串和匹配串进行不同的后续的比较。</li></ol><p>代码里面的注释写的非常清楚了，所以直接看代码吧。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool match(char* str, char* pattern)</span><br><span class="line">    &#123;</span><br><span class="line">        // 两者任意一个为空，则返回空。</span><br><span class="line">        if(str == NULL || pattern == NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return matchCore(str, pattern);</span><br><span class="line">     &#125;</span><br><span class="line">    //本部分以str = aaa 为例进行说明。</span><br><span class="line">    bool matchCore(char* str, char* pattern)&#123;</span><br><span class="line">        // 字符串和模式串都运行到了结尾，则匹配完成。返回true</span><br><span class="line">        if(*str == &apos;\0&apos; &amp;&amp; *pattern == &apos;\0&apos;)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 字符串没有到结尾，模式串到结尾了，则返回false</span><br><span class="line">        // 模式串没有到结尾，字符串到结尾了，则根据后续判断进行，需要对&apos;*&apos;做处理</span><br><span class="line">        if((*str != &apos;\0&apos; &amp;&amp; *pattern == &apos;\0&apos;))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果模式串的下一个字符是&apos;*&apos;，</span><br><span class="line">        if(*(pattern + 1) == &apos;*&apos;)&#123;</span><br><span class="line">            // 如果字符串和模式串相等，或者模式串是&apos;.&apos;，并且字符串没有到结尾，则继续匹配</span><br><span class="line">            if(*str == *pattern || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;))&#123;</span><br><span class="line">                // 可能存在三种情况。</span><br><span class="line">                // 1. *匹配前面字符0次， 如pattern = a*aaa</span><br><span class="line">                // 2. *匹配前面字符1次， 如pattern = a*aa</span><br><span class="line">                // 3. *匹配前面字符不止一次，如pattern = a*</span><br><span class="line">                return    // *匹配0次</span><br><span class="line">                    matchCore(str, pattern + 2)|| </span><br><span class="line">                          // *匹配1次</span><br><span class="line">                    matchCore(str + 1, pattern + 2) ||</span><br><span class="line">                          // *匹配不止1次</span><br><span class="line">                    matchCore(str + 1, pattern);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果字符串和模式串不相等，则跳过当前模式串的字符和&apos;*&apos;，进入新一轮的匹配</span><br><span class="line">            else&#123;</span><br><span class="line">                // 比如pattern = b*aaa</span><br><span class="line">                return matchCore(str, pattern + 2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果字符串和模式串相等，或者模式串是&apos;.&apos;，并且字符串没有到结尾，则继续匹配</span><br><span class="line">        if(*str == *pattern || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;))&#123;</span><br><span class="line">            return matchCore(str + 1, pattern + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十九篇。&lt;br&gt;这个题目比较难，甚至我觉得是整个剑指offer里面最难的一道题目了，&lt;br&gt;也是参考了网上的答案加上自己的理解来解决这道题目，no more talk, show you code!&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="hard" scheme="http://yoursite.com/tags/hard/"/>
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="正则表达" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-构建乘积数组</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-构建乘积数组/</id>
    <published>2020-01-26T03:37:35.000Z</published>
    <updated>2020-01-26T03:57:30.390Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十八篇。<br>主要知识点为数组，但是可以通过类似于矩阵的方式来进行性能的提升。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>暴力求解，双层循环，对每个结果进行单独的计算即可。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>其实我们在计算的时候可以发现很多计算是重复的，举例来说<br>1, 2, 3, 4, 5<br>计算第一个数字的时候是2*3*4*5,<br>计算第二个数字的时候是1*3*4*5,<br>计算第三个数字的时候是1*2*4*5,<br>计算第四个数字的时候是1*2*3*5,<br>计算第五个数字的时候是1*2*3*4。<br>这样就可以发现很多运算是重复的，比如第一行的3<em>4</em>5和第二行的3<em>4</em>5，<br>如何去掉重复的计算呢？就是我们接下来要考虑的问题。<br>同样以1, 2, 3, 4, 5为例来进行说明，我们可以发现同一行的计算可以分成左右两个部分。<br>计算第一个数字的时候是(1)*(2*3*4*5),<br>计算第二个数字的时候是(1*1)*(3*4*5),<br>计算第三个数字的时候是(1*2*1)*(4*5),<br>计算第四个数字的时候是(1*2*3*1)*(5),<br>计算第五个数字的时候是(1*2*3*4*1)()。<br>左面括号中下一行的数字是上一行的数字再乘上一个数字，<br>右面括号中上一行的数字是下一行的数组再乘上一个数字。<br>而最终的结果就是左边的括号乘上右面的括号。<br>非常优秀的思路。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        //  方法1: 双层遍历 O(n^2)</span><br><span class="line">        vector&lt;int&gt; res ;</span><br><span class="line">        int temp = 1;</span><br><span class="line">        for(int i  = 0;i&lt; A.size();i++)&#123;</span><br><span class="line">            for(int j = 0; j&lt; A.size(); j++)&#123;</span><br><span class="line">                if(i != j)&#123;</span><br><span class="line">                   temp = A[j] *temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            temp = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n^2),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        //  方法2: 巧妙运用一下前一次和后一次的关系</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;int&gt; left = &#123;1&#125;;</span><br><span class="line">        vector&lt;int&gt; right = &#123;1&#125;;</span><br><span class="line">        for(int i = 1; i &lt;= A.size()-1; i++)&#123;</span><br><span class="line">            left.push_back(left.back()* A[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for( int i = A.size()-2; i&gt;=0;i--)&#123;</span><br><span class="line">            right.insert(right.begin(),right.front()*A[i+1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i&lt;A.size();i++)&#123;</span><br><span class="line">            res.push_back(left[i] * right[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十八篇。&lt;br&gt;主要知识点为数组，但是可以通过类似于矩阵的方式来进行性能的提升。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数组中重复的数字</title>
    <link href="http://yoursite.com/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/01/26/剑指offer-数组中重复的数字/</id>
    <published>2020-01-26T03:22:44.000Z</published>
    <updated>2020-01-26T03:35:26.708Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四十七篇。<br>主要知识点为数组，找数组中重复的数字，类似于之前找出现一次或者两次的数字。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>找个set来存一下之前出现过的数据，然后在新遍历到数据的时候只要先看一下set中有没有存在，若存在，则直接返回即可，若不存在，将这个数据放到set中，继续向后遍历。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // Parameters:</span><br><span class="line">    //        numbers:     an array of integers</span><br><span class="line">    //        length:      the length of array numbers</span><br><span class="line">    //        duplication: (Output) the duplicated number in the array number</span><br><span class="line">    // Return value:       true if the input is valid, and there are some duplications in the array number</span><br><span class="line">    //                     otherwise false</span><br><span class="line">    bool duplicate(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; mset;</span><br><span class="line">        for(int i = 0; i&lt;length; i++)&#123;</span><br><span class="line">            if(!mset.count(numbers[i]))&#123;</span><br><span class="line">                mset.insert(numbers[i]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四十七篇。&lt;br&gt;主要知识点为数组，找数组中重复的数字，类似于之前找出现一次或者两次的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
</feed>
