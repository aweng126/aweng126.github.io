<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingwen&#39;s blog</title>
  
  <subtitle>没有输出的输入是不完整的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-18T14:55:26.357Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李庆文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer-跳台阶</title>
    <link href="http://yoursite.com/2020/01/18/%E5%89%91%E6%8C%87offer-%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>http://yoursite.com/2020/01/18/剑指offer-跳台阶/</id>
    <published>2020-01-18T14:45:04.000Z</published>
    <updated>2020-01-18T14:55:26.357Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第十篇。<br>主要内容其实还是斐波那契数列，依旧是上一篇斐波那契的思路，再复习一遍。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一级台阶： 1种跳法<br>第二级台阶： 2种跳法<br>第三级台阶： 3种跳法：要么从第一级跳2级跳上来，要么从第二级跳1级跳上来。<br>……<br>第n级台阶：f(n-2)+f(n-1): 要么从n-2级一次跳两级跳上来，那么从n-1级跳一级跳上来。<br>所以就是一个非常典型的斐波那契数列，最开始两项分别是1和2.</p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接用递归</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>用数组保存</p><h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>保存两个关键数字</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int num) &#123;</span><br><span class="line">        //方法1.递归解决</span><br><span class="line">         if(num == 1)&#123;</span><br><span class="line">           return 1;</span><br><span class="line">         &#125;else if( num == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">            return jumpFloor(num-1) + jumpFloor(num-2);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int num) &#123;</span><br><span class="line">        // 方法2: 数组保存</span><br><span class="line">         vector&lt;int&gt; a=&#123;0,1,2&#125;;</span><br><span class="line">         for(int i = 3; i&lt;=num; i++)&#123;</span><br><span class="line">             a.push_back(a[i-1]+a[i-2]);</span><br><span class="line">         &#125;</span><br><span class="line">         return a[num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int num) &#123;</span><br><span class="line">        // 方法3:</span><br><span class="line">        int first = 1, second = 2;</span><br><span class="line">        if(num == 1) return 1;</span><br><span class="line">        if(num == 2) return 2;</span><br><span class="line">        for(int i = 2; i &lt; num; i++)&#123;</span><br><span class="line">            int temp = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第十篇。&lt;br&gt;主要内容其实还是斐波那契数列，依旧是上一篇斐波那契的思路，再复习一遍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="斐波那契数列" scheme="http://yoursite.com/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-斐波那契数列</title>
    <link href="http://yoursite.com/2020/01/18/%E5%89%91%E6%8C%87offer-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://yoursite.com/2020/01/18/剑指offer-斐波那契数列/</id>
    <published>2020-01-18T14:27:29.000Z</published>
    <updated>2020-01-18T14:35:47.111Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第九篇。<br>主要知识点就是斐波那契数列，非常常见，非常经典。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接通过斐波那契的概念来进行计算，递归调用。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>我们知道递归调用的时候，很多部分都是重复计算的，所以我们可以建立一个数组进行保存。</p><h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>仔细想想，每次计算的时候，对我们真正有用的数据其实只有两个，所以我们只要能够保存好两个必要的数据即可依次的计算后面的数据，直到算出我们想要的数据。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        //方法1: 递归</span><br><span class="line">        if(n == 0)return 0;</span><br><span class="line">        if(n == 1) return 1;</span><br><span class="line">        return Fibonacci(n-1)+Fibonacci(n-2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        // 方法2: 数据保存在一个数组中</span><br><span class="line">        vector&lt;int&gt; a=&#123;0,1&#125;;</span><br><span class="line">        for(int i = 2;i&lt;=39;i++)&#123;</span><br><span class="line">            a.push_back(a[i-1]+a[i-2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return a[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        // 方法3. 通过2个常量来进行数据的保存。</span><br><span class="line">        int first = 0,second = 1;</span><br><span class="line">        if(n == 0) return first;</span><br><span class="line">        if(n == 1) return second;</span><br><span class="line">        for(int i = 1; i&lt;n; i++)&#123;</span><br><span class="line">            int temp = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(1)</p><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第九篇。&lt;br&gt;主要知识点就是斐波那契数列，非常常见，非常经典。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="斐波那契数列" scheme="http://yoursite.com/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-旋转数组的最小数字</title>
    <link href="http://yoursite.com/2020/01/18/%E5%89%91%E6%8C%87offer-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/01/18/剑指offer-旋转数组的最小数字/</id>
    <published>2020-01-18T13:58:32.000Z</published>
    <updated>2020-01-18T14:19:29.626Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第八篇。<br>其实就是找有序数组的最小元素，只是这个有序数组进行了一次旋转而已。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接使用stl中的min_element方法。一行代码就可以搞定。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>思路2是可以使用类似于二分的方法进行查找，我们在看这个数字经过旋转之后的变化，其实如果一旦二分，我们会发现那个最小元素其实会存在于某个区间内，而这个区间并不满足左边的元素要小于右边的元素。而另一个区间是满足的，因为本身的数组就是非递减排序的，所以只会有一个区间是出现降序排列。这样我们只要找到导致降序的点即可。<br>还有一个要注意的点，就是这个里面可能会有重复数据，所以可能出现中间元素和尾元素相等的情况，这个时候其实不能确定那个降序点在什么地方，所以这个时候就尾节点区间减少一个即可。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        return *min_element(rotateArray.begin(),rotateArray.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(rotateArray.size() == 0) return 0;</span><br><span class="line">        if(rotateArray.size() == 1) return rotateArray[0];</span><br><span class="line">        int l = 0,r = rotateArray.size()-1;</span><br><span class="line">        while(l&lt;r)&#123;</span><br><span class="line">            int mid = l + (r-l)/2;</span><br><span class="line">            if(rotateArray[mid]&lt;rotateArray[r])&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;else if(rotateArray[mid]&gt;rotateArray[r])&#123;</span><br><span class="line">                l = mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度好的情况为O(logn),不好的情况为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第八篇。&lt;br&gt;其实就是找有序数组的最小元素，只是这个有序数组进行了一次旋转而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-用两个栈实现队列</title>
    <link href="http://yoursite.com/2020/01/18/%E5%89%91%E6%8C%87offer-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/01/18/剑指offer-用两个栈实现队列/</id>
    <published>2020-01-18T13:33:47.000Z</published>
    <updated>2020-01-18T13:54:31.582Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第七篇。<br>目的就是用两个后进先出的栈来实现一个先进先出的队列，思路比较巧妙。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>思路1比较朴素，我们用一个栈来作为数据存储的栈A，然后另一个作为中转的栈B，当我们存数据的时候，我们将数据压入到栈A中，然后取数据的时候，我们将A的所有数据都压入到B中，这个时候B的出栈顺序也就是队列应该的出队列顺序了，所以此时将B的栈顶元素取出即可，然后再将B中的所有的数据重新压回A中，后续操作皆是如此。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>思路2其实是思路1的改进版，我们发现思路1在将数据取出之后，又把所有数据压回A栈，这样就会有很大的浪费，这里其实只要加一层判断，当往外取数据的时候，只要B栈不为空，就直接从B栈出栈栈顶元素即可，如果B栈为空，那么将A栈的数据全部压入到B栈中。从而省去中间多余的数据的来回压入操作。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">      while(!stack1.empty())&#123;</span><br><span class="line">           stack2.push(stack1.top());</span><br><span class="line">           stack1.pop();</span><br><span class="line">       &#125;</span><br><span class="line">      int res =  stack2.top();</span><br><span class="line">      stack2.pop();</span><br><span class="line">      while(!stack2.empty())&#123;</span><br><span class="line">           stack1.push(stack2.top());</span><br><span class="line">           stack2.pop();</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n^2),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">      if(stack2.empty())&#123;</span><br><span class="line">          while(!stack1.empty())&#123;</span><br><span class="line">              stack2.push(stack1.top());</span><br><span class="line">              stack1.pop();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      int res = stack2.top(); stack2.pop();</span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第七篇。&lt;br&gt;目的就是用两个后进先出的栈来实现一个先进先出的队列，思路比较巧妙。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-重建二叉树</title>
    <link href="http://yoursite.com/2020/01/18/%E5%89%91%E6%8C%87offer-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/01/18/剑指offer-重建二叉树/</id>
    <published>2020-01-18T13:13:32.000Z</published>
    <updated>2020-01-18T13:31:04.278Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第六篇。<br>主要就是根据二叉树遍历的前序遍历和中序遍历重新构造出原始的二叉树。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>前序遍历的顺序是 根节点，左子树，右子树。<br>中序遍历的顺序是 左子树，根节点，右子树。<br>所以我们可以发现，前序遍历的第一个节点就是根节点，然后我们在中序遍历中找到这个根节点，那么这个根节点之前的就是左子树的中序，根节点之后的就是右子树的中序，然后可以根据左子树的个数，在前序遍历中将左子树和右子树进行分离，而分离的结果可以用来构建左子树和右子树。</p><p>下面以题目中的数据为例进行详细说明</p><ol><li>首先根据前序遍历，可以知道当前的根节点为1。</li><li>在中序遍历中寻找节点1， 然后1之前的节点[4,7,2]就是当前树的左子树的中序遍历，1之后的节点[5,3,8,6]就是当前树的右子树的中序遍历。</li><li>在前序遍历中根据左子树的节点个数找到对应的左子树的前序遍历[2,4,7],和对应的右子树的前序遍历【3，5，6，8】。</li><li>同样的操作可以继续针对左子树和右子树，从而把整个的二叉树构建出来。</li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">            return helper(pre,0,pre.size()-1,vin,0,vin.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* helper(vector&lt;int&gt; pre,int pstart,int pend,vector&lt;int&gt; vin,int vstart,int vend)&#123;</span><br><span class="line">        if(vstart &gt; vend) return NULL;</span><br><span class="line">        int root = pre[pstart];</span><br><span class="line">        TreeNode* temp = new TreeNode(root);</span><br><span class="line">        </span><br><span class="line">        auto a = find(vin.begin(),vin.end(),root);</span><br><span class="line">        int index = distance(vin.begin(),a);</span><br><span class="line">        int lnum = index - vstart; //左子树</span><br><span class="line">        temp -&gt; left = helper(pre,pstart+1,pstart+lnum,vin,vstart,index-1);</span><br><span class="line">        temp -&gt; right = helper(pre,pstart+1+lnum,pend,vin,index+1,vend);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>类似的题目还有根据中序和后续进行重建二叉树，道理类似，只是根节点变成了后续遍历的最后一个节点。<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第六篇。&lt;br&gt;主要就是根据二叉树遍历的前序遍历和中序遍历重新构造出原始的二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-从尾到头打印链表</title>
    <link href="http://yoursite.com/2020/01/17/%E5%89%91%E6%8C%87offer-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/01/17/剑指offer-从尾到头打印链表/</id>
    <published>2020-01-17T13:34:03.000Z</published>
    <updated>2020-01-17T13:55:37.946Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第五篇。<br>题目要求就是打印链表，属于很常见的问题，但是因为题目要求从尾到头打印链表，所以又生出了一些波折。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>从头到尾遍历这个链表，然后将得到的值插入用于保存结果的vector的初始位置。<br>这个方法很容易能够想到，但是性能其实不是很好，就是因为在vector开头插入元素的时候，需要将这个vector中的所有元素向后移动一位，所以复杂度就会比较高，更多详细的解释可以看之后的关于字符串替换的那个题目。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>从头到尾遍历这个链表，将遍历得到的值依次插入到用于保存结果的vector的后面，最后再反转整个vector。</p><h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>从头到尾遍历这个链表，将数据压入到对应的栈中，然后利用栈的先进后出的特性，将所有结果出栈，以后插入用于保存结果的vector后面即可。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        // 思路1: 遍历的时候前面插入结果</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            res.insert(res.begin(),p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n^2),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        // 思路2: 遍历的时候后插，然后返回reverse的结果。 4ms 480k</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)</p><h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        // 思路3: 通过栈先进后出的特性来实现链表的从尾到头遍历 3ms 460k</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        stack&lt;int&gt; mstack;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            mstack.push(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(mstack.size() != 0)&#123;</span><br><span class="line">            res.push_back(mstack.top());</span><br><span class="line">            mstack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第五篇。&lt;br&gt;题目要求就是打印链表，属于很常见的问题，但是因为题目要求从尾到头打印链表，所以又生出了一些波折。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-最小的K个数</title>
    <link href="http://yoursite.com/2020/01/17/%E5%89%91%E6%8C%87offer-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/17/剑指offer-最小的K个数/</id>
    <published>2020-01-17T13:18:27.000Z</published>
    <updated>2020-01-17T13:24:21.318Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第四篇。<br>本题比较常见，而且思路也非常清晰，一个是排序，一个用最小堆。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接从小到大将所有所有数字进行排序，然后取前K个即可。</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>把所有的数据进行处理构造最小堆，然后取出前K个返回即可。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        if(k&gt;input.size()) return &#123;&#125;;</span><br><span class="line">        sort(input.begin(),input.end());</span><br><span class="line">        return vector&lt;int&gt;(input.begin(),input.begin()+k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(nlogn),空间复杂度为O(n)</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        if(k&gt;input.size()) return &#123;&#125;;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</span><br><span class="line">        for(auto a:input)&#123;</span><br><span class="line">            q.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        while(k&gt;0)&#123;</span><br><span class="line">           res.push_back(q.top());</span><br><span class="line">           q.pop();</span><br><span class="line">           k--;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第四篇。&lt;br&gt;本题比较常见，而且思路也非常清晰，一个是排序，一个用最小堆。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="最小堆" scheme="http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-整数中1出现的次数</title>
    <link href="http://yoursite.com/2020/01/17/%E5%89%91%E6%8C%87offer-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/17/剑指offer-整数中1出现的次数/</id>
    <published>2020-01-17T12:41:54.000Z</published>
    <updated>2020-01-17T13:10:38.128Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指 offer 系列第三篇。<br>核心能力是基于数学知识来找数字存在的规律。<br>这个问题给我的重要启示是将问题普遍化与自动化，是我们作为一个计算机行业从业者应该要做的事，也是让我们所有人受益无穷的事。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>求出1到13的整数中1出现的次数,并算出100到1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1:"></a>思路1:</h3><p>将1-n的每个数通过取余数来计算每一位是否为1，然后找个计数器来进行统计</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2:"></a>思路2:</h3><p>通过分析每个位置上1出现的规律来进行规律性的查找。下面以数字32456然后计算百位上1的个数来进行演示。</p><ol><li>首先将原来的数据分为2部分，a= 32456/100 = 324, b=32456%100 = 56. </li><li>这里百位上为4，所以他有完整的33个100位1，也就是(a/10+1)个100，推广一下，我们发现其实任何大于等于2的数字都会有这个规律。</li><li>如果这里百位上为0.即32056，则它有完整的32个100，也就是（a/10)个100。</li><li>如果这里百位上位1，即32156，则他有完整的32个100，同时会有32100-32156中57个百位上的1.也就是(a/10)个100，然后加上(b+1)个1.<br>其他位可以同理得到计算结果。从而问题得到了解决。</li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        // 方法1: 暴力求解。计算每一个数中每一位是不是1进行求和。</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 1;  i &lt;= n; i++)&#123;</span><br><span class="line">           int temp = i;</span><br><span class="line">            while(temp)&#123;</span><br><span class="line">                if(temp%10 == 1)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp/10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(nlgn),空间复杂度为O(1);</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(long i = 1; i&lt;= n; i*=10)&#123;</span><br><span class="line">            int a = n/i, b = n%i;</span><br><span class="line">            if(a%10 == 0)&#123;</span><br><span class="line">                res += (a/10)*i;</span><br><span class="line">            &#125;else if( a%10 == 1)&#123;</span><br><span class="line">                res += (a/10)*i + (b+1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res += (a/10+1)*i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(lgn),空间复杂度为O(1);<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指 offer 系列第三篇。&lt;br&gt;核心能力是基于数学知识来找数字存在的规律。&lt;br&gt;这个问题给我的重要启示是将问题普遍化与自动化，是我们作为一个计算机行业从业者应该要做的事，也是让我们所有人受益无穷的事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-求1+2+……+n</title>
    <link href="http://yoursite.com/2020/01/16/%E5%89%91%E6%8C%87offer-%E6%B1%821-2-%E2%80%A6%E2%80%A6-n/"/>
    <id>http://yoursite.com/2020/01/16/剑指offer-求1-2-……-n/</id>
    <published>2020-01-16T08:27:19.000Z</published>
    <updated>2020-01-16T08:58:25.465Z</updated>
    
    <content type="html"><![CDATA[<p>本文为剑指offer系列第二篇。<br>个人感觉属于奇淫巧技，但是是真的很巧妙，有利于打破思维定势。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=11200&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路1: 其实可以调用库函数<br>思路2: 可以使用 &amp;&amp; 和 || 的熔断机制。<br>思路3：使用sizeof函数和右移操作。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="朴素思想代码"><a href="#朴素思想代码" class="headerlink" title="朴素思想代码"></a>朴素思想代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        return (1+n)*n/2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        return fma(fma(n,n+1,0),0.5,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma" target="_blank" rel="noopener">fma</a>(x,y,z)函数作用是返回x*y+z. 我们让z为0,就变成了单纯的加法。</p><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        int sum  = n;</span><br><span class="line">        bool b = (n&gt;0) &amp;&amp; (sum += Sum_Solution(n-1))&gt;0;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        char a[n][n+1];</span><br><span class="line">        return sizeof(a)&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为sizeof()函数可以用来计算对象空间大小，每个char是1个字节，所以对于大小为n<em>(n+1)的二维数组而言，空间就是n</em>(n+1). 结果右移一位等同于除以2.<br>由此我们可以推广到其他的数据类型上，比如int,每个int是4个字节，所以要在原来的基础上右移3位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">       int a[n][n+1];</span><br><span class="line">       return sizeof(a)&gt;&gt;3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为剑指offer系列第二篇。&lt;br&gt;个人感觉属于奇淫巧技，但是是真的很巧妙，有利于打破思维定势。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="智力题" scheme="http://yoursite.com/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二维数组中的查找</title>
    <link href="http://yoursite.com/2020/01/16/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/01/16/剑指offer-二维数组中的查找/</id>
    <published>2020-01-16T07:58:41.000Z</published>
    <updated>2020-01-16T08:21:23.001Z</updated>
    
    <content type="html"><![CDATA[<p>本文属于剑指offer系列第一题。<br>本题目的关键点在于找到一个非常棒的问题入手点，然后这个题目就已经解决了一半。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路1: 双层for循环，肯定能解决，但是复杂度为O(n^2),而且没有充分利用行列有序这个条件。<br>思路2: 我们从右上角开始查找，往左下角找。<br>    如果当前位置的元素大于目标元素，那么肯定在下一行。<br>    如果当前位置的元素小于目标元素，肯定在本元素的左侧。<br>    如果当前位置的元素等于目标元素，那么返回即可。</p><h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><p>题目从右上角入手开始查找元素非常有效且巧妙。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">       int i = 0;</span><br><span class="line">       int j = array[0].size()-1;</span><br><span class="line">       while(i &lt; array.size() &amp;&amp; j&gt;= 0)&#123;</span><br><span class="line">           if(array[i][j] == target)&#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;else if(array[i][j] &lt; target)&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度是O(m+n)，空间复杂度O(m*n) m为行数，n为列数。<br>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文属于剑指offer系列第一题。&lt;br&gt;本题目的关键点在于找到一个非常棒的问题入手点，然后这个题目就已经解决了一半。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="Codinginterviews" scheme="http://yoursite.com/tags/Codinginterviews/"/>
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>common-commands</title>
    <link href="http://yoursite.com/2020/01/07/common-commands/"/>
    <id>http://yoursite.com/2020/01/07/common-commands/</id>
    <published>2020-01-07T04:10:01.000Z</published>
    <updated>2020-01-07T04:16:07.628Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章用于记录平时常用的、可以大幅度提高效率的一些命令和快捷键，方便之后查看与使用，不定期更新。</p><a id="more"></a><h2 id="mac相关"><a href="#mac相关" class="headerlink" title="mac相关"></a>mac相关</h2><h3 id="mac命令行下打开图片"><a href="#mac命令行下打开图片" class="headerlink" title="mac命令行下打开图片"></a>mac命令行下打开图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open a.jpg</span><br></pre></td></tr></table></figure><p>打开文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open foldname</span><br></pre></td></tr></table></figure><p>打开当前文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open .</span><br></pre></td></tr></table></figure><h2 id="Chrome相关（important！！）"><a href="#Chrome相关（important！！）" class="headerlink" title="Chrome相关（important！！）"></a>Chrome相关（important！！）</h2><h3 id="新开一个标签页"><a href="#新开一个标签页" class="headerlink" title="新开一个标签页"></a>新开一个标签页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command + T</span><br></pre></td></tr></table></figure><h3 id="新开一个搜索窗口"><a href="#新开一个搜索窗口" class="headerlink" title="新开一个搜索窗口"></a>新开一个搜索窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command + N //正常窗口</span><br><span class="line">command + shift + N //无痕搜索窗口</span><br></pre></td></tr></table></figure><h3 id="切换标签页"><a href="#切换标签页" class="headerlink" title="切换标签页"></a>切换标签页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl + tab //下一个标签页</span><br><span class="line">ctrl + shift + tab //上一个标签页</span><br></pre></td></tr></table></figure><h3 id="打开刚关掉的标签页"><a href="#打开刚关掉的标签页" class="headerlink" title="打开刚关掉的标签页"></a>打开刚关掉的标签页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command + shift + T</span><br></pre></td></tr></table></figure><h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><h3 id="查看电脑核数"><a href="#查看电脑核数" class="headerlink" title="查看电脑核数"></a>查看电脑核数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo |grep &quot;processor&quot;| wc -l</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章用于记录平时常用的、可以大幅度提高效率的一些命令和快捷键，方便之后查看与使用，不定期更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="快捷键" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
      <category term="常用命令" scheme="http://yoursite.com/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>为什么c++比java运行的速度快</title>
    <link href="http://yoursite.com/2019/12/10/%E4%B8%BA%E4%BB%80%E4%B9%88c-%E6%AF%94java%E8%BF%90%E8%A1%8C%E7%9A%84%E9%80%9F%E5%BA%A6%E5%BF%AB/"/>
    <id>http://yoursite.com/2019/12/10/为什么c-比java运行的速度快/</id>
    <published>2019-12-10T03:46:49.000Z</published>
    <updated>2019-12-10T04:01:51.188Z</updated>
    
    <content type="html"><![CDATA[<p>最近和同学讨论算法题目的时候，突然讲到为什么java的速度比c++慢，当时一知半解，雾里看花。<br>于是回来之后查了一下资料，整理一下放在这里，方便以后查看。<br>暂时理解到这个程度，如果以后有新的理解再做补充。</p><a id="more"></a><h2 id="明确原则"><a href="#明确原则" class="headerlink" title="明确原则"></a>明确原则</h2><p>首先，我们要明确一个放之世界皆准的原则:</p><blockquote><p>在资源一定的情况下，鱼与熊掌不可得兼。</p></blockquote><p>在程序运行方面，也就是说效率和便捷性往往不能同时满足。</p><p>c++ 和java的比较就是一个很典型的例子。java的抽象层级要比c++高一点，很多情况下java语言已经替我们做出了选择（可能是考虑了全局的程序性能之后得到的最优解），所以用起来就比较方便，但是这就有可能放弃了对于某些特定问题的更优的选择（可能他们仅仅在某几类问题上性能优秀，但是全局所有问题来看不是那么理想）也就在一定程度上损失了效率。</p><p>比如我们在使用java语言的时候可以直接通过obj.method()这种方式进行调用，它默认传递的都是引用。但是我们如果使用的是c++，那么就需要自己来确定我们的方法参数传的是指针还是引用，根据不同的选择在方法内部也有不同的使用方式。</p><h2 id="原因浅析"><a href="#原因浅析" class="headerlink" title="原因浅析"></a>原因浅析</h2><h3 id="编译过程不一样"><a href="#编译过程不一样" class="headerlink" title="编译过程不一样"></a>编译过程不一样</h3><p>在前面我们已经介绍过c++ 的编译过程，g++编译器可以直接将我们的源码编译成为机器可以执行的二进制代码（机器指令的集合），从而直接执行。</p><p>而对于java语言，java编译器会将java源码解析成字节码（独立于CPU架构，cpu不认识），然后字节码会被JVM加载然后再编译成当前cpu架构所对应的二进制代码（机器指令的集合）然后再执行。</p><p>简而言之，java在源码与机器指令之间又加了一层字节码的处理，这样可以保证在不同的机器上运行，但是相比于c++直接编译到机器指令来讲就会慢很多。</p><h3 id="对象的创建不同"><a href="#对象的创建不同" class="headerlink" title="对象的创建不同"></a>对象的创建不同</h3><p>在java中一切皆对象（这里忽略基本数据类型的情况），而对象的创建是通过new来实现的，也就是说对象本身都是保存在堆内存中的，而栈内存中仅仅保存了一个对象的引用。这样在获得对象的时候实际上可以认为是间接寻址，速度就会比较慢。</p><p>而在c++ 中，很多局部变量和对象的创建都是保存在栈中的，可以直接访问，所以效率就会很高。</p><h3 id="检查机制不同"><a href="#检查机制不同" class="headerlink" title="检查机制不同"></a>检查机制不同</h3><p>java虚拟机本身在运行时会对程序进行很多的检查，比如说检查数组越界，检查类型是否错误，检查是否空指针，检查对象是否需要回收(JVM)等等，比较充分的保证了java程序的安全性和稳定性，但是也浪费了检查的时间。</p><p>但是在c++程序中，这些检查都是需要程序员自己进行检查判断和处理的，如果程序员不写，那就硬着头皮执行，所以效率会很高，但是安全性和稳定性会有一定的损失。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.iteye.com/blog/leowzy-819206" target="_blank" rel="noopener">java运行速度比C++慢的原因</a></li><li><a href="https://www.zhihu.com/question/22050405" target="_blank" rel="noopener">知乎-为什么说 Java 比 C / C++ 慢？</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近和同学讨论算法题目的时候，突然讲到为什么java的速度比c++慢，当时一知半解，雾里看花。&lt;br&gt;于是回来之后查了一下资料，整理一下放在这里，方便以后查看。&lt;br&gt;暂时理解到这个程度，如果以后有新的理解再做补充。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Why" scheme="http://yoursite.com/tags/Why/"/>
    
  </entry>
  
  <entry>
    <title>make命令与MakeFile文件</title>
    <link href="http://yoursite.com/2019/12/05/make%E5%91%BD%E4%BB%A4%E4%B8%8EMakeFile%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/12/05/make命令与MakeFile文件/</id>
    <published>2019-12-05T14:26:08.000Z</published>
    <updated>2019-12-05T14:36:03.277Z</updated>
    
    <content type="html"><![CDATA[<p>前面三篇文章主要讲述了c++的编译过程，本篇文章主要讲述用Makefile文件来定义编译过程，用make命令来对项目进行构建，从而项目在编译过程中存在的各种依赖等可以程序化生成并保持最新版本，一次编写，永久受益。</p><a id="more"></a><h2 id="make与Makefile是什么"><a href="#make与Makefile是什么" class="headerlink" title="make与Makefile是什么"></a>make与Makefile是什么</h2><h3 id="make命令"><a href="#make命令" class="headerlink" title="make命令"></a>make命令</h3><p>源代码变成可执行文件的过程，叫做编译（compile）；而对一整个项目而言，先编译这个文件还是先编译另外一个文件的过程叫做构建（build），make命令是一个GNU组织提供的一个构建工具，诞生于1977年，起初主要应用于c语言的项目，但是实际上，任何只要有某个文件有变化就要重新构建的项目，就可以用make来进行构建。</p><h3 id="Makefile文件"><a href="#Makefile文件" class="headerlink" title="Makefile文件"></a>Makefile文件</h3><p>make是一个构建的命令，而具体的规则都是写在MakeFile文件中的。</p><h2 id="如何编写makefile文件"><a href="#如何编写makefile文件" class="headerlink" title="如何编写makefile文件"></a>如何编写makefile文件</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Makefile文件由一系列的规则（rules）构成，每条规则的形式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class="line">[tab] &lt;commands&gt;</span><br></pre></td></tr></table></figure><p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p><p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。</p><p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。</p><h3 id="目标-target"><a href="#目标-target" class="headerlink" title="目标(target)"></a>目标(target)</h3><ol><li>目标指的是具体要生成的文件名字,也可以是文件的列表。</li><li>目标也可以是某个操作的名字，这称作“伪目标”（phony target）</li></ol><h3 id="前置条件-prerequisites"><a href="#前置条件-prerequisites" class="headerlink" title="前置条件(prerequisites)"></a>前置条件(prerequisites)</h3><ol><li>前置条件通常是一组文件名，中间用空格分隔。</li><li>前置条件指定了“目标”是否要重新构建的判断标准：只要有一个前置文件不存在，或者有过更新，那么目标就需要重新构建。</li></ol><h3 id="命令-commands"><a href="#命令-commands" class="headerlink" title="命令(commands)"></a>命令(commands)</h3><ol><li>命令表示如何构建或者更新目标文件，由一行或者多行的shell命令组成，他是构成“目标”的具体指令，他的运行结果通常就是生成目标文件。</li><li>每行命令之前必须有一个tab键。</li><li>需要注意，每行命令在一个单独的shell中执行，这些shell没有独立关系，如果需要，可以在换行符前加反斜杠转义。</li></ol><h2 id="如何使用make命令"><a href="#如何使用make命令" class="headerlink" title="如何使用make命令"></a>如何使用make命令</h2><h3 id="有目标无条件"><a href="#有目标无条件" class="headerlink" title="有目标无条件"></a>有目标无条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    echo &apos;this is the a.txt&apos; &gt; a.txt</span><br></pre></td></tr></table></figure><p>解释：目标是创建a.txt, 没有前置条件。具体的执行命令是将“this is the a.txt”这个字符串写入到a.txt中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make t.txt //执行Makefile文件  </span><br><span class="line">cat a.txt //查看a.txt文件内容，发现就是this is the a.txt。</span><br></pre></td></tr></table></figure><h3 id="有目标有条件"><a href="#有目标有条件" class="headerlink" title="有目标有条件"></a>有目标有条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.txt : a.txt</span><br><span class="line">    cat a.txt &gt; b.txt</span><br></pre></td></tr></table></figure><p>解释：目标是创建b.txt，前置条件是要有a.txt文件，具体命令是将a.txt的内容输出到b.txt中去。</p><h3 id="伪目标无前置条件"><a href="#伪目标无前置条件" class="headerlink" title="伪目标无前置条件"></a>伪目标无前置条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br></pre></td></tr></table></figure><p>解释：目标是clean，没有前置条件，具体命令是将所有的txt文件删除。<br>这里要说明一下，如果当前目录下也有一个叫做clean的文件，那么上述命令便不会执行了，所以我们可以声明这个命令是一个“伪目标”,也就是说变成了如下的样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br></pre></td></tr></table></figure><h3 id="阶段小结"><a href="#阶段小结" class="headerlink" title="阶段小结"></a>阶段小结</h3><p>按照前面部分的介绍，我们可以得到如下内容的Makefile文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    echo &apos;this is the a.txt&apos; &gt; a.txt</span><br><span class="line"></span><br><span class="line">b.txt : a.txt</span><br><span class="line">    cat a.txt &gt; b.txt</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br></pre></td></tr></table></figure><p>其实这个时候我们如果直接执行make命令，那么会默认执行第一条规则，也就是说，对于上面的Makefile文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make a.txt</span><br></pre></td></tr></table></figure><p>是等价的。</p><h3 id="前置条件不符"><a href="#前置条件不符" class="headerlink" title="前置条件不符"></a>前置条件不符</h3><p>还是在之前的Makefile的基础上继续修改。这个时候我们想创建c.txt,但是我们当前没有d.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.txt : d.txt</span><br><span class="line">    echo &apos;test no prerequists with c.txt&apos; &gt;c.txt</span><br></pre></td></tr></table></figure><p>这个时候执行make c.txt命令，肯定会报错，报错信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: *** No rule to make target `d.txt&apos;, needed by `c.txt&apos;.  Stop.</span><br></pre></td></tr></table></figure><h2 id="MakeFile语法"><a href="#MakeFile语法" class="headerlink" title="MakeFile语法"></a>MakeFile语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 这是注释</span><br><span class="line">.PHONY :print</span><br><span class="line">print :</span><br><span class="line">    # 这也是注释</span><br><span class="line">    echo &apos;hello world&apos;  #这还是注释</span><br></pre></td></tr></table></figure><p>通过如下命令执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make print</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  maketest git:(dev) ✗ make print</span><br><span class="line"># 这也是注释</span><br><span class="line">echo &apos;hello world&apos;  #这还是注释</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>大家会发现，print对应的命令也打印出来了，这就涉及了回声这个概念</p><h3 id="回声（echoing）"><a href="#回声（echoing）" class="headerlink" title="回声（echoing）"></a>回声（echoing）</h3><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。<br>所以上面print执行的时候，会将命令的内容也打印出来，然后才是真正的执行结果。<br><strong>在命令的前面加上@，就可以关闭回声</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.PHONY :printnoecho</span><br><span class="line">printnoecho :</span><br><span class="line">    @echo &apos;hello world&apos;</span><br></pre></td></tr></table></figure><p>输出结果就不会有命令内容，而仅仅剩下执行结果了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  maketest git:(dev) ✗ make printnoecho</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="自定义赋值"><a href="#自定义赋值" class="headerlink" title="自定义赋值"></a>自定义赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txt = &apos;hello world&apos;</span><br><span class="line">printxt:</span><br><span class="line">    @echo $(txt)</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make printxt</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="编译多个文件"><a href="#编译多个文件" class="headerlink" title="编译多个文件"></a>编译多个文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ALL  =  d.txt e.txt \</span><br><span class="line">f.txt</span><br><span class="line"></span><br><span class="line">all : $(ALL)</span><br><span class="line">    echo &apos;all&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d.txt : a.txt</span><br><span class="line">    cat a.txt &gt; d.txt</span><br><span class="line"></span><br><span class="line">e.txt : d.txt</span><br><span class="line">    cat d.txt &gt; e.txt</span><br><span class="line"></span><br><span class="line">f.txt : d.txt e.txt  </span><br><span class="line">    cat d.txt e.txt &gt; f.txt</span><br></pre></td></tr></table></figure><p>然后执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make all</span><br></pre></td></tr></table></figure><p>会发现d.txt,e.txt,f.txt都会得到创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  maketest git:(dev) ✗ make all</span><br><span class="line">cat a.txt &gt; d.txt</span><br><span class="line">cat d.txt &gt; e.txt</span><br><span class="line">cat d.txt e.txt &gt; f.txt</span><br><span class="line">echo &apos;all&apos;</span><br><span class="line">all</span><br></pre></td></tr></table></figure><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$@ : 当前目标</span><br><span class="line">$&lt; : 指代第一个前置条件</span><br><span class="line">$^ : 指代所有的前置条件</span><br></pre></td></tr></table></figure><p>暂时先写这些，以后遇到什么问题再做补充。</p><h2 id="本文的代码文件"><a href="#本文的代码文件" class="headerlink" title="本文的代码文件"></a>本文的代码文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    echo &apos;this is the a.txt&apos; &gt; a.txt</span><br><span class="line"></span><br><span class="line">b.txt : a.txt</span><br><span class="line">    cat a.txt &gt; b.txt</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br><span class="line"></span><br><span class="line">c.txt : d.txt</span><br><span class="line">    echo &apos;test no prerequists with c.txt&apos; &gt;c.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这是注释</span><br><span class="line">.PHONY :print</span><br><span class="line">print :</span><br><span class="line">    # 这也是注释</span><br><span class="line">    echo &apos;hello world&apos;  #这还是注释</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY :printnoecho</span><br><span class="line">printnoecho :</span><br><span class="line">    @echo &apos;hello world&apos; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">compile : %.cpp</span><br><span class="line">    g++ -o %.cpp %.cpp </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">txt = &apos;hello world&apos;</span><br><span class="line">printxt:</span><br><span class="line">    @echo $(txt)</span><br><span class="line"></span><br><span class="line">printcc:</span><br><span class="line">    $(CC) -o test test.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALL  =  d.txt e.txt \</span><br><span class="line">f.txt</span><br><span class="line"></span><br><span class="line">all : $(ALL)</span><br><span class="line">    echo &apos;all&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d.txt : a.txt</span><br><span class="line">    cat a.txt &gt; d.txt</span><br><span class="line"></span><br><span class="line">e.txt : d.txt</span><br><span class="line">    cat d.txt &gt; e.txt</span><br><span class="line"></span><br><span class="line">f.txt : d.txt e.txt  </span><br><span class="line">    cat d.txt e.txt &gt; f.txt</span><br></pre></td></tr></table></figure><h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><ol><li><a href="https://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">Make 命令教程-阮一峰</a> </li><li><a href="https://www.cnblogs.com/wujing-hubei/p/5223113.html" target="_blank" rel="noopener">makefile文件编写</a></li><li><a href="https://blog.csdn.net/u014066037/article/details/54602273" target="_blank" rel="noopener">Makefile文件编写</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面三篇文章主要讲述了c++的编译过程，本篇文章主要讲述用Makefile文件来定义编译过程，用make命令来对项目进行构建，从而项目在编译过程中存在的各种依赖等可以程序化生成并保持最新版本，一次编写，永久受益。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>终探c++编译过程</title>
    <link href="http://yoursite.com/2019/12/03/%E7%BB%88%E6%8E%A2c-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/12/03/终探c-编译过程/</id>
    <published>2019-12-03T15:11:35.000Z</published>
    <updated>2019-12-03T15:33:47.130Z</updated>
    
    <content type="html"><![CDATA[<p>在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。<br>本篇文章探究c++编译过程的第三篇，属于本系列暂时的最后一篇，总结了本次对于整个编译过程的探究结果，同时解释了动态链接和静态链接以及g++和gcc的一些区别和联系。</p><a id="more"></a><p>其实c++编译过程很复杂，一本《编译原理》让无数从业人员感到自己能力有限，我们这里介绍的仅仅是最简单的，比较概括性的内容，如果想继续深入了解可以自行去看《编译原理》书籍。</p><h2 id="编译过程总结"><a href="#编译过程总结" class="headerlink" title="编译过程总结"></a>编译过程总结</h2><p><img src="http://q1tldblw4.bkt.clouddn.com/qiniu_kwimg20191203232929.png" alt=""><br>我们现在应用的g++编译器其实是一个比较成熟的工具，内部细节我们不做深入探讨。但是从总体上来讲，它将整个编译过程分成了如下的四个步骤：</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><h4 id="g-执行编译"><a href="#g-执行编译" class="headerlink" title="g++执行编译"></a>g++执行编译</h4><p>从源代码文件变成预处理之后的源代码文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E helloword.cpp helloword.ii</span><br></pre></td></tr></table></figure><h4 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h4><p>简单点说，就是将代码进行整合，包括宏定义，include等都替换进来，没用的东西都删掉，比如注释等。</p><p>详细点说<br>预处理相当于根据预处理指令组装新的C/C++程序。经过预处理，会产生一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件，这个文件的含义同原本的文件无异，只是内容上有所不同。</p><ol><li>读取C/C++源程序，对其中的伪指令（以#开头的指令）进行处理<ol><li>将所有的“#define”删除，并且展开所有的宏定义</li><li>处理所有的条件编译指令，如：“#if”、“#ifdef”、“#elif”、“#else”、“endif”等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。</li><li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。</li></ol></li></ol><p>（注意：这个过程可能是递归进行的，也就是说被包含的文件可能还包含其他文件）<br>2. 删除所有的注释<br>3. 添加行号和文件名标识<br>以便于编译时编译器产生调试用的行号信息及用于编译时产生的编译错误或警告时能够显示行号<br>4. 保留所有的#pragma编译器指令</p><h3 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h3><h4 id="g-执行编译-1"><a href="#g-执行编译-1" class="headerlink" title="g++执行编译"></a>g++执行编译</h4><p>从源代码文件变成汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S helloword.cpp helloword.s</span><br></pre></td></tr></table></figure><h4 id="原理解释-1"><a href="#原理解释-1" class="headerlink" title="原理解释"></a>原理解释</h4><p>将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><h4 id="g-执行编译-2"><a href="#g-执行编译-2" class="headerlink" title="g++执行编译"></a>g++执行编译</h4><p>从源代码文件变成对象文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c talk.cpp -o talk.o</span><br><span class="line">g++ -c talktest.cpp -o talktest.o</span><br></pre></td></tr></table></figure><h4 id="原理解释-2"><a href="#原理解释-2" class="headerlink" title="原理解释"></a>原理解释</h4><p><strong>将编译完的汇编代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。</strong></p><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="gcc执行编译"><a href="#gcc执行编译" class="headerlink" title="gcc执行编译"></a>gcc执行编译</h4><p>从对象文件变成可执行文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ talk.o talktest.o -o talktest</span><br><span class="line">./talktest</span><br></pre></td></tr></table></figure><p>也可以从源代码文件变成可执行文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ helloword.cpp -o helloworld</span><br><span class="line">./helloworld</span><br></pre></td></tr></table></figure><h4 id="原理解释-3"><a href="#原理解释-3" class="headerlink" title="原理解释"></a>原理解释</h4><p>通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序</p><h2 id="关于链接过程"><a href="#关于链接过程" class="headerlink" title="关于链接过程"></a>关于链接过程</h2><p>在编译器的第四步链接的时候，主要工作是将对象文件和标准库中的文件进行链接，打包成可执行文件，这个大家应该已经很清楚啦。那么怎么链接呢？</p><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>静态链接是直接将所需要的库都直接嵌入到我们的主程序中，然后直接打包成可执行程序。</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>在主程序中仅仅对这个库进行一次声明，等到程序执行到这个地方的时候，再去引用这个库。</p><h3 id="共同存在的必要性"><a href="#共同存在的必要性" class="headerlink" title="共同存在的必要性"></a>共同存在的必要性</h3><p>静态库有容易使用和理解，而且也达到了代码复用的目的，那为什么我们还要有动态库呢？</p><ol><li>静态库容易造成空间浪费。</li><li>静态库对程序的更新、部署和发布页会带来麻烦</li></ol><p>这两个缺点也就决定了动态库存在的必要性。</p><ol><li>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。</li><li>动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</li></ol><h2 id="Gcc和G-区别与联系"><a href="#Gcc和G-区别与联系" class="headerlink" title="Gcc和G++区别与联系"></a>Gcc和G++区别与联系</h2><p>gcc和g++都是<a href="https://en.wikipedia.org/wiki/GNU" target="_blank" rel="noopener">GNU组织</a>的编译器。<br>1、对于.c后缀的文件，gcc把它当做是C程序；g++ 当做是C++程序；<br>2、对于.cpp后缀的文件，gcc和g++ 都会当做c++程序。<br>3、编译阶段，g++ 会调用gcc；<br>4、连接阶段，通常会用g++ 来完成，这是因为gcc命令不能自动和c++程序使用的库连接</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/wcc27857285/article/details/84945519" target="_blank" rel="noopener">C/C++ 程序编译过程详解</a></li><li><a href="https://blog.csdn.net/baidu_33604078/article/details/79091049" target="_blank" rel="noopener">程序编译的四个过程</a></li><li><a href="https://www.cnblogs.com/mickole/articles/3659112.html" target="_blank" rel="noopener">C/C++程序编译过程详解</a></li><li><a href="https://www.cnblogs.com/skynet/p/3372855.html" target="_blank" rel="noopener">C++静态库与动态库</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。&lt;br&gt;本篇文章探究c++编译过程的第三篇，属于本系列暂时的最后一篇，总结了本次对于整个编译过程的探究结果，同时解释了动态链接和静态链接以及g++和gcc的一些区别和联系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="g++" scheme="http://yoursite.com/tags/g/"/>
    
  </entry>
  
  <entry>
    <title>再探c++编译过程</title>
    <link href="http://yoursite.com/2019/12/03/%E5%86%8D%E6%8E%A2c-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/12/03/再探c-编译过程/</id>
    <published>2019-12-03T15:02:27.000Z</published>
    <updated>2019-12-03T15:10:22.769Z</updated>
    
    <content type="html"><![CDATA[<p>在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。<br>本篇文章探究c++编译过程的第二篇，主要解释了第一篇中的一些现象，同时尝试编译出预处理文件、汇编文件、对象文件等编译过程中的中间产物。</p><a id="more"></a><h2 id="编译原理解释"><a href="#编译原理解释" class="headerlink" title="编译原理解释"></a>编译原理解释</h2><h3 id="编译器的作用"><a href="#编译器的作用" class="headerlink" title="编译器的作用"></a>编译器的作用</h3><p>编译器 g++ 通过检查命令行中指定的文件的后缀名可识别其为 C++ 源代码文件。</p><p>编译器默认的动作：编译源代码文件生成<strong>对象文件(object file)</strong>，将<strong>对象文件</strong>和 <strong>libstdc++ 库中的函数</strong>进行链接得到可执行程序。</p><h3 id="c-编程中常见文件后缀"><a href="#c-编程中常见文件后缀" class="headerlink" title="c++编程中常见文件后缀"></a>c++编程中常见文件后缀</h3><table>    <tbody>  <tr>    <td style="font-family:verdana, sans-serif;font-size:12px;">      <strong>.a</strong></td>    <td style="font-family:verdana, sans-serif;font-size:12px;">静态库 (archive)</td></tr>  <tr>    <td style="font-family:verdana, sans-serif;font-size:12px;">      <strong>.C        <br>.c        <br>.cc        <br>.cp        <br>.cpp        <br>.cxx        <br>.c++</strong></td>    <td style="font-family:verdana, sans-serif;font-size:12px;">C++源代码（需要编译预处理）</td></tr>  <tr>    <td style="font-family:verdana, sans-serif;font-size:12px;">      <strong>.h</strong></td>    <td style="font-family:verdana, sans-serif;font-size:12px;">C或者C++源代码头文件</td></tr>  <tr>    <td style="font-family:verdana, sans-serif;font-size:12px;">      <strong>.ii</strong></td>    <td style="font-family:verdana, sans-serif;font-size:12px;">C++源代码（不需编译预处理）</td></tr>  <tr>    <td style="font-family:verdana, sans-serif;font-size:12px;">      <strong>.o</strong></td>    <td style="font-family:verdana, sans-serif;font-size:12px;">对象文件</td></tr>  <tr>    <td style="font-family:verdana, sans-serif;font-size:12px;">      <strong>.s</strong></td>    <td style="font-family:verdana, sans-serif;font-size:12px;">汇编语言代码</td></tr>  <tr>    <td style="font-family:verdana, sans-serif;font-size:12px;">      <strong>.so</strong></td>    <td style="font-family:verdana, sans-serif;font-size:12px;">动态库</td></tr>  <tr>    <td style="font-family:verdana, sans-serif;font-size:12px;">      <strong>&lt;none&gt;</strong></td>    <td style="font-family:verdana, sans-serif;font-size:12px;">标准C++系统头文件</td></tr></tbody></table><h3 id="初探解疑"><a href="#初探解疑" class="headerlink" title="初探解疑"></a>初探解疑</h3><ol><li>初探过程中，当我们直接通过如下命令编译出最后的执行文件的过程中，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure>其实是存在中间状态文件的，也就是编译过程中所说到的<strong>对象文件</strong>，查表可知应该是以.o为后缀的文件。</li><li>初探过程中，当我们将头文件talk.h和实现源文件talk.cpp分开之后，然后只编译测试文件talktest.cpp的时候是报错的，那么现在我们就可以理解为什么报错了，原因在于最终的可执行文件是要链接对象文件和标准库中的文件形成的，而对象文件是必须要通过cpp等c++源代码编译形成的，所以对于我们自己编写的cpp文件是一定要经过自己手动编译才能参与到后续的链接过程中的。</li></ol><h2 id="再探c-编译过程"><a href="#再探c-编译过程" class="headerlink" title="再探c++编译过程"></a>再探c++编译过程</h2><h3 id="生成对象文件"><a href="#生成对象文件" class="headerlink" title="生成对象文件"></a>生成对象文件</h3><p>1.利用初探中写好的talk.h,talk.cpp,talktest.cpp文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.h</span><br><span class="line">*/</span><br><span class="line">class Talk&#123;</span><br><span class="line">    public:</span><br><span class="line">        void say(const char*); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.cpp</span><br><span class="line">*/</span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">void Talk::say(const char* str)&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;talk with&quot;&lt;&lt;&apos;\t&apos;&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">talktest.cpp</span><br><span class="line">*/</span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Talk talk;</span><br><span class="line">    talk.say(&quot;kingwen&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>直接编译出对象文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c talk.cpp</span><br><span class="line">g++ -c talktest.cpp</span><br></pre></td></tr></table></figure></li><li><p>查看当前文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p>可以发现多了两个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">talk.o talktest.o</span><br></pre></td></tr></table></figure></li><li><p>编译对象文件生成可执行文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ talk.o talktest.o -o talktest1</span><br></pre></td></tr></table></figure></li><li><p>执行talktest1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./talktest1</span><br></pre></td></tr></table></figure><p>结果和我们执行直接生成编译结果是一样的,结果如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">talk with   kingwen</span><br></pre></td></tr></table></figure></li><li><p>对象文件输出<br>我们在第二步中是通过<strong>gcc -c talk.cpp</strong>直接编译出了<strong>talk.o</strong>这个对象。<br>这里会使得编译结果的默认名称和源码名称一致。但是我们其实可以自定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c talk.cpp -o talker.o</span><br><span class="line">g++ -c talktest.cpp -o talkertest.o</span><br></pre></td></tr></table></figure><p>然后编译运行方式和前面说明的一致即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ talker.o talkertest.o -o talkertest</span><br><span class="line">./talkertest</span><br></pre></td></tr></table></figure><p>最后得到的结果也和之前是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">talk with   kingwen</span><br></pre></td></tr></table></figure><p>PS:所以如果以后在编码过程中如果碰见说缺少对象文件，那么就是对应的cpp源代码文件没有编译，我们可以通过g++命令对其进行编译即可解决问题。</p><h3 id="生成预处理文件"><a href="#生成预处理文件" class="headerlink" title="生成预处理文件"></a>生成预处理文件</h3></li><li><p>找到初探中的helloworld.cpp代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">  helloworld.cpp </span><br><span class="line">  用于测试g++编译单个源文件生成可执行程序</span><br><span class="line">*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;hello world&quot;&lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过wc命令来查看helloworld.cpp文件的行数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  compilec++ wc -l helloworld.cpp</span><br><span class="line">       8 helloworld.cpp</span><br></pre></td></tr></table></figure></li><li><p>代码预处理<br>通过如下命令会将预处理的结果在标准输出中进行输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E helloworld.cpp</span><br></pre></td></tr></table></figure><p>当然我们也可以将结果进行输出保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E helloworld.cpp -o helloworld.ii</span><br></pre></td></tr></table></figure><p>通过wc命令来查看预处理结果helloworld.ii的行数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compilec++ wc -l helloworld.ii</span><br><span class="line">  41484 helloworld.ii</span><br></pre></td></tr></table></figure><p>可以发现文件大小有了翻天覆地的变化，这里主要就是将头文件等引入了我们的文件中。</p></li></ol><h3 id="生成汇编文件"><a href="#生成汇编文件" class="headerlink" title="生成汇编文件"></a>生成汇编文件</h3><ol><li>同样还是之前的helloworld.cpp代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">  helloworld.cpp </span><br><span class="line">  用于测试g++编译单个源文件生成可执行程序</span><br><span class="line">*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;hello world&quot;&lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>直接编译生成汇编代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S helloworld.cpp -o helloworld.s</span><br></pre></td></tr></table></figure></li><li>查看生成的汇编代码<br>其实可以使用cat或者head或者tail进行查看，<br>这里我用的是sed命令查看了从1360到1372行，因为我觉得这块代码更加符合我对汇编的想象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &apos;1360,1372p&apos; helloworld.s</span><br></pre></td></tr></table></figure>结果如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">compilec++ sed -n &apos;1360,1372p&apos; helloworld.s</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register %rbp</span><br><span class="line">    movl    %edi, -4(%rbp)</span><br><span class="line">    movl    %esi, -8(%rbp)</span><br><span class="line">    movl    -4(%rbp), %esi</span><br><span class="line">    cmpl    -8(%rbp), %esi</span><br><span class="line">    sete    %al</span><br><span class="line">    andb    $1, %al</span><br><span class="line">    movzbl  %al, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    retq</span><br><span class="line">    .cfi_endproc</span><br><span class="line">                                        ## -- End function</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><a href="https://blog.csdn.net/guoxiaoqian8028/article/details/18915513" target="_blank" rel="noopener">GCC编译C++</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。&lt;br&gt;本篇文章探究c++编译过程的第二篇，主要解释了第一篇中的一些现象，同时尝试编译出预处理文件、汇编文件、对象文件等编译过程中的中间产物。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="g++" scheme="http://yoursite.com/tags/g/"/>
    
  </entry>
  
  <entry>
    <title>初探c++编译过程</title>
    <link href="http://yoursite.com/2019/12/03/%E5%88%9D%E6%8E%A2c-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/12/03/初探c-编译过程/</id>
    <published>2019-12-03T14:53:58.000Z</published>
    <updated>2019-12-03T15:00:44.241Z</updated>
    
    <content type="html"><![CDATA[<p>在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。<br>本篇文章探究c++编译过程的第一篇，主要尝试编译单个源文件和多个源文件生成可执行文件。</p><a id="more"></a><h3 id="单个源文件生成可执行程序"><a href="#单个源文件生成可执行程序" class="headerlink" title="单个源文件生成可执行程序"></a>单个源文件生成可执行程序</h3><ol><li><p>编写helloworld源代码，文件后缀是cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* helloworld.cpp */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;hello world&quot;&lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过gcc编译器对其进行编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ helloworld.cpp</span><br><span class="line">或者</span><br><span class="line">g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure><p>如果是第一条命令，g++会编译helloworld.cpp文件产生a.out文件，a.out是默认文件名；<br>但是更多情况下我们使用g++编译文件的时候会通过-o参数来指定生成的可执行文件的文件名。比如这里生成的文件名就叫做helloworld</p></li><li><p>查看当前目录文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p>因为执行了两次不同的编译，所以当前目录下会有三个文件，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.out  helloworld  helloworld.cpp</span><br></pre></td></tr></table></figure></li><li><p>执行文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br><span class="line">或者</span><br><span class="line">./helloworld</span><br></pre></td></tr></table></figure><p>这里两次结果是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="两个源文件生成可执行程序"><a href="#两个源文件生成可执行程序" class="headerlink" title="两个源文件生成可执行程序"></a>两个源文件生成可执行程序</h3><p>这一部分我们自己编写一个头文件speak.h,然后编写一个测试文件speaktest.cpp进行编译测试。</p></li><li><p>编写speak.h代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">speak.h</span><br><span class="line">用于测试g++编译多个文件形成一个可执行文件</span><br><span class="line">*/</span><br><span class="line">#ifndef __SPEAK__</span><br><span class="line">#define __SPEAK__</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Speak&#123;</span><br><span class="line">    public:</span><br><span class="line">        void sayHello(const char* );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Speak::sayHello(const char* str)&#123;</span><br><span class="line">    std::cout&lt;&lt; &quot;hello&quot; &lt;&lt;&apos;\t&apos;&lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>编写speaktest.cpp代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">speaktest.cpp</span><br><span class="line">用于测试g++编译多个文件形成一个可执行文件</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &quot;speak.h&quot;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Speak speak;</span><br><span class="line">    speak.sayHello(&quot;kingwen&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>g++编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ speaktest.cpp -o speaktest</span><br></pre></td></tr></table></figure></li><li><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./speaktest</span><br></pre></td></tr></table></figure><p>结果很符合我们的预期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello   kingwen</span><br></pre></td></tr></table></figure><p>所以我们可以得出很明显的结论，就是我们的.h其实只要在最终的测试文件中include，不需要自己再手动编译一次，这非常符合编译原理课程中的讲述。</p></li></ol><p>这里我们就发现一个问题，我们的speak.h头文件其实和它的实现都在同一个文件中，但是很多情况下，头文件只负责声明，具体实现是通过其他文件来实现的，如果碰到这种情况我们还可以通过只编译测试文件就能运行嘛？来测试一下。</p><h3 id="声明和实现分离生成可执行程序"><a href="#声明和实现分离生成可执行程序" class="headerlink" title="声明和实现分离生成可执行程序"></a>声明和实现分离生成可执行程序</h3><ol><li>编写talk.h文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.h</span><br><span class="line">用于测试当talk的声明和实现分离，那么在测试的时候能不能只编译测试文件。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Talk&#123;</span><br><span class="line">    public:</span><br><span class="line">        void say(const char*); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>编写talk.cpp文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.cpp</span><br><span class="line">用于测试当talk的声明和实现分离，那么在测试的时候能不能只编译测试文件。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">void Talk::say(const char* str)&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;talk with&quot;&lt;&lt;&apos;\t&apos;&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编写talktest.cpp文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">talktest.cpp</span><br><span class="line">用于测试当talk的声明和实现分离，那么在测试的时候能不能只编译测试文件。</span><br><span class="line">*/</span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Talk talk;</span><br><span class="line">    talk.say(&quot;kingwen&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>尝试编译<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ talktest.cpp -o talktest</span><br></pre></td></tr></table></figure>注意，这个时候报错了！！！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  compilec++ g++ talktest.cpp -o talktest</span><br><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;Talk::say(char const*)&quot;, referenced from:</span><br><span class="line">      _main in talktest-2630f3.o</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>原因其实是没有找到Talk中say方法的实现。<br>那么我们尝试连同talk.cpp一起编译<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ talktest.cpp talk.cpp -o talktest</span><br></pre></td></tr></table></figure>这个时候就可以编译通过啦，而且经过我的测试中间talktest.cpp和talk.cpp的顺序交换是没有关系的。</li><li>执行结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./talktest</span><br></pre></td></tr></table></figure>结果非常符合预期<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">talk with   kingwen</span><br></pre></td></tr></table></figure>由此，我们可以解释我们小节提出的疑问了，如果声明和实现不在同一个地方，那么对于实现文件是需要进行编译的，否则就会报错。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://blog.csdn.net/guoxiaoqian8028/article/details/18915513" target="_blank" rel="noopener">GCC编译C++</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。&lt;br&gt;本篇文章探究c++编译过程的第一篇，主要尝试编译单个源文件和多个源文件生成可执行文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="g++" scheme="http://yoursite.com/tags/g/"/>
    
  </entry>
  
  <entry>
    <title>Make-MacOs-Support-NTFS</title>
    <link href="http://yoursite.com/2019/12/01/Make-MacOs-Support-NTFS/"/>
    <id>http://yoursite.com/2019/12/01/Make-MacOs-Support-NTFS/</id>
    <published>2019-12-01T07:37:21.000Z</published>
    <updated>2019-12-01T07:46:35.223Z</updated>
    
    <content type="html"><![CDATA[<p>我有一个2T的硬盘，文件格式是NTFS格式的，在MAC系统上一直能读不能写，让我很苦恼，这次从网上找了一个方法而且亲测有效，所以特地记录一下。</p><a id="more"></a><h2 id="什么是NTFS"><a href="#什么是NTFS" class="headerlink" title="什么是NTFS"></a>什么是<a href="https://zh.wikipedia.org/wiki/NTFS" target="_blank" rel="noopener">NTFS</a></h2><p>简单来讲，NTFS是微软开发的专用文件系统，Mac OS X内核能对NTFS进行有限的读操作。Linux和BSD提供自由及开放源代码的软件，可用于读写NTFS文件。</p><pre><code>NTFS（英语：New Technology File System），是Microsoft公司开发的专用文件系统，从Windows NT 3.1开始成为Windows NT家族的标准文件系统。[4]NTFS取代FAT（文件分配表）和HPFS（高性能文件系统）并进行一系列改进，例如增强对元数据的支持，使用更高级的数据结构以提升性能、可靠性和磁盘空间利用率，并附带一系列增强功能，如访问控制列表（ACL）和文件系统日志等。——维基百科</code></pre><h2 id="解决措施"><a href="#解决措施" class="headerlink" title="解决措施"></a>解决措施</h2><h3 id="流程简介"><a href="#流程简介" class="headerlink" title="流程简介"></a>流程简介</h3><ol><li>挂载上你的NTFS硬盘，查看硬盘名称</li><li>编辑/etc/fstab文件，使其支持NTFS写入</li><li>将/Volumes中的NTFS磁盘快捷方式到Finder</li></ol><h3 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h3><ol><li><p>插上硬盘后，查看你的硬盘名称，这里假设名称是AngleDisk，牢记之（你的可不是这个呀！！）</p></li><li><p>打开Applications的Terminal, 你也可以直接spotlight输入terminal打开</p></li><li><p>在终端输入sudo nano /etc/fstab 敲击回车</p></li><li><p>现在你看到了一个编辑界面，输入LABEL=AngleDisk none ntfs rw,auto,nobrowse后，敲击回车，再Ctrl+X，再敲击Y，再敲击回车</p></li><li><p>此时，退出你的移动硬盘，再重新插入，你会发现磁盘没有显示再桌面或是Finder之前出现的地方，别慌</p></li><li><p>打开Finder，Command+Shift+G，输入框中输入/Volumes，回车，你就可以看到你的磁盘啦！是可以读写的哟，Enjoy</p></li><li><p>方便起见，你可以直接把磁盘拖到Finder侧边栏中，这样下次使用就不用进入到/Volumes目录打开了</p></li></ol><h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://blog.csdn.net/u013247765/article/details/77932144" target="_blank" rel="noopener">无需第三方软件实现Mac支持ntfs读写的最简单操作</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我有一个2T的硬盘，文件格式是NTFS格式的，在MAC系统上一直能读不能写，让我很苦恼，这次从网上找了一个方法而且亲测有效，所以特地记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="MacOs" scheme="http://yoursite.com/tags/MacOs/"/>
    
      <category term="NTFS" scheme="http://yoursite.com/tags/NTFS/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-207-CourseSchedule</title>
    <link href="http://yoursite.com/2019/12/01/leetcode-207-CourseSchedule/"/>
    <id>http://yoursite.com/2019/12/01/leetcode-207-CourseSchedule/</id>
    <published>2019-12-01T06:13:45.000Z</published>
    <updated>2019-12-01T06:42:57.142Z</updated>
    
    <content type="html"><![CDATA[<p>这个是leetcode中为数不多的关于Graph的题目，判断图中是否有环，可以用BFS或者DFS两种思路进行求解。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p><p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class="line">             also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>BFS或者DFS</p><h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><p>其实这个题目就是说对于每一个课程都有一个前置课程，然后问如果前置课程这样安排能不能成立，其实就可以抽象出查看一个图中是否有环，因为一旦有环路，那肯定是不成立的，反之，肯定成立。</p><h3 id="BFS思路"><a href="#BFS思路" class="headerlink" title="BFS思路"></a>BFS思路</h3><p>我们创建一个队列，用于保存目前入度为0的点，然后我们对于每个节点都保存一个入度的值。然后从入度为0的值开始，进行遍历，对于这个点能达到的所有的点将其入度减去1，如果此时这个点入度为0，将其加入到队列中。当队列为空的时候，如果此时所有节点的入读都变成0，那么肯定没有环路，否则有环路。<br>举例说明,假设输入是如下情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 [[1,0],[2,0],[1,2],[3,1]]</span><br></pre></td></tr></table></figure><p>对应的图其实就是<br><img src="http://q1tldblw4.bkt.clouddn.com/qiniu_kwimg20191201143417.png" alt=""></p><p>1.初始化队列q中元素只有0，入度数组arr=[0,2,1,1]<br>2. 然后经过0号节点，arr变为[0,1,0,1],此时2号加入队列<br>3. 然后处理2号节点，arr变成[0,0,0,1],此时1号加入队列<br>4. 然后处理1号节点，arr变成[0,0,0,0] 此时3号加入队列<br>5. 然后处理3号节点，arr变成[0,0,0,0] 此时队列为空。<br>6. 然后判断arr数组中每个节点的入度是否是0，全为0，返回true。</p><h3 id="DFS思路"><a href="#DFS思路" class="headerlink" title="DFS思路"></a>DFS思路</h3><p>DFS就是用深度优先搜索，我们对于每个节点记录一个状态，-1表示是当前节点：如果在遍历过程中发现了-1，说明又回到了自身，那就是有环路，返回flase；0是默认值，代表之前还没有访问；1表示已经访问过了。对于每一个节点都进行如此的遍历，即可得到结果。<br>PS：要记得传引用而不要传对象本身，否则容易Time Limit Exceeded</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="BFS解题代码"><a href="#BFS解题代码" class="headerlink" title="BFS解题代码"></a>BFS解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; graph(numCourses,vector&lt;int&gt;());</span><br><span class="line">        vector&lt;int&gt; in(numCourses,0);</span><br><span class="line">        for(auto a:prerequisites)&#123;</span><br><span class="line">            graph[a[1]].push_back(a[0]);</span><br><span class="line">            in[a[0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        for(int i = 0;i&lt;in.size();i++)&#123;</span><br><span class="line">            if(in[i]==0) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            auto a = q.front(); q.pop();</span><br><span class="line">            for(int b:graph[a])&#123;</span><br><span class="line">                --in[b];</span><br><span class="line">                if(in[b]==0) q.push(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i:in)&#123;</span><br><span class="line">            if(i!=0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="DFS解题代码"><a href="#DFS解题代码" class="headerlink" title="DFS解题代码"></a>DFS解题代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; graph(numCourses,vector&lt;int&gt;());</span><br><span class="line">        vector&lt;int&gt; visit(numCourses);</span><br><span class="line">        for(auto a:prerequisites)&#123;</span><br><span class="line">            graph[a[1]].push_back(a[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; numCourses; ++i)&#123;</span><br><span class="line">            if(!findSelf(graph,visit,i)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool findSelf(vector&lt;vector&lt;int&gt;&gt;&amp; graph,vector&lt;int&gt;&amp; visit,int i)&#123;</span><br><span class="line">        if(visit[i] == -1) return false;</span><br><span class="line">        if(visit[i] == 1) return true;</span><br><span class="line">        visit[i] = -1;</span><br><span class="line">        for(auto a:graph[i])&#123;</span><br><span class="line">            if(!findSelf(graph,visit,a)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i] = 1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上，本题结束！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个是leetcode中为数不多的关于Graph的题目，判断图中是否有环，可以用BFS或者DFS两种思路进行求解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="medium" scheme="http://yoursite.com/tags/medium/"/>
    
      <category term="Graph" scheme="http://yoursite.com/tags/Graph/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Class-with-pointer-mString-Houjie-Bilibili</title>
    <link href="http://yoursite.com/2019/11/22/Class-with-pointer-mString-Houjie-Bilibili/"/>
    <id>http://yoursite.com/2019/11/22/Class-with-pointer-mString-Houjie-Bilibili/</id>
    <published>2019-11-22T15:47:22.000Z</published>
    <updated>2019-11-22T15:51:17.271Z</updated>
    
    <content type="html"><![CDATA[<p>在Bilibili跟着侯捷老师学C++系列第二篇，带指针的类mString类。<br>人生得遇良师，实属大幸，侯捷老师就属于这种老师，再夸一遍！！</p><a id="more"></a><p>因为C++的效率是最高的，所以对于C++自己一定要好好掌握，个人看法，你如果能学会C++，其他语言都将不在话下。然后刚好碰到一个非常好的教程，有一位非常棒的老师-侯捷老师，有一个好的平台-Bilibili，还有非常好的训练场地——leetcode，所以此时不学什么时候学呢？</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p><a href="https://www.bilibili.com/video/av19038490" target="_blank" rel="noopener">侯捷C++手把手教学(上),适合新手</a> </p><h2 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h2><h3 id="mstring-hpp"><a href="#mstring-hpp" class="headerlink" title="mstring.hpp"></a>mstring.hpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#ifndef mstring_hpp</span><br><span class="line">#define mstring_hpp</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class mstring&#123;</span><br><span class="line">public:</span><br><span class="line">    mstring(const char* a = 0);</span><br><span class="line">    mstring(const mstring&amp; str);</span><br><span class="line">    mstring&amp; operator =(const mstring&amp; str);</span><br><span class="line">    ~mstring();</span><br><span class="line">    char* get_c_str() const &#123;return mdata;&#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    char* mdata;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring::mstring(const char* a)&#123;</span><br><span class="line">    if(a)&#123;</span><br><span class="line">        mdata = new char[strlen(a)+1];</span><br><span class="line">        strcpy(mdata, a);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        mdata = new char[1];</span><br><span class="line">        *mdata = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring::mstring(const mstring&amp; str)&#123;</span><br><span class="line">    mdata = new char[std::strlen(str.mdata)+1];</span><br><span class="line">    strcpy(mdata, str.mdata);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring&amp; mstring::operator=(const mstring&amp; str)&#123;</span><br><span class="line">    if(this == &amp;str)&#123;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    this-&gt;mdata = new char[strlen(str.mdata)+1];</span><br><span class="line">    strcpy(this-&gt;mdata,str.mdata);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring::~mstring()&#123;</span><br><span class="line">    delete[] mdata;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator &lt;&lt; (ostream&amp; os,const mstring&amp; str)&#123;</span><br><span class="line">    return os&lt;&lt;str.get_c_str();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif /* mstring_hpp */</span><br></pre></td></tr></table></figure><h3 id="mstring-cpp"><a href="#mstring-cpp" class="headerlink" title="mstring.cpp"></a>mstring.cpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mstring.hpp&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    mstring s1;</span><br><span class="line">    cout&lt;&lt;&quot;s1 = &quot;&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    mstring s2(&quot;hello&quot;);</span><br><span class="line">    cout&lt;&lt;&quot;s2 = &quot;&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">    s1 = s2;</span><br><span class="line">    cout&lt;&lt;&quot;s1 = &quot;&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    mstring s3(s2);</span><br><span class="line">    cout&lt;&lt;&quot;s3 = &quot;&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    mstring *p = new mstring(&quot;world&quot;);</span><br><span class="line">    cout&lt;&lt;&quot;*p = &quot;&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = </span><br><span class="line">s2 = hello</span><br><span class="line">s1 = hello</span><br><span class="line">s3 = hello</span><br><span class="line">*p = world</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><h2 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h2><ol><li>构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstring(const char* a = 0);</span><br></pre></td></tr></table></figure>构造函数的名称和类名一致，没有返回值，参数可以设置默认参数（实际实现的时候就不需要再说明默认参数了）</li><li>拷贝构造<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstring(const mstring&amp; str);</span><br></pre></td></tr></table></figure>接收一个同种类型的对象作为自己的参数，然后产生一个新的对象。</li></ol><p>这里要注意深复制和浅复制的区别，深复制就是会新创建一个对象，这个对象有属于自己的内存空间，只是值和原来的是一致的。浅复制是说两个对象指向同一个内存空间，所以一旦有一个更改，另一个肯定会被更改，很危险。<br>3. 拷贝赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstring&amp; operator =(const mstring&amp; str);</span><br></pre></td></tr></table></figure><p>这里首先要注意的是我们重载了运算符=，然后是当前类的方法。其次是我们传入的参数，我们不会修改，所以设置为const，是通过引用传进来的，返回值同样是一个mstring对象，我们通过引用返回。</p><p>对于成员函数，其实每个函数都含有一个隐藏的参数this，我们可以通过this和参数引用的地址来确定是否是自我赋值，要进行判断，否则会报错。因为具体赋值的过程是先删除本身的数据，然后创建一个能容纳str的空间的内存，然后将str内容拷贝到内存中。如果this和str指向同一个地址，那么刚开始删除掉就已经没有了，之后的创建空间就会出错。所以一定要注意这个拷贝赋值时自我赋值的问题。<br>4. 析构函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~mstring();</span><br></pre></td></tr></table></figure><p>析构函数是指当对象生命周期结束之后会自动调用当前对象的析构函数，主要负责释放通过new关键字请求得到的内存空间。如果不自行解决，那么new出来的这块空间就会变成无主空间，会造成内存泄露。<br>5. 对于一个带有指针的类，必须要有拷贝构造和拷贝赋值还有析构函数。<br>6. 其他成员函数的编写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* get_c_str() const &#123;return mdata;&#125;</span><br></pre></td></tr></table></figure><p>首先这个函数可以认为是一个辅助函数，方便之后重载&lt;&lt; 符号的，因为ostream已经被重载过所以可以输出char类型的指针所指向的数据，所以我们这里单独写一个用于输出。<br>其次要注意这个函数有个const，对于类对象本身没有更改的方法都要写上这个const。<br>然后要注意这里的返回值类型，是一个char类型的指针。<br>7. array new 一定要搭配一个array delete</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline</span><br><span class="line">mstring::mstring(const char* a)&#123;</span><br><span class="line">    if(a)&#123;</span><br><span class="line">        mdata = new char[strlen(a)+1];</span><br><span class="line">        strcpy(mdata, a);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        mdata = new char[1];</span><br><span class="line">        *mdata = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline</span><br><span class="line">mstring::~mstring()&#123;</span><br><span class="line">    delete[] mdata;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在构造函数中是创建了一个char类型的数组，那么在析构函数中也要以同样的方式进行释放。<br>8. 关于栈存储<br>Stack,是存在于作用域的一块内存空间，例如当你调用函数，函数本身就会形成一个stack来放置它所接收的参数，以及对应的返回地址。在函数本体中声明的任何变量，其所使用的内存块都会在上述stack中。当作用域结束，所有内存都会被回收，内存中的对象也就再也找不到了，所以这就是我们上一节所讲的不能返回一个local对象的引用或者指针而要直接返回他们本身。<br>9. 关于堆存储<br>Heap，或者叫做system heap，是指由操作系统提供的一块global的内存空间，程序可以通过new来动态分配获得若干区块。这样就需要自己来动手释放掉。<br>10. stack object的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> complex c1(1,2);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个大括号（作用域）中创建的对象也就是所谓的local对象，比如c1,在作用域结束的时候就会被自动清理。<br>11. static local object的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    static complex c2(1,2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个局部变量被static关键字修饰的时候,比如c2，它就是一个静态对象，其生命在作用域结束之后仍然存在，直到整个程序结束。<br>12. global objects的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">complex c3(1,2);</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局对象，写在{}之外的对象,比如c3，其生命周期是整个程序。这个经常在算法题目中出现。<br>13. heap objects的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    complex* p = new Complex(1,2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的p就是一个堆对象，是由动态分配生成的，在其被deleted之际才会结束。<br>14. new关键字:先分配内存，然后调用构造函数<br>15. delete关键字：先调用析构函数，然后再释放内存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Bilibili跟着侯捷老师学C++系列第二篇，带指针的类mString类。&lt;br&gt;人生得遇良师，实属大幸，侯捷老师就属于这种老师，再夸一遍！！&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Houjie" scheme="http://yoursite.com/tags/Houjie/"/>
    
      <category term="Bilibili" scheme="http://yoursite.com/tags/Bilibili/"/>
    
  </entry>
  
  <entry>
    <title>Class-without-pointer-Complex-Houjie-Bilibili</title>
    <link href="http://yoursite.com/2019/11/22/Class-without-pointer-Complex-Houjie-Bilibili/"/>
    <id>http://yoursite.com/2019/11/22/Class-without-pointer-Complex-Houjie-Bilibili/</id>
    <published>2019-11-22T14:15:18.000Z</published>
    <updated>2019-11-22T14:53:29.139Z</updated>
    
    <content type="html"><![CDATA[<p>在Bilibili跟着侯捷老师学C++系列第一篇，不带指针的类Complex类。<br>人生得遇良师，实属大幸，侯捷老师就属于这种老师！！</p><a id="more"></a><p>因为C++的效率是最高的，所以对于C++自己一定要好好掌握，个人看法，你如果能学会C++，其他语言都将不在话下。然后刚好碰到一个非常好的教程，有一位非常棒的老师-侯捷老师，有一个好的平台-Bilibili，还有非常好的训练场地——leetcode，所以此时不学什么时候学呢？</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p><a href="https://www.bilibili.com/video/av19038490" target="_blank" rel="noopener">侯捷C++手把手教学(上),适合新手</a> </p><h2 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h2><h3 id="Complex-hpp"><a href="#Complex-hpp" class="headerlink" title="Complex.hpp"></a>Complex.hpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Complex_hpp</span><br><span class="line">#define Complex_hpp</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Complex&#123;</span><br><span class="line">public:</span><br><span class="line">    Complex(double r = 0, double i = 0) : re(r), im(i)&#123;&#125;</span><br><span class="line">    Complex&amp; operator += (const Complex&amp;);</span><br><span class="line">    double real() const &#123;return re;&#125;</span><br><span class="line">    double imag() const &#123;return im;&#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    double re,im;</span><br><span class="line">    </span><br><span class="line">    friend Complex&amp; _doapl(Complex*, const Complex&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif /* Complex_hpp */</span><br><span class="line"></span><br><span class="line">inline Complex&amp; Complex::operator += (const Complex&amp; c)&#123;</span><br><span class="line">    return _doapl(this,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex&amp; _doapl(Complex* ths,const Complex&amp; c)&#123;</span><br><span class="line">    ths-&gt;im += c.im;</span><br><span class="line">    ths-&gt;re += c.re;</span><br><span class="line">    return *ths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double real(const Complex&amp; r)&#123;</span><br><span class="line">    return r.real();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double imag(const Complex&amp; r)&#123;</span><br><span class="line">    return r.imag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator +(const Complex&amp; r1,const Complex r2)&#123;</span><br><span class="line">    return Complex(real(r1)+real(r2), imag(r1)+imag(r2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator + (const Complex&amp; r1, double d)&#123;</span><br><span class="line">    return Complex(real(r1)+d,imag(r1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator + (double d,const Complex&amp; r1)&#123;</span><br><span class="line">    return Complex(real(r1)+d, imag(r1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os,const Complex&amp; c)&#123;</span><br><span class="line">    return os&lt;&lt;&quot;(&quot;&lt;&lt;real(c)&lt;&lt;&quot;,&quot;&lt;&lt;imag(c)&lt;&lt;&quot;)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Complex-cpp"><a href="#Complex-cpp" class="headerlink" title="Complex.cpp"></a>Complex.cpp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Complex.hpp&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Complex c1(2,3);</span><br><span class="line">    Complex c2;</span><br><span class="line">//   测试输出</span><br><span class="line">    cout&lt;&lt;c1&lt;&lt;endl;</span><br><span class="line">//    测试连续输出</span><br><span class="line">    cout&lt;&lt;c1&lt;&lt;c1&lt;&lt;endl;</span><br><span class="line">//    测试 +=</span><br><span class="line">    c1 += c2;</span><br><span class="line">    cout&lt;&lt; c1&lt;&lt;endl;</span><br><span class="line">//    测试+运算</span><br><span class="line">    cout&lt;&lt; c1+2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="result"><a href="#result" class="headerlink" title="result"></a>result</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(2,3)</span><br><span class="line">(2,3)(2,3)</span><br><span class="line">(2,3)</span><br><span class="line">(4,3)</span><br></pre></td></tr></table></figure><h2 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h2><ol><li>首先是要有一个防卫式声明。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Complex_hpp</span><br><span class="line">#define Complex_hpp</span><br><span class="line"></span><br><span class="line">#endif /* Complex_hpp */</span><br></pre></td></tr></table></figure>它的作用在于当我们写的类被其他人通过导入头文件引用的时候不会重复引用。</li><li>类的数据不出意外都要写在private部分,也就是下面的部分。而方法一般都是写在public部分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">    double re,im;</span><br></pre></td></tr></table></figure></li><li>函数的要不要加const关键字,如果没有更改类属性的值，都要加上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double real() const &#123;return re;&#125;</span><br></pre></td></tr></table></figure></li><li>函数参数要不要加const关键字，如果我们不想这个参数在方法中被修改，那么就加上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline double real(const Complex&amp; r)&#123;</span><br><span class="line">    return r.real();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>考虑是返回值是传值还是传引用。尽量都传引用，这样可以极大的提高效率。但是当返回的值是一个局部变量的时候，要记得通过值进行返回。</li><li>在重载操作符的时候，考虑返回值要考虑到会不会有多重使用，然后再考虑是要无返回还是返回一个引用值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os,const Complex&amp; c)&#123;</span><br><span class="line">    return os&lt;&lt;&quot;(&quot;&lt;&lt;real(c)&lt;&lt;&quot;,&quot;&lt;&lt;imag(c)&lt;&lt;&quot;)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>当重载运算符的时候要声明其为全局函数。</li><li>构造函数可以通过initialization list来进行初始化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex(double r = 0, double i = 0) : re(r), im(i)&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>传递者无需知道接收者是以什么形式传递数据。传递者只需要传过去即可。但是如果以reference进行传递效率会高一点。</li><li>友元函数可以直接访问私有数据。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Bilibili跟着侯捷老师学C++系列第一篇，不带指针的类Complex类。&lt;br&gt;人生得遇良师，实属大幸，侯捷老师就属于这种老师！！&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Houjie" scheme="http://yoursite.com/tags/Houjie/"/>
    
      <category term="Bilibili" scheme="http://yoursite.com/tags/Bilibili/"/>
    
  </entry>
  
</feed>
