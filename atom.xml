<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingwen&#39;s blog</title>
  
  <subtitle>没有输出的输入是不完整的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-11T09:14:38.338Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李庆文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>how-to-save-pdf-images</title>
    <link href="http://yoursite.com/2019/11/11/how-to-save-pdf-images/"/>
    <id>http://yoursite.com/2019/11/11/how-to-save-pdf-images/</id>
    <published>2019-11-11T06:02:09.000Z</published>
    <updated>2019-11-11T09:14:38.338Z</updated>
    
    <content type="html"><![CDATA[<p>本来想查一下如何写程序来提取pdf中的图片来着，然后发现可以用ps来实现，然后就先记录一下。</p><a id="more"></a><h2 id="通过PhotoShop进行保存"><a href="#通过PhotoShop进行保存" class="headerlink" title="通过PhotoShop进行保存"></a>通过PhotoShop进行保存</h2><ol><li>打开ps</li><li>选择ps的菜单选项 <strong>文件</strong>-&gt;<strong>打开</strong>（或者直接快捷键ctrl+o）打开想打开的pdf文件</li><li>在打开pdf选项页面的时候，注意选择<strong>图像</strong>，然后选择要打开的图片（可以通过按住shift进行多选），然后点击确定即可。如下图所示。<br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191111135210.png" alt=""></li><li>在图片页面进行保存操作，(也可以使用快捷键ctrl+s)，注意保存格式选择jpeg，重命名，选择保存地址，然后确定即可。<h2 id="截图保存"><a href="#截图保存" class="headerlink" title="截图保存"></a>截图保存</h2></li><li>平时的微信和QQ都是有默认的截图功能的，可以直接截图保存，以微信来举例，通过查看设置中的快捷键选项可以查看如何进行快速截图。<br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191111135655.png" alt=""><br>啊，这篇文章好水啊，哗哗哗～</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来想查一下如何写程序来提取pdf中的图片来着，然后发现可以用ps来实现，然后就先记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="PDF" scheme="http://yoursite.com/tags/PDF/"/>
    
      <category term="Image" scheme="http://yoursite.com/tags/Image/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-330-PatchingArray</title>
    <link href="http://yoursite.com/2019/11/09/leetcode-330-PatchingArray/"/>
    <id>http://yoursite.com/2019/11/09/leetcode-330-PatchingArray/</id>
    <published>2019-11-09T08:14:19.000Z</published>
    <updated>2019-11-09T08:20:27.100Z</updated>
    
    <content type="html"><![CDATA[<p>今天周六，好好做个题，明天就可以心安理得的出去玩啦！<br>然后就碰见了这个解题方法特别让人觉得奇妙的题目，算法这个东西实在是太神奇了。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p>Input: nums = [1,3], n = 6<br>Output: 1<br>Explanation:<br>Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.<br>Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].<br>Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].<br>So we only need 1 patch.</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><p>Input: nums = [1,5,10], n = 20<br>Output: 2<br>Explanation: The two patches can be [2, 4].</p><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><p>Input: nums = [1,2,2], n = 5<br>Output: 0</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心</p><h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><p>构造了一个miss缺失值，表示不能覆盖的最小值。最开始表示为1，表示此时不能表示范围为[0,1),然后去依次找数组中的值（要注意数组中的数据是排好序的，所以才可以这么用！），如果缺失值小于数组中的值，那么肯定要添加数，如果缺失值要是大于数组中的值，那么那么最小缺失值可以得到更新。最后如果最小缺失值大于n，那么就说明已经完成要求了。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>以sample2也就是nums = [1,5,10], n=20举例来讲</p><ol><li>初始化的时候，数组索引index = 0，最小缺失值miss为1，res为0；</li><li>此时miss&lt;=20成立，没有覆盖到[1,n]的范围，所以进入循环判断，此时nums[0] = 1&lt;=miss 而且index没有超出数组范围，所以miss会更新，加上当前数组索引位置，也就是说miss = 2，表示此时可以表示范围为[0,2)啦。</li><li>然后miss此时仍然不能表示n，继续往后走，此时nums[1] = 5, 是大于miss的，也就是说此时我们最多表示到1，但是你突然来了个5，那我[2,4]的数据怎么办，就只能自己往里添加啦，所以此时为了尽可能表示的数字变得更大，所以此时加上miss本身这个数，从而就可以表示  [0，miss+miss)的数字了，所以此时添加一个2，res在原来的基础上+1变为1，miss也就变成了4；</li><li>[0,4)依然不能表示[0,n],所以还是要继续判断，此时miss仍然小于nums[1],所以我仍然不能用nums中的数字来表示4这个数，所以继续向数组中添加4,然后此时可表示范围变成了[0,8),res+1变成2，添加了4这个数字。</li><li>[0,8)仍然表示不了[0,n],所以仍然没有结束，此时的miss大于nums[1],也就是miss&gt;5成立，所以此时nums到索引1然后再加上添加的元素可以表示数的范围就变成了[0,13).</li><li>[0.13)仍然表示不了[0,20]，所以继续，此时miss大于nums[2],所以如果nums中从0到索引2的所有数字加上之前添加的数字可以表示的数字范围就变成了[0,23).</li><li>[0.23)是可以表示[0,20]的，所以结束，最终结果需要添加两个数，一个2，一个4即可。<br>太神奇了。<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:    </span><br><span class="line">    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;</span><br><span class="line">        int res  = 0;</span><br><span class="line">        long miss = 1, i = 0;</span><br><span class="line">        while(miss &lt;= n)&#123;</span><br><span class="line">            if(i&lt;nums.size() &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">                miss += nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                miss += miss;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天周六，好好做个题，明天就可以心安理得的出去玩啦！&lt;br&gt;然后就碰见了这个解题方法特别让人觉得奇妙的题目，算法这个东西实在是太神奇了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="hard" scheme="http://yoursite.com/tags/hard/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>create-my-leetcode-artical-template</title>
    <link href="http://yoursite.com/2019/11/09/create-my-leetcode-artical-template/"/>
    <id>http://yoursite.com/2019/11/09/create-my-leetcode-artical-template/</id>
    <published>2019-11-09T04:46:16.000Z</published>
    <updated>2019-11-09T04:59:02.744Z</updated>
    
    <content type="html"><![CDATA[<p>在我每次写leetcode解题文章的时候，经常需要搞排版信息，一次两次还好，但是次数多了就会比较烦。那么我们能不能自定义一个属于自己的leetcode文章模版呢？当然可以！于是就有了本篇文章。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="从创建文章说起"><a href="#从创建文章说起" class="headerlink" title="从创建文章说起"></a>从创建文章说起</h3><p>我们在使用如下命令创建文章的时候，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new title</span><br></pre></td></tr></table></figure><p>实际上我们使用的是如下的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post title</span><br></pre></td></tr></table></figure><p>上面的命令是这个命令的缩写形式而已，因为一般搭建都不太会创建草稿（draft）或者页面（page），大家都是创建文章，它太常用了，所以就被设置成了默认选项。</p><h3 id="真实的创建命令"><a href="#真实的创建命令" class="headerlink" title="真实的创建命令"></a>真实的创建命令</h3><p>那么真实使用的创建命令是什么呢？其实是下面这个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>根据<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">官方文档</a>显示，hexo默认的layout有三种，分别是post，draft，page，他们都有自己的默认样式，他们文件本身都在scaffolds目录下面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  blog ls -l scaffolds </span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 liqingwen  staff  33 10 18 21:52 draft.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  44 10 18 21:52 page.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  76 10 21 16:48 post.md</span><br></pre></td></tr></table></figure><p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，所以我们要想创建自己的模版，只要在这里面创建一个leetcode模板即可，然后以后就可以通过如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new leetcode leetcode-number-nanme</span><br></pre></td></tr></table></figure><p>来创建符合对应布局的文章啦。</p><h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><ol><li>先查看模版中的文件有哪些<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  blog ls -l scaffolds </span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 liqingwen  staff  33 10 18 21:52 draft.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  44 10 18 21:52 page.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  76 10 21 16:48 post.md</span><br></pre></td></tr></table></figure></li><li>查看我们常用的post模板中的内容，然后我们照着这个改写就可以啦。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## 查看模版中内容</span><br><span class="line">➜  blog cat scaffolds/post.md </span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- tag1</span><br><span class="line">categories:</span><br><span class="line">- cat1</span><br></pre></td></tr></table></figure></li><li>复制一份post，重命名为leetcode，然后将我们想要的东西都加进去，然后保存即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜  blog cd scaffolds </span><br><span class="line">➜  scaffolds cp post.md leetcode.md</span><br><span class="line">➜  scaffolds ls</span><br><span class="line">draft.md    leetcode.md page.md     post.md</span><br><span class="line"></span><br><span class="line"># 注意这里我使用的是sublime编辑器，然后在文档中添加的内容已经通过后面的cat输出了，大家可以直接赋值。</span><br><span class="line">➜  scaffolds subl leetcode.md </span><br><span class="line"></span><br><span class="line">➜  scaffolds ls</span><br><span class="line">draft.md    leetcode.md page.md     post.md</span><br><span class="line">➜  scaffolds cat leetcode.md </span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- leetcode</span><br><span class="line">- hard,medium,easy</span><br><span class="line">- Greedy, DP, String </span><br><span class="line">categories:</span><br><span class="line">- 算法训练</span><br><span class="line">---</span><br><span class="line">摘要内容</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line">### sample1</span><br><span class="line">## 解题思路</span><br><span class="line">## 巧妙之处</span><br><span class="line">## 解题代码</span><br></pre></td></tr></table></figure></li><li>尝试使用leetcode模版<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  scaffolds cd ..</span><br><span class="line">➜  blog hexo new leetcode &quot;leetcode-406-QueueReconstructionbyHeight&quot;   </span><br><span class="line">INFO  Created: ~/workplace/blog/source/_posts/leetcode-406-QueueReconstructionbyHeight.md</span><br><span class="line">➜  blog subl  source/_posts/leetcode-406-QueueReconstructionbyHeight.md</span><br></pre></td></tr></table></figure>大功告成，于是就可以可以很开心的写文章啦。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我每次写leetcode解题文章的时候，经常需要搞排版信息，一次两次还好，但是次数多了就会比较烦。那么我们能不能自定义一个属于自己的leetcode文章模版呢？当然可以！于是就有了本篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="template" scheme="http://yoursite.com/tags/template/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-67-AddBinary</title>
    <link href="http://yoursite.com/2019/11/08/leetcode-67-AddBinary/"/>
    <id>http://yoursite.com/2019/11/08/leetcode-67-AddBinary/</id>
    <published>2019-11-08T15:14:27.000Z</published>
    <updated>2019-11-08T15:27:42.566Z</updated>
    
    <content type="html"><![CDATA[<p>今天晚上总结了一下c++中string的常用的属性和方法，一时手痒，所以就找了个题目练练手，记录一下。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given two binary strings, return their sum (also a binary string).</p><p>The input strings are both non-empty and contains only characters 1 or 0.</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p>Input: a = “11”, b = “1”<br>Output: “100”</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p>Input: a = “1010”, b = “1011”<br>Output: “10101”</p><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>第一反应其实和两个数相加的那个题目类似，只是这里需要反向遍历即可。<br>这里的一个比较好的技巧就是学会补零。比如说1和1001进行相加，很明显，结果是1010。计算结果可以将1补充为0001，这样就可以数据对齐，然后就可以方便计算而不容易出现空指针了。</p><h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addBinary(string a, string b) &#123;</span><br><span class="line">        int alen = a.size();</span><br><span class="line">        int blen = b.size();</span><br><span class="line">        int mlen = max(alen, blen);</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        for(int i = 0; i &lt; mlen; i++)&#123;</span><br><span class="line">            int tempa = alen&gt;i?a[alen-i-1]-&apos;0&apos;:0;</span><br><span class="line">            int tempb = blen&gt;i?b[blen-i-1]-&apos;0&apos;:0;</span><br><span class="line">            int tres = tempa+tempb+carry;</span><br><span class="line">            if(tres == 0)&#123;</span><br><span class="line">                res.insert(0,1,&apos;0&apos;);</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else if(tres == 1)&#123;</span><br><span class="line">                res.insert(0,1,&apos;1&apos;);</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else if(tres == 2)&#123;</span><br><span class="line">                res.insert(0,1,&apos;0&apos;);</span><br><span class="line">                carry = 1;</span><br><span class="line">            &#125;else if(tres == 3)&#123;</span><br><span class="line">                res.insert(0,1,&apos;1&apos;);</span><br><span class="line">                carry = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry == 1)&#123;</span><br><span class="line">            res.insert(0,1,&apos;1&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天晚上总结了一下c++中string的常用的属性和方法，一时手痒，所以就找了个题目练练手，记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="easy" scheme="http://yoursite.com/tags/easy/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-72-EditDistance</title>
    <link href="http://yoursite.com/2019/10/24/leetcode-72-EditDistance/"/>
    <id>http://yoursite.com/2019/10/24/leetcode-72-EditDistance/</id>
    <published>2019-10-24T06:26:49.000Z</published>
    <updated>2019-10-24T06:32:19.247Z</updated>
    
    <content type="html"><![CDATA[<p>编辑距离是一个非常经典的动态规划的题目，之前搞懂过，但是总是会忘，所以又搞了一遍，顺便做个笔记。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">题目描述</a></h2><p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p><p>You have the following 3 operations permitted on a word:</p><ol><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ol><h2 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a>题目解读</h2><p>就是求两个字符串的最小编辑距离，也就是计算word1最少可以经过多少次变化(插入，删除，替换)可以变成word2。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="动态规划的具体思路"><a href="#动态规划的具体思路" class="headerlink" title="动态规划的具体思路"></a>动态规划的具体思路</h3><ol><li>dp[i][j]表示word1的[0,i)变成word2的[0,j)位需要多少次变化。</li><li>对于第0行，dp[0][i] = i for 0&lt;= i &lt;= len2; (len2是word2的字符串长度)</li><li>对于第0列，dp[i][0] = i for 0=&lt; i &lt;= len1; (len1是word1的字符串长度)</li><li>如果最后一位相同，则arr[i][j] = arr[i-1][j-1]</li><li>若是判断的最后一位不同，则arr[i][j] = min(arr[i-1][j]+1, arr[i][j-1]+1 ,arr[i-1][j-1]+1)</li><li>最后返回arr[len1][len2]</li></ol><h3 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h3><p>这里解释一下第4步，也是看了好久才明白的。</p><p>下面以word1=”abb”,word2=”ac”为例。</p><ol><li>首先明确一下问题：我们现在要求的是abb需要多少步会变到ac，而假设我们已经知道了ab变ac，abb变a，ab变a三种情况，我们只需要现在的情况变到之前已知的情况就解决了。</li><li>假设abb-&gt;ac是从ab-&gt;ac变过来的，那么我们只要将abb去掉最后一个b就可以，剩下的就是要考虑ab如何变成ac了。也就是arr[i][j]=arr[i-1][j]+1;</li><li>假设abb-&gt;ac是从abb-&gt;a变过来的，那么我们只要在abb后面插入一个c就可以实现最后一位的匹配，剩下的就是考虑abb如何变成a了。也就是arr[i][j] = arr[i][j-1]+1;</li><li>假设abb-&gt;ac是从ab-&gt;a变过来的，那么我们只要将abb的最后一位变成c，剩下的就是考虑如何将ab变成a了。也就是arr[i][j]=arr[i-1][j-1]+1;</li><li>最后我们选一个从三种方式中修改次数最小的一个就可以了</li></ol><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        int len1 = word1.length();</span><br><span class="line">        int len2 = word2.length();</span><br><span class="line">        </span><br><span class="line">        int arr[len1+1][len2+1];</span><br><span class="line">        memset(arr,0,sizeof arr);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;= len1; i++)&#123;</span><br><span class="line">            arr[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;= len2; i++)&#123;</span><br><span class="line">            arr[0][i] = i;</span><br><span class="line">        &#125;      </span><br><span class="line">         for(int i = 1; i &lt;= len1; i++)&#123;</span><br><span class="line">             for(int j = 1;j &lt;= len2; j++)&#123;</span><br><span class="line">                 if(word1[i-1]==word2[j-1])&#123;</span><br><span class="line">                     arr[i][j] = arr[i-1][j-1];</span><br><span class="line">                 &#125;else&#123;</span><br><span class="line">                     arr[i][j] = min(min(arr[i-1][j],arr[i][j-1]),arr[i-1][j-1])+1;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        // for(int i = 0; i &lt;= len1; i++)&#123;</span><br><span class="line">        //      for(int j = 0;j &lt;= len2; j++)&#123;</span><br><span class="line">        //         cout&lt;&lt;arr[i][j]&lt;&lt;&apos;\t&apos;;         </span><br><span class="line">        //      &#125;</span><br><span class="line">        //     cout&lt;&lt;endl;</span><br><span class="line">        // &#125;</span><br><span class="line">        </span><br><span class="line">        return arr[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编辑距离是一个非常经典的动态规划的题目，之前搞懂过，但是总是会忘，所以又搞了一遍，顺便做个笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="hard" scheme="http://yoursite.com/tags/hard/"/>
    
  </entry>
  
  <entry>
    <title>build-image-hosting-service-with-github-and-PicGo</title>
    <link href="http://yoursite.com/2019/10/23/build-image-hosting-service-with-github-and-PicGo/"/>
    <id>http://yoursite.com/2019/10/23/build-image-hosting-service-with-github-and-PicGo/</id>
    <published>2019-10-23T02:38:32.000Z</published>
    <updated>2019-10-23T02:43:49.510Z</updated>
    
    <content type="html"><![CDATA[<p>图床，就是用来存放图片的地方。</p><p>目前各个网站为了保证自己的图片不会被其他人盗用，几乎都设置了访问条件验证（比如通过网站登录所保存的cookie等），这样的话其他人可能就访问不到你的图片了，而我写博客就是想给别人看的呀，所以搭建一个自己的图床就迫在眉睫。</p><a id="more"></a><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol><li>github账号</li><li>良好的网络条件</li><li>耐心</li></ol><h2 id="具体做法参考"><a href="#具体做法参考" class="headerlink" title="具体做法参考"></a>具体做法参考</h2><ol><li><a href="https://juejin.im/entry/5c4ec5aaf265da614420689f" target="_blank" rel="noopener">掘金-PicGo+GitHub图床，让Markdown飞</a></li></ol><p>按照这个流程就可以完美搭建起来了，我就是照着这个做的。</p><ol start="2"><li><a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo github下载地址</a></li></ol><p>这个是PicGo的下载地址，选择最新版本的进行下载即可。mac下载dmg格式，win下载exe格式即可。</p><ol start="3"><li><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E9%A2%84%E8%A7%88" target="_blank" rel="noopener">PicGo 官方文档</a></li></ol><p>之所以把这个放上，是因为这个PicGo其实有很多扩展或者其他的功能，包括设置各种快捷键，各种图床的支持（包括七牛，阿里，github，腾讯云，又拍云等等。话说微博图床现在放盗链了，不建议使用），各种代理等的支持，大家可以进行私人定制，将这个软件做成自己喜欢的样子。</p><h2 id="本文感受"><a href="#本文感受" class="headerlink" title="本文感受"></a>本文感受</h2><ol><li>github是个好地方，开源的力量极其伟大。</li></ol><p>本来享用iPic来进行图片上传来着，但是它默认只给你微博图床，而现在不能用了。然后如果要开启其他图床支持，是要花钱的，难过的是我都要准备花钱了，网络问题，付费一直不成功，所以就找到了PicGo，完美。</p><ol start="2"><li>有机会还是要花钱买服务</li></ol><p>github尽管免费，但是说实话，访问是有延迟的，七牛云我也注册了，但是实名认证需要时间，所以我就先直接用github来搭建图床了。等到博客访问量大了的时候到时候再付费买七牛云存储吧，嘿嘿。</p><ol start="3"><li>好的教程感觉一份就够了</li></ol><p>所以对于自己感觉比较好的教程我就直接放链接了，如果有补充的话我再专门写文章来介绍一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图床，就是用来存放图片的地方。&lt;/p&gt;
&lt;p&gt;目前各个网站为了保证自己的图片不会被其他人盗用，几乎都设置了访问条件验证（比如通过网站登录所保存的cookie等），这样的话其他人可能就访问不到你的图片了，而我写博客就是想给别人看的呀，所以搭建一个自己的图床就迫在眉睫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用技能" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="FigureBed" scheme="http://yoursite.com/tags/FigureBed/"/>
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
      <category term="PicGo" scheme="http://yoursite.com/tags/PicGo/"/>
    
  </entry>
  
  <entry>
    <title>kickstart-2019-G-T2-TheEquation</title>
    <link href="http://yoursite.com/2019/10/22/kickstart-2019-G-T2-TheEquation/"/>
    <id>http://yoursite.com/2019/10/22/kickstart-2019-G-T2-TheEquation/</id>
    <published>2019-10-22T13:29:55.000Z</published>
    <updated>2019-10-23T02:01:05.535Z</updated>
    
    <content type="html"><![CDATA[<p>还是上周和同学一起尝试的kickstart第G轮比赛，这个是第二题的思路和解法。<br>在经历各种报错，各种思路修正之后终于搞定了！快写下来！</p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e02/000000000018fe36" target="_blank" rel="noopener">题目描述</a></h1><p><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/kickstart-2019-g-t2-description.jpg" alt=""><br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/kickstart-2019-g-t2-sample.jpg" alt=""></p><h1 id="题目理解"><a href="#题目理解" class="headerlink" title="题目理解"></a>题目理解</h1><p>就是找一个最大的K，使得K和每个元素进行亦或运算的和小于某个值。</p><h1 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h1><h2 id="Test-set1-暴力求解"><a href="#Test-set1-暴力求解" class="headerlink" title="Test set1 暴力求解"></a>Test set1 暴力求解</h2><p>下面的代码仅仅适应于小测试集。而之所以设置从127开始找，是因为看到了他给的测试集的范围。<br>对于Test set1中的每个元素而言，0&lt;=Ai&lt;=100,所以可以用6位表示。M也是可以用6位来表示，如果K的最高位不是第6位，而是第7位甚至更高，那么取亦或之后必然会大于128也就大于M，所以对于这个测试集来说，只要从127往下找到第一个符合条件的数字即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">// typedef long long ll;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">void solve(int case_num)&#123;</span><br><span class="line">    int N,M;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    int res = 0;</span><br><span class="line">    int temp = 0 ;</span><br><span class="line">    vector&lt;int&gt; arr;</span><br><span class="line">    bool find = false;</span><br><span class="line">    for(int i =0;i&lt;N;i++)&#123;</span><br><span class="line">        int mi;</span><br><span class="line">        cin &gt;&gt; mi;</span><br><span class="line">        arr.emplace_back(mi);</span><br><span class="line">    &#125;</span><br><span class="line">      for(int i = 127;i&gt;=0;i--)&#123;</span><br><span class="line">          for(int j=0;j&lt;N;j++)&#123;</span><br><span class="line">              temp += arr[j]^i;</span><br><span class="line">          &#125;</span><br><span class="line">          if(temp &lt;= M)&#123;</span><br><span class="line">              find = true;</span><br><span class="line">              res = i;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">          temp = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      res = find?res:-1;</span><br><span class="line">     cout &lt;&lt; &quot;Case #&quot; &lt;&lt; case_num &lt;&lt; &quot;: &quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">    solve(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心-位运算巧妙运用"><a href="#贪心-位运算巧妙运用" class="headerlink" title="贪心+位运算巧妙运用"></a>贪心+位运算巧妙运用</h2><p>按照上面的方法，我们可以发现这个大样例的0&lt;=Ai&lt;=pow(10,15),对应M也是这个范围。我们可以发现要用49位来表示，也就是说从pow(2,50)开始往下找到第一个符合条件的即可。但是这个数太大了。<br>然后我们发现原来式子的值可以这么改。<br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191023095812.png" alt=""><br>这样我们就通过位运算来找最大的K值了。<br>怎么找呢。我们找K的时候也是按照比特位从高位开始找，尽可能让高位取1，注意这里要保证当我这个位置取1之后加上后面的所有值的最小值不会超过M，那么才可以取。如果取不了1，那就试一下可不可以取0，同理如果这个位置取0，也要看加上后面所有位所形成的最小值会不会超过K，若是没有超过，则可以取，如果超过，那么说明这个数不存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int maxn = 50;</span><br><span class="line">LL pre[maxn], zeros[maxn], ones[maxn], minc[maxn], vis[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    for (int t = 1; t &lt;= T; ++t) &#123;</span><br><span class="line">        LL N, M;</span><br><span class="line">        </span><br><span class="line">        scanf(&quot;%lld %lld&quot;,&amp;N, &amp;M);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0;i&lt;maxn;i++)&#123;</span><br><span class="line">              vis[i] = 0;</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;N; i++)&#123;</span><br><span class="line">            LL temp;</span><br><span class="line">            scanf(&quot;%lld&quot;, &amp;temp);</span><br><span class="line">            for(int j = maxn - 1; j &gt;= 0; j--)&#123;</span><br><span class="line">                if((temp&gt;&gt;j)&amp;1)&#123;</span><br><span class="line">                    vis[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = maxn-1; i &gt;= 0; i--)&#123;</span><br><span class="line">            LL a = vis[i] * (1LL&lt;&lt;i);</span><br><span class="line">            LL b = (N-vis[i]) * (1LL&lt;&lt;i);</span><br><span class="line">            ones[i] = a;</span><br><span class="line">            zeros[i] = b;</span><br><span class="line">            minc[i] = min(a,b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre[0] = 0;</span><br><span class="line">        for(int i = 1;i &lt; maxn; i++)&#123;</span><br><span class="line">            pre[i] = pre[i-1]+minc[i-1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL res = 0;</span><br><span class="line">        LL temp = 0;</span><br><span class="line">        for(LL i = maxn - 1; i &gt;=0; i--)&#123;</span><br><span class="line">            if((zeros[i]+temp+pre[i])&lt;=M)&#123;</span><br><span class="line">                temp += zeros[i];</span><br><span class="line">                res += (1LL&lt;&lt;i);</span><br><span class="line">            &#125;else if(temp+ones[i]+pre[i]&lt;=M)&#123;</span><br><span class="line">                temp += ones[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res = -1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld \n&quot;, t, res);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方一定需要搞清楚的是，从最高位开始找的时候，并不是取1就可以，因为后面所有的位的0和1的情况会形成一个数字的范围，而不是0.一定要注意。</p><h1 id="本题收获"><a href="#本题收获" class="headerlink" title="本题收获"></a>本题收获</h1><ol><li>要注意看测试集的测试用例的条件，尤其是大小，直接会决定我们的数据类型是int或者long long或者其他。</li><li>要注意题目隐含的条件，这个条件并不是单纯的从最高位到最低位的贪心，而是有后续隐含条件的贪心，所以一定要注意。</li><li>对于位运算，一定要学会使用移位运算符以及对应的位运算操作，有时候可能会有巧妙的作用。</li><li>因为c++的灵活性，可以通过地址进行操作，所以在使用数组的时候一定要注意不要越界，在进行相关条件判断的时候一定要小心。当报错说运行时错误的时候，多半就是for循环的条件写错了或者数组越界了。还有当你发现在本地跑的和在kickstart上跑同一份代码，但是结果不一样的时候，多半也是地址错了，以后要注意！</li><li>做出来这个题目的感觉很爽啊，继续加油～</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还是上周和同学一起尝试的kickstart第G轮比赛，这个是第二题的思路和解法。&lt;br&gt;在经历各种报错，各种思路修正之后终于搞定了！快写下来！&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="kickstart" scheme="http://yoursite.com/tags/kickstart/"/>
    
  </entry>
  
  <entry>
    <title>kickstart-2019-G-T1-BookReading</title>
    <link href="http://yoursite.com/2019/10/22/kickstart-2019-G-T1-BookReading/"/>
    <id>http://yoursite.com/2019/10/22/kickstart-2019-G-T1-BookReading/</id>
    <published>2019-10-22T09:38:01.000Z</published>
    <updated>2019-10-23T02:05:18.981Z</updated>
    
    <content type="html"><![CDATA[<p>上周六和同学一起尝试了一下Google Kickstart的题目，开了开眼，涨了涨见识！<br>本文是G轮第一题BookReading的思路以及代码，留个纪念。</p><a id="more"></a><h2 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e02/000000000018fd0d" target="_blank" rel="noopener">题目详情</a></h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>Supervin is a librarian handling an ancient book with N pages, numbered from 1 to N. Since the book is too old, unfortunately M pages are torn out: page number P1, P2, …, PM.</p><p>Today, there are Q lazy readers who are interested in reading the ancient book. Since they are lazy, each reader will not necessarily read all the pages. Instead, the i-th reader will only read the pages that are numbered multiples of Ri and not torn out. Supervin would like to know the sum of the number of pages read by each reader.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, M, and Q, the number of pages in the book, the number of torn out pages in the book, and the number of readers, respectively. The second line contains M integers, the i-th of which is Pi. The third line contains Q integers, the i-th of which is Ri.</p><h3 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h3><p>Time limit: 40 seconds per test set.<br>Memory limit: 1GB.<br>1 ≤ T ≤ 100.<br>1 ≤ P1 &lt; P2 &lt; … &lt; PM ≤ N.<br>1 ≤ Ri ≤ N, for all i.</p><p>Test set 1 (Visible)<br>1 ≤ M ≤ N ≤ 1000.<br>1 ≤ Q ≤ 1000.</p><p>Test set 2 (Hidden)<br>1 ≤ M ≤ N ≤ 105.<br>1 ≤ Q ≤ 105.</p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191023100352.png" alt=""></p><h2 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h2><p>图书管理员想知道大家一共读了多少页书，需要我们统计。<br>已知情况是书的总页数N，坏了的页数M，有Q个读者。<br>然后知道坏的M分别是那些页，知道读者每个人都要读那些页（实际上知道的是基数，这个读者会读这个基数的整数倍）。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果大家想看最终结果，可以直接翻到最后，然后前面的代码写的比较乱，后来经过王博指点，有了很大的改善。好的代码习惯还是要保持的。</p><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>一看题目很简单，对于每个人来说，如果书籍不坏，那么他可以读页数/基数页，然后看看坏了的页数中有几个是基数的倍数，减去就可以。然后我们最终的结果就是每个人的结果加和。<br>代码如下，写的很乱，而且第二个样例不出意外的超时了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solve(int case_num)&#123;</span><br><span class="line">    int N,M,Q;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;Q;</span><br><span class="line">    vector&lt;int&gt; torn;</span><br><span class="line">    int res =0;</span><br><span class="line">    //vector&lt;int&gt; reader;</span><br><span class="line">    for(int i = 0;i&lt;M;i++)&#123;</span><br><span class="line">        int mi;</span><br><span class="line">        cin &gt;&gt; mi;</span><br><span class="line">        torn.emplace_back(mi);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i =0;i&lt;Q;i++)&#123;</span><br><span class="line">        int ri;</span><br><span class="line">        cin &gt;&gt; ri;</span><br><span class="line">        int num = N/ri;</span><br><span class="line">        int sortnum =0;</span><br><span class="line">        for(int j = 0;j&lt;M;j++)&#123;</span><br><span class="line">            if(torn[j]%ri==0)&#123;</span><br><span class="line">                sortnum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += (num - sortnum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Case #&quot; &lt;&lt; case_num &lt;&lt; &quot;: &quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">    solve(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划求解"><a href="#动态规划求解" class="headerlink" title="动态规划求解"></a>动态规划求解</h3><p>仔细想想，其实我们上面暴力的时间复杂度是O（M<em>Q），当破坏的页数很多的时候，很多判断是无效的，没有意义的，比如某位读者只读2的倍数，那么我其实只要判断2，4，6，2</em>n&lt;=N这些页就可以。其他的页数完全可以不用判断，所以这个地方可以简化。于是是不是可以把每个基数对应的结果都算出来，然后当读读者的基数的时候，直接将其求和就可以呢？当然可以！于是就有了下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int a[MAXN],ans[MAXN];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t,x;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">        int N,M,Q;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;Q);</span><br><span class="line"></span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            a[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            a[x] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i&lt;=N; i++)&#123;</span><br><span class="line">            for(int j =i; j &lt;= N; j+=i)&#123;</span><br><span class="line">                 ans[i] += a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LL res =0;</span><br><span class="line">        for( int i = 1; i &lt;= Q; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            res += ans[x];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,res);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0;i&lt;=N;i++)&#123;</span><br><span class="line">            ans[i] = 0;</span><br><span class="line">            a[i] =0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进一步动态规划"><a href="#进一步动态规划" class="headerlink" title="进一步动态规划"></a>进一步动态规划</h3><p>上面的方法把所有的基数对应的结果都算出来了，但是其实中间的很多结果我们是用不到的，比如我们就两个读者，分别读2的倍数和3的倍数，而上面那个方法将1-N的所有结果都算出来了，最后只用了2和3对应的结果而已，这样就造成了浪费。所以我们是不是可以将结果进行保存，下次来了一个读者，看看之前有没有算过，如果算过，就直接用之前保存的结果，如果没有算过，那么就计算一下，然后保存起来呢？当然可以！于是就有了下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int getPage(int N,int i,int arr[])&#123;</span><br><span class="line">    int res =0;</span><br><span class="line">    for(int j = i; j&lt;=N; j+=i)&#123;</span><br><span class="line">        res += arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a[MAXN],ans[MAXN];</span><br><span class="line">int N,M,Q;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t,x;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;Q);</span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            a[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            a[x] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(ans, 0, sizeof ans);</span><br><span class="line">      </span><br><span class="line">        LL res =0;</span><br><span class="line">        for( int i = 1; i &lt;= Q; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            if(ans[x]==0)&#123;</span><br><span class="line">                ans[x] = getPage(N, x,a);</span><br><span class="line">            &#125;</span><br><span class="line">            res += ans[x];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,res);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本题收获"><a href="#本题收获" class="headerlink" title="本题收获"></a>本题收获</h2><ol><li>了解到了比较好的编码规范，以后会应用到实践中。</li><li>锻炼了自己分析问题的能力，提高算法的效率很重要，而其中的意识要逐渐培养。</li><li>认识到了c++灵活但是有时候太灵活，以后需要好好注意如何使用。</li><li>知道了kickstart的难度以及自己的水平。刷题路漫漫，以后请加油。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周六和同学一起尝试了一下Google Kickstart的题目，开了开眼，涨了涨见识！&lt;br&gt;本文是G轮第一题BookReading的思路以及代码，留个纪念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法训练" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="kickstart" scheme="http://yoursite.com/tags/kickstart/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>终端工具tmux资料分享</title>
    <link href="http://yoursite.com/2019/10/21/tmux-reference/"/>
    <id>http://yoursite.com/2019/10/21/tmux-reference/</id>
    <published>2019-10-21T08:36:02.000Z</published>
    <updated>2019-10-21T08:45:18.419Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html" target="_blank" rel="noopener">阮一峰-Tmux 使用教程</a><br>从浅入深，娓娓道来，非常棒。</li><li><a href="https://louiszhai.github.io/2017/09/30/tmux/#Tmux%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener">路易斯-Tmux使用手册</a><br>大牛无疑，介绍的非常干练，私人定制部分写的特别好。</li><li><a href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7#file-tmux-cheatsheet-markdown" target="_blank" rel="noopener">GitHub-Tmux 快捷键 &amp; 速查表 &amp; 简明教程</a><br>方便大家使用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2019/10/tmux.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰-Tmux 使用教程&lt;/a&gt;&lt;br&gt;从浅入深，娓娓道来，非常棒。&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="工具推荐" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="tmux" scheme="http://yoursite.com/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>喜大普奔，庆文又搭博客了。</title>
    <link href="http://yoursite.com/2019/10/18/hello-world-1/"/>
    <id>http://yoursite.com/2019/10/18/hello-world-1/</id>
    <published>2019-10-18T14:47:37.000Z</published>
    <updated>2019-10-19T04:01:24.200Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到一句话，</p><pre><code>有了自己的博客，就仿佛自己在互联网中留下了自己的脚印.</code></pre><p>还挺有诗意的，所以我就把这个博客搭建起来了。</p><a id="more"></a><h1 id="博客写点啥呢"><a href="#博客写点啥呢" class="headerlink" title="博客写点啥呢"></a>博客写点啥呢</h1><h2 id="可能会帮到别人的东西"><a href="#可能会帮到别人的东西" class="headerlink" title="可能会帮到别人的东西"></a>可能会帮到别人的东西</h2><p>本部分包含但不限于代码的bug解决办法，代码规范，leetcode题解。</p><h2 id="自己觉得需要整理的东西"><a href="#自己觉得需要整理的东西" class="headerlink" title="自己觉得需要整理的东西"></a>自己觉得需要整理的东西</h2><p>本部分包含但不限于对于某个问题的求解过程。</p><h2 id="也许写点乱七八糟的推荐"><a href="#也许写点乱七八糟的推荐" class="headerlink" title="也许写点乱七八糟的推荐"></a>也许写点乱七八糟的推荐</h2><p>本部分包含但是不限于对于书籍电影动漫等的推荐。</p><p>目标就是等我回忆青春的时候，再来这个博客瞅瞅，让我能够感慨一句，我当年也干了很多事情呀。</p><h1 id="博客搭建参考"><a href="#博客搭建参考" class="headerlink" title="博客搭建参考"></a>博客搭建参考</h1><ol><li><a href="https://cuiqingcai.com/7625.html" target="_blank" rel="noopener">崔庆才-利用 GitHub + Hexo + Next 从零搭建一个博客</a></li><li><a href="https://juejin.im/post/5a308ae551882540f363879a" target="_blank" rel="noopener">为你的hexo博客配置个性域名</a></li><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo-中文文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到一句话，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;有了自己的博客，就仿佛自己在互联网中留下了自己的脚印.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还挺有诗意的，所以我就把这个博客搭建起来了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="文言文语" scheme="http://yoursite.com/categories/%E6%96%87%E8%A8%80%E6%96%87%E8%AF%AD/"/>
    
    
      <category term="杂事" scheme="http://yoursite.com/tags/%E6%9D%82%E4%BA%8B/"/>
    
  </entry>
  
</feed>
