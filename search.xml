<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>check-login-without-password</title>
    <url>/2022/03/03/check-login-without-password/</url>
    <content><![CDATA[<p>通过find命令查找authorized_keys文件来查询系统内是否存在免密登陆情况。</p>
<a id="more"></a>
<h2 id="原理说明">原理说明</h2>
<p>机器A某用户如果要免秘登陆到机器B，则需要在机器A上通过类似ssh-keygen -t rsa的命令生成公钥和私钥，然后将公钥发送到机器B对应用户目录下的.ssh目录下的authorized_keys文件中。</p>
<p>所以反推，若想查看是否存在免密登陆，则只需要查看系统用户目录下是否存在authorized_keys目录即可。</p>
<h2 id="详细命令">详细命令</h2>
<h3 id="root用户">root用户</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /root -name  authorized_keys</span><br></pre></td></tr></table></figure>
<h3 id="普通用户">普通用户</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /home/*/.ssh -name authorized_keys</span><br></pre></td></tr></table></figure>
<p>为保证系统的安全性，在确认没有必要的情况下 直接通过rm -rf<br>
命令删除对应的文件即可。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>golang-bug-sf-IsExported-undefined</title>
    <url>/2022/03/03/golang-bug-sf-IsExported-undefined/</url>
    <content><![CDATA[<p>通过升级golang版本为1.17.X解决sf.IsExported undefined问题。</p>
<a id="more"></a>
<h2 id="问题描述">问题描述</h2>
<p>在编写项目的时候，通过go build命令生成可执行二进制文件时候，碰见sf.IsExported undefined问题。</p>
<p>经过查询,主要是<a href="https://github.com/kubernetes-sigs/controller-tools/issues/643" target="_blank" rel="noopener">github-issue</a>，可以发现大概率是golang版本问题，问题出现在golang1.16.X。</p>
<h2 id="解决方案">解决方案</h2>
<p>升级系统内golang版本为golang1.17.X即可。</p>
<p>但是考虑到系统内其他的项目可能仍然需要原来的golang1.16版本,所以要设置系统对于多版本golang的支持。</p>
<h2 id="详细命令">详细命令</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://go.dev/dl/go1.17.7.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -C /usr/local/go117 -xzvf go1.17.7.linux-amd64.tar.gz </span><br><span class="line"></span><br><span class="line">ln -s /usr/local/go117/go/bin /usr/bin/go117</span><br></pre></td></tr></table></figure>
<p>升级完成后可以通过如下方式查看目前系统内的golang命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go version</span><br><span class="line">go117 version</span><br></pre></td></tr></table></figure>
<p>通过go117 build命令重新编译项目，上述碰到的问题得到解决。</p>
<p>PS: 一定要善于使用搜索引擎啊！！！</p>
]]></content>
      <categories>
        <category>bug-records</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos系统中安装golang环境</title>
    <url>/2021/08/05/Install-golang-in-centos-system/</url>
    <content><![CDATA[<p>本文将介绍如何在centos系统中安装golang环境。</p>
<a id="more"></a>
<h2 id="一、centos安装golang环境流程">一、centos安装golang环境流程</h2>
<h3 id="1、golang仓库选择合适的package">1、golang仓库选择合适的package</h3>
<p>从如下两个网址中选择适合自己机器的package,右键复制链接地址得到对应package的下载地址。重点关注第二个网址，这也是写本文的目的。</p>
<ul>
<li><a href="https://golang.org/dl/" target="_blank" rel="noopener">golang官方仓库</a></li>
<li><a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">golang-Google仓库</a></li>
</ul>
<h3 id="2、服务器下载">2、服务器下载</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget  https://golang.google.cn/dl/go1.16.6.linux-amd64.tar.gz # 前面复制的目标package的下载网址。</span><br><span class="line">rm -rf /usr/local/go </span><br><span class="line">tar -C /usr/local -xzf go1.16.6.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="3、将go相关命令添加到环境变量中">3、将go相关命令添加到环境变量中</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line"># 添加如下内容</span><br><span class="line">export PATH=$PATH:/usr/local/go/bin </span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<h3 id="4、golang环境确认">4、golang环境确认</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>
<h2 id="二、参考文档。">二、参考文档。</h2>
<ol>
<li><a href="https://golang.org/doc/install" target="_blank" rel="noopener">golang-doc-install</a></li>
<li><a href="https://www.runoob.com/go/go-environment.html" target="_blank" rel="noopener">golang环境安装</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Goland配置默认文件头信息</title>
    <url>/2021/01/18/goland-default-header-information/</url>
    <content><![CDATA[<p>本文介绍了如何给Goland编辑器配置文件头的默认信息。</p>
<a id="more"></a>
<p>点击Goland-&gt;Preference进入goland配置页面。<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20210118154352.png" alt=""><br>
一图搞定！</p>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>Goland</tag>
      </tags>
  </entry>
  <entry>
    <title>curl命令下载资源速度缓慢解决方案</title>
    <url>/2020/12/15/curl%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90%E9%80%9F%E5%BA%A6%E7%BC%93%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>在服务器下载资源往往会通过curl或者wget命令，但是有时部分资源会因为网络问题下载缓慢甚至直接下载失败。<br>
本文提出三种解决方案来解决这个问题。</p>
<a id="more"></a>
<h2 id="修改hosts文件解决DNS污染问题">修改hosts文件解决DNS污染问题</h2>
<p>类似于githubusercontent.com等网站会因为dns解析失败而不能访问成功。此时我们可以通过修改hosts文件来解决这个问题。</p>
<ol>
<li>打开网站<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">ipaddress</a>，输入不能访问的资源的地址，获取对应地址的ip地址。比如我们输入raw.githubusercontent.com网站<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20201215095532.png" alt=""><br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20201215095655.png" alt=""><br>
可以看到对应的ip地址为199.232.96.133</li>
</ol>
<p>此时，我们修改/etc/hosts文件，在文件的最后添加如下内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">199.232.96.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p>从而事情就可以得到解决。</p>
<p>为方便大家使用，github的<a href="https://github.com/hawtim/blog/issues/10" target="_blank" rel="noopener">解决curl connection refused问题</a>的issue已经为我们总结了常见的几个更改的网址，我一并放在此处供大家使用，直接拷贝并追加到/etc/hosts文件中即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">199.232.68.133 raw.githubusercontent.com</span><br><span class="line">199.232.68.133 user-images.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars2.githubusercontent.com</span><br><span class="line">199.232.68.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure>
<h2 id="下载源码自行编译">下载源码自行编译</h2>
<p>有些package会提供多种方式供大家下载使用，比如yum安装、apt-get安装、brew安装，curl下载后sh安装。<br>
除此之外，其实还有一种常见的安装方式就是项目会提供源代码，然后用户下载后自行通过make命令进行编译，之后再将对应的二进制执行程序复制到/usr/local/bin目录下。</p>
<h2 id="其他主机拷贝">其他主机拷贝</h2>
<p>可以通过scp命令将其他主机已经安装好的二进制文件复制到本机。相关scp的使用说明可以参见文章<a href="https://www.runoob.com/linux/linux-comm-scp.html" target="_blank" rel="noopener">Linux scp命令</a></p>
<p>我暂时知道的解决方式就上面三种，如果以后有其他方式可以再补充吧。</p>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>cron表达式学习</title>
    <url>/2020/12/09/learn-cron-expression/</url>
    <content><![CDATA[<p>Cron语法经常用于定时任务的设定，如定时进行数据采集任务，定时进行数据备份任务等。<br>
本文对cron表达式进行了简单介绍。</p>
<a id="more"></a>
<h2 id="语法说明">语法说明</h2>
<p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201208212253.png" alt=""></p>
<ol>
<li>每个cron指令一般包含5个部分，分别对应分钟、小时、天、月、周。 每个部分用空格隔开。</li>
<li>每个部分的通用标志。</li>
</ol>
<ul>
<li>* : 表示任意值</li>
<li>, ：表示值的列表</li>
<li>- ：表示值的范围</li>
<li>/ ：表示值的步长</li>
</ul>
<ol start="3">
<li>每个值的取值范围</li>
</ol>
<ul>
<li>分钟： 0 - 59</li>
<li>小时：0 - 23</li>
<li>天：1 - 31</li>
<li>月：1 - 12</li>
<li>周：0 - 6</li>
</ul>
<h2 id="举例说明">举例说明</h2>
<ol>
<li>每隔十分钟执行一次</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*/10 * * * *</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201208231301.png" alt=""><br>
2. 双月中每周一周二的前两个小时每隔5分钟执行一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*/5 0-2 * */2 1,2</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201208231642.png" alt=""></p>
<h2 id="后续更新">后续更新</h2>
<p>本部分参考盖若博主的文章，属于cron语法使用的升级版。</p>
<ol>
<li>如果cron表达式中有6个值，则第一个表示秒。</li>
<li>如果cron表示式中有7个值，则最后一个表示年。<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20201209100616.png" alt=""><br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20201209100647.png" alt=""></li>
</ol>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://crontab.guru/#*_*_*_*_*" target="_blank" rel="noopener">在线解析crontab guru</a></li>
<li><a href="https://www.gairuo.com/p/cron-expression-sheet" target="_blank" rel="noopener">盖若-Cron 定时任务表达式手册</a></li>
</ol>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>cron</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter设置多编程语言支持</title>
    <url>/2020/10/17/jupyter%E8%AE%BE%E7%BD%AE%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p>本篇文章主要介绍如何设置jupyter notebook使其在支持python的基础上支持octave和R语言。</p>
<a id="more"></a>
<p><a href="https://github.com/jupyter/notebook" target="_blank" rel="noopener">jupyter notebook</a>是目前应用非常广泛的一个软件。它最大的亮点在于让用户可以即时编码，即时测试，即时调整，而且支持超过40种编程语言，详情可参考<a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="noopener">jupyter-kernels-list</a>。</p>
<h2 id="设置多编程语言支持">设置多编程语言支持</h2>
<h3 id="octave支持">octave支持</h3>
<ol>
<li>首先本地要安装octave, mac用户可以直接通过如下命令安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install octave</span><br></pre></td></tr></table></figure>
<p>其他系统可以自行参考<a href="https://www.gnu.org/software/octave/download" target="_blank" rel="noopener">octave安装教程</a><br>
2. 安装jupyter和octave进行交互的octave_kernel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install octave_kernel</span><br></pre></td></tr></table></figure>
<p>更多细节可以参考<a href="https://github.com/Calysto/octave_kernel/blob/master/README.rst" target="_blank" rel="noopener">octave_kernel-Github</a></p>
<h3 id="R语言支持">R语言支持</h3>
<ol>
<li>本地安装R语言环境</li>
</ol>
<p>下载连接 <a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/" target="_blank" rel="noopener">tsinghua-cran-download</a></p>
<p>R语言官网<a href="https://www.r-project.org/" target="_blank" rel="noopener">R-project</a></p>
<ol start="2">
<li>配置R语言kernel</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入R语言console</span><br><span class="line">R</span><br><span class="line"># 安装kernel</span><br><span class="line">install.packages(&apos;IRkernel&apos;)</span><br><span class="line">选择合适的源即可。</span><br><span class="line"># 为系统所有用户安装</span><br><span class="line">IRkernel::installspec(user = FALSE)</span><br></pre></td></tr></table></figure>
<h3 id="查看jupyter的内核支持">查看jupyter的内核支持</h3>
<ol>
<li>通过命令行查看</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter kernelspec list</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016145435.png" alt=""></p>
<p>2.通过打开notebook新建文件来查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016145812.png" alt=""></p>
<h2 id="bug记录">bug记录</h2>
<ol>
<li>configurations are cuurently only defined for the following language:</li>
</ol>
<p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016114704.png" alt=""></p>
<ul>
<li>问题描述</li>
</ul>
<p>这个问题出现在我为本地jupyter新添加了R语言和octave语言的kernel.但是当我新建一个对应的文件的时候，就报错上面的错误。</p>
<ul>
<li>解决措施</li>
</ul>
<p>问题出现在autopep8插件上，这个插件仅仅支持python，所以在使用其他语言的时候就会报错，所以当我们在编写其他语言相关的文件时候，我们将这个插件关掉即可。</p>
<p><img src="https://cdn.kingwen.cn/qiniu_kwimg20201016113535.png" alt=""></p>
]]></content>
      <categories>
        <category>工具推荐</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
        <tag>octave</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛云+PicGo制作博客图床</title>
    <url>/2020/09/11/%E4%B8%83%E7%89%9B%E4%BA%91-PicGo%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p>用七牛云和PicGo给博客的图片安了一个家，七牛云真香！</p>
<a id="more"></a>
<p>对于所有写博客的同学来说，图床是一个必须要考虑的事情，最好图床可以稳定、便宜还要好用。</p>
<p>我从写博客以来，用过微博的图床(后来外链关闭了)，用过github搭建过图床（访问速度堪忧），用过简书做图床(平台现在越做越差)，后来就直接用有道云笔记了（但是只能自己看），一路走来，充满坎坷。</p>
<p>最近刚好有点时间，我就把自己的域名和服务器重新认证了一下，准备以后好好做点东西，所以图床的事情也必须要搞一下，于是本篇文章应运而生！</p>
<h2 id="前期准备">前期准备</h2>
<ol>
<li><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGO</a>：到releases下载最新版本的符合自己电脑的安装包，下载即可。注意下载的是稳定版本还是试用版本，带有beta的都是试用版本。<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911200650.png" alt=""></li>
<li><a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a>对象存储：在七牛云新建存储空间，用来保存图片即可。<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911201552.png" alt=""></li>
<li>实名认证后的域名。可以通过腾讯云或者阿里云进行域名购买，然后记得要到工信部认证。否则是不能对外提供服务的。</li>
</ol>
<h2 id="具体步骤">具体步骤</h2>
<h3 id="1-设置七牛云存储">1.设置七牛云存储</h3>
<ol>
<li>对象存储-&gt;空间管理-&gt;新建空间<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911201447.png" alt=""></li>
</ol>
<ul>
<li>存储空间名称：名称自定义即可。要注意长度</li>
<li>存储区域：自己选一个离自己比较近的区域即可。</li>
<li>访问控制：要设置为公开</li>
</ul>
<ol start="2">
<li>设置自己的存储空间<br>
刷新列表就可以看到自己刚刚新建的存储空间。<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911201842.png" alt=""><br>
这里其实最需要干的是要绑定自己的域名，七牛云仅仅提供了一个测试域名，只能有一个月的使用时间，之后便不能访问了。所以需要干的是选择设置，绑定自己的域名。<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911202412.png" alt=""><br>
具体绑定域名方法七牛云有详细的说明文档，以及https和cdn的绑定，按照说明指导就行。</li>
</ol>
<h3 id="2-设置PicGo">2. 设置PicGo</h3>
<ol>
<li>右键图标查看详情打开picGO设置面板，左侧图床设置选择七牛图床<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203034.png" alt=""></li>
</ol>
<ul>
<li>AccessKey和SecretKey：七牛云页面右上角个人中心的密钥管理里面可以设置<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203301.png" alt=""></li>
<li>存储空间名称：就是我们前面的存储空间的名称。注意我这里用的是我实际图床使用的名字kwimg，但是我前面演示的是dh-img，那个仅仅是演示。大家在设置的时候此处要和前面创建的保持一致。</li>
<li>设定访问网址：<br>
如果是没有实际绑定自己的域名的话，可以在空间概览中查看。<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203700.png" alt=""><br>
如果是自己已经绑定好域名的话，是下面这个样子的。<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911203838.png" alt=""><br>
还有需要注意的一点是需要自己在网址的前面加上(<strong>http:// 或者 https://</strong>)。</li>
<li>确认存储区域<br>
这里和我们之前申请存储空间的时候选择的区域是相关的。<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911204251.png" alt=""></li>
<li>设定网址后缀： 这个暂时不用设置</li>
<li>制定存储区域： 自己随便设置，仅仅是图片的url路径多点东西而已不重要。</li>
</ul>
<ol start="2">
<li>设置快捷键<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911204718.png" alt=""></li>
<li>设置开机自启<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911204812.png" alt=""></li>
<li>接下来就可以非常开心的将图片提交到七牛云存储啦。</li>
</ol>
<ul>
<li>当我们截图之后直接通过快捷键上传图片，图片上传成功之后对应的markdown地址会在本地的粘贴板。直接在对应的markdown文件中ctrl+v就行啦。</li>
<li>如果想看之前提交过图片，可以左键点击图标查看；也可以右键查看详情，然后查看对应的相册，点击图片下面的三个按钮最左面一个就可以复制本张图片的markdown地址；中间一个可以修改url地址；最右面一个可以将本张图片在相册中删掉，但是七牛云存储中依然存在。<br>
<img src="https://cdn.kingwen.cn/qiniu_kwimg20200911205205.png" alt=""></li>
</ul>
<h2 id="关于价格">关于价格</h2>
<p><img src="https://cdn.kingwen.cn/qiniu_kwimg20200911205849.png" alt=""><br>
如果仅仅是个人博客，而且访问量没有那么大的话，基本上就是免费的，七牛云真棒！！</p>
<p>ok,剩下的就是安心写博客啦,gogogo!</p>
<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://picgo.github.io/PicGo-Doc/zh/guide/" target="_blank" rel="noopener">PicGo-Guide文档</a></li>
</ol>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>PicGo</tag>
        <tag>七牛云</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫项目阶段性总结</title>
    <url>/2020/07/18/data-scientist-grow-up/</url>
    <content><![CDATA[<p>我对于爬虫项目的阶段性总结。<br>
包含做项目时的流程、每个流程相关技术概述以及自己的学习经验。<br>
方便自己后期查阅，也希望能给别人一点点指引。</p>
<a id="more"></a>
<h2 id="【前言】">【前言】</h2>
<ol>
<li>本学习计划仅作为参考，具体学习路线根据自己的实际情况酌情调整。</li>
<li>本学习路线图侧重数据工程师或者数据科学家路线，包括数据爬虫，清洗，存储，分析，展示等一系列流程。</li>
<li>本文档主要是给大黄写的，大黄写代码要加油啊！</li>
</ol>
<h2 id="完整的项目流程">完整的项目流程</h2>
<ol>
<li>确定项目内容：可以选择自己感兴趣的内容或者根据工作任务确定。</li>
<li>确定项目最终效果：根据目标效果反推出需要的数据。</li>
<li>确定数据源：根据想要的数据确定一个或者多个数据源</li>
<li>确定技术方案：分析数据源，确定需要的技术方案以及技术可行性。</li>
<li>开始动手！按照技术方案将数据进行采集，并最终实现预期的项目效果。</li>
</ol>
<h2 id="项目详细技术">项目详细技术</h2>
<h3 id="网页数据获取">网页数据获取</h3>
<p>本部分工作主要是用爬虫程序模拟浏览器访问对应的网站来获取网页html数据。</p>
<ol>
<li>发送请求获取网页数据。以python为例，可以通过类似于<a href="https://requests.readthedocs.io/en/master/" target="_blank" rel="noopener">requests</a>、urllib等package发送请求。</li>
<li>在正式编写代码前，要首先通过F12开发者选项（chrome浏览器）分析请求内容。或者直接通过网站页面右键-&gt;检查-&gt;network面板进行查看。</li>
</ol>
<ul>
<li>分析请求的url，查看是否存在跳转，是否需要登陆，如果需要登陆则考虑模拟登陆或者保存cookie或者使用cookie池。</li>
<li>查看能否直接请求对应的api获取目标数据,如果不能,再考虑请求网页原始数据再将目标数据解析出来。</li>
<li>对于模拟登陆，可以通过输入一个错误的用户名和密码来获得真正的url请求情况，否则可能因为成功跳转而看不到相关内容；</li>
</ul>
<ol start="3">
<li>注意各种反爬虫措施的处理，包括伪造请求头、设置请求间隔时间、设置ip代理,携带cookie信息等等</li>
</ol>
<h3 id="网页解析">网页解析</h3>
<p>本部分工作是将网页对应的html页面内容进行解析。重点是灵活使用各种解析库，将想要的数据提取出来。<br>
其中解析库主要包括<a href="https://www.runoob.com/xpath/xpath-syntax.html" target="_blank" rel="noopener">xpath</a>,<a href="https://www.crummy.com/software/BeautifulSoup/doc" target="_blank" rel="noopener">bs4</a>，<a href="https://pythonhosted.org/pyquery/" target="_blank" rel="noopener">pyquery</a>等，还可以结合正则表达式、字符串操作等多种方式对网页内容进行解析。</p>
<h3 id="数据处理">数据处理</h3>
<p>网页解析出来的内容数据可能存在数据缺失、数据格式不一致等问题。所以需要进行数据处理操作。</p>
<ul>
<li>数据缺失问题：删除整条数据、填充特殊值、填充中位数、填充众数、数据拟合等</li>
<li>数据格式不一致问题：确定数据统一格式，包括单位、格式等</li>
</ul>
<h3 id="数据存储">数据存储</h3>
<p>将处理好的数据进行数据存储，方便后期使用。</p>
<ul>
<li>关系型数据库：mysql、oracle等</li>
<li>文档型数据库：mongodb</li>
<li>图数据库：neo4j</li>
<li>内存数据库： redis<br>
个人比较倾向于爬虫处理后的结果暂时放到mongdb中，原因就是方便读写。等数据处理结束之后可以根据数据类型以及对外服务的类型决定放到图数据库或者关系型数据库。</li>
</ul>
<h3 id="数据分析">数据分析</h3>
<p>根据预期的项目效果对已经爬取的数据进行数据分析。</p>
<ul>
<li>按照不同类别进行划分，比如不同的地域，不同季节，不同人群等。</li>
<li>按照时间线进行分析，比如平均身高，平均薪酬等。</li>
<li>按照其他统计学的知识对数据进行处理并分析。</li>
</ul>
<h3 id="数据展示">数据展示</h3>
<p>数据分析的结果要通过合适的方式进行展示。</p>
<ul>
<li>ppt、word等办公软件。考虑内嵌图表或者截图插入</li>
<li>个人网站、个人博客等。考虑使用<a href="https://echarts.apache.org/examples/zh/index.html" target="_blank" rel="noopener">echarts.js</a>或者<a href="https://observablehq.com/@d3/gallery" target="_blank" rel="noopener">d3.js</a>等图表库，效果非常好。</li>
</ul>
<h3 id="结论">结论</h3>
<p>我们研究或者调研的内容告诉我们什么内容，说明了什么道理，给我们什么启示，这个也应该作为我们整个项目的一部分进行说明。</p>
<h2 id="技术进一步提升">技术进一步提升</h2>
<p>上面介绍的技术仅仅适应于数据量较小的常规数据采集路线。下面说一下其中可以进行扩展和提升的部分。</p>
<h3 id="爬虫框架的使用">爬虫框架的使用</h3>
<p>数据采集是一个比较常见的需求，所以程序员们开发出了很多方便扩展的爬虫框架，比如<a href="https://docs.scrapy.org/en/latest/intro/tutorial.html" target="_blank" rel="noopener">scrapy</a>、<a href="http://docs.pyspider.org/en/latest/" target="_blank" rel="noopener">pyspider</a>、<a href="https://scrapy-redis.readthedocs.io/en/stable/" target="_blank" rel="noopener">scrapy-redis</a>、<a href="https://scrapy-cluster.readthedocs.io/en/latest/topics/introduction/overview.html" target="_blank" rel="noopener">scrapy-cluster</a>等，可以让我们将重点放在处理核心业务上。</p>
<h3 id="docker的使用">docker的使用</h3>
<p>docker可以认为是一个轻量的虚拟机，通过镜像来创建实例，每个实例彼此隔离彼此独立，从而可以让程序员摆脱编程开发测试部署环境不一致的问题，同时方便进行横向扩展。在我们项目构造出对应的镜像之后，便会由镜像在手，天下我有的豪气。<br>
在使用新的组件之前，可以先去<a href="https://hub.docker.com/" target="_blank" rel="noopener">dockerhub</a>看看，之后尽量所有的项目要通过docker进行部署，用dockerfile来进行定义。让项目组件化，这样就可以解耦合，从而方便扩展和升级。</p>
<p>爬虫过程的每一个步骤都可以单独拿出来交给对应的docker镜像来处理。看自己最后的需求进行不同粒度的分解。</p>
<h3 id="大数据组件">大数据组件</h3>
<p>在数据清洗、数据分析的时候如果数据量太大，可以和大数据平台进行对接，包括hadoop、mapreduce等，然后将对应的结果保存起来供进一步使用。</p>
<p>大数据平台的东西由很多，而且环境部署比较麻烦，所以本部分强烈建议使用docker进行部署，然后在部署的时候要注意不同实例之间的通信。</p>
<h3 id="分布式爬虫部署">分布式爬虫部署</h3>
<p>当数据量太大，单机爬虫的速率就远远不能满足我们的需求，这个时候就可以考虑使用分布式爬虫，将很多台主机一起来爬取想要的数据，上面说的爬虫框架sacrpy就是单机版本的，scrapy-redis就是在scrapy的基础上添加redis用来做爬取队列，可以作为分布式爬虫使用，scrapy-cluster是在scrapy-redis的基础上添加大数据组件kafka从而与大数据平台对接，也属于分布式爬虫。scrapyd可以用来方便的部署分布式爬虫程序。<a href="https://docs.gerapy.com/en/latest/" target="_blank" rel="noopener">Gerapy</a>也值得关注。</p>
<h3 id="APP内容的爬取">APP内容的爬取</h3>
<p>本部分我没有做过，但是我知道有很多库，包括Charles、mitmproxy、Appium等，可以对手机app进行抓包，从而采集到想要的数据。</p>
<h2 id="学习经验">学习经验</h2>
<ol>
<li>要以项目为主导，no bb，show your code！！</li>
<li>善于使用搜索引擎google、bing</li>
<li>学会使用<a href="https://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a>查找bug</li>
<li>尽量通过官方文档学习新的技术</li>
<li>合理使用github这个宝库</li>
<li>找一本好的参考资料比如<a href="https://item.jd.com/12333540.html" target="_blank" rel="noopener">Python 3网络爬虫开发实战</a>以及网站<a href="https://cuiqingcai.com/" target="_blank" rel="noopener">静觅-崔庆才</a></li>
</ol>
<p>最后，开始动手吧！！！！</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>spider</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-容器内安装vim编辑器</title>
    <url>/2020/06/15/docker-4-install-vim-in-container/</url>
    <content><![CDATA[<p>本篇文章将会介绍在container中安装vim编辑器。<br>
需要注意在正式开发时要通过dockerfile来进行所有环境的设置。</p>
<a id="more"></a>
<p>在有些容器中使用vim命令的时候，会提示如下错误。</p>
<blockquote>
<p>vim: command not found</p>
</blockquote>
<p>说明容器中没有安装vim.<br>
我们可以通过如下命令进行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>
<p>如果安装的时候报错，报错信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package vim</span><br></pre></td></tr></table></figure>
<p>可以通过如下命令来解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker提升-实现原理</title>
    <url>/2020/06/15/docker-3-principle/</url>
    <content><![CDATA[<p>docker镜像是一个特殊的文件系统。<br>
本篇文章将介绍如何docker镜像的层级结构，同时学习如何查看中间层镜像。</p>
<a id="more"></a>
<h2 id="docker的原理">docker的原理</h2>
<p>Docker 的镜像就是它的文件系统，一个镜像可以放在另外一个镜像的上层，那么位于下层的就是它的父镜像。所以，Docker 会存在很多镜像层，每个镜像层都是只读的，并且不会改变。当我们创建一个新的容器时，Docker 会构建出一个镜像栈，并在栈的最顶层添加一个读写层，如图所示。<br>
<img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdbf9e98a71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<p>其中中间的这些镜像层就是intermediate image，是不能被删除的。</p>
<h2 id="如何查看中间层镜像">如何查看中间层镜像</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//查看镜像</span><br><span class="line">docker image ls</span><br><span class="line">//查看所有镜像（包含中间层镜像）</span><br><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure>
<p>带参数a选项的命令输出的结果中含有none:none标签的镜像都是intermediate image(中间层镜像)，这些镜像会被其他镜像所使用，是不能被随意删除的。</p>
<h2 id="none-none-标签镜像">none:none 标签镜像</h2>
<p>具有none:none 标签的景象都是intermediate image吗？ 其实不是，还有一类镜像是dangling image（悬虚镜像），通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<p>命令展示出来的镜像也会包含none:none标签的镜像，这就是dangling image.</p>
<p>那么dangling image是如何产生的呢？<br>
比如我们最开始通过如下命令构造一个名称为test:v1的镜像，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t test:v1 .</span><br></pre></td></tr></table></figure>
<p>然后我们后期对代码进行了修改，所以我们会重新构造一个镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t test:v1 .</span><br></pre></td></tr></table></figure>
<p>我们没有为它分配新的名字，新构造的镜像还是叫做test:v1。这个时候原来的test:v1就会成为dangling image，根本没用，而且会占用存储空间。</p>
<p>可以通过如下命令将所有的玄虚镜像删掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>
<h2 id="写在最后">写在最后</h2>
<p>记得多关注一下docker的help文档,以查看镜像命令为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  log docker image ls --help</span><br><span class="line"></span><br><span class="line">Usage:  docker image ls [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">List images</span><br><span class="line"></span><br><span class="line">Aliases:</span><br><span class="line">  ls, images, list</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">      --digests         Show digests</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print images using a Go template</span><br><span class="line">      --no-trunc        Don&apos;t truncate output</span><br><span class="line">  -q, --quiet           Only show numeric IDs</span><br></pre></td></tr></table></figure>
<p>可以看到-a选项后面说，默认是隐藏intermediate images的。所以我们就可以了解到存在intermediate images 而且还可以通过在原命令的后面加参数a来查看中间层镜像。</p>
<p>更细节的原理可以查看这篇文章<a href="https://www.projectatomic.io/blog/2015/07/what-are-docker-none-none-images/" target="_blank" rel="noopener">What are Docker <none>:<none> images?</a>。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>principle</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker进阶-Dockerfile的编写和使用</title>
    <url>/2020/06/15/docker-2-dockerfile/</url>
    <content><![CDATA[<p>在实际开发中完全使用他人构造好的镜像是不现实的。<br>
所以本篇文章我们将会学习Dockerfile的知识，从而学习如何构造符合项目要求的镜像。</p>
<a id="more"></a>
<h2 id="Dockerfile文档展示">Dockerfile文档展示</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">RUN apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y python3-pip python3-dev</span><br><span class="line"></span><br><span class="line"># We copy just the requirements.txt first to leverage Docker cache</span><br><span class="line">COPY ./requirements.txt /app/requirements.txt</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">RUN python3 -m pip install --upgrade pip</span><br><span class="line">RUN pip3 install -r requirements.txt</span><br><span class="line"></span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"># ENTRYPOINT [ &quot;python3&quot; ]</span><br><span class="line"></span><br><span class="line">CMD [ &quot;python3&quot;, &quot;main.py&quot; ]</span><br></pre></td></tr></table></figure>
<h2 id="逐行命令解释">逐行命令解释</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">FROM 关键字会初始化一个image构造，并为后续的所有操作设置基础镜像，，上面的例子表示，该image是以ubuntu:16.04为基础构建的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. RUN apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y python3-pip python3-dev</span><br><span class="line"></span><br><span class="line">RUN 会在上一层的基础上添加新的layer,并将结果提交给下一层。RUN命令有两种形式。一种是shell格式，格式如下</span><br><span class="line">RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)</span><br><span class="line"></span><br><span class="line">另一种是exec格式，格式如下</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)</span><br><span class="line"></span><br><span class="line">&amp;&amp; \ 并不是Docker独有的，只是告诉linux这两条命令要一起执行，而不是执行两次，这样就只会产生一层layer,如果有两个RUN，那么就会产生两个中间层。 </span><br><span class="line"></span><br><span class="line">3. COPY ./requirements.txt /app/requirements.txt</span><br><span class="line">COPY 命令同样有两种形式，可以实现将源文件复制到目标位置，支持正则表达式。</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br><span class="line"></span><br><span class="line">4. WORKDIR /app</span><br><span class="line">- WORKDIR 会设置当前的工作目录，在本条指令之后的RUN, CMD, ENTRYPOINT, COPY 和 ADD目录都是在当前目录下执行的。</span><br><span class="line">- WORKDIR 可以出现多次，从而更换shell的执行路径</span><br><span class="line"></span><br><span class="line">5. RUN python3 -m pip install --upgrade pip</span><br><span class="line">6. RUN pip3 install -r requirements.txt</span><br><span class="line">RUN命令的shell形式，更新pip同时安装依赖。</span><br><span class="line"></span><br><span class="line">7. COPY . /app</span><br><span class="line">复制命令 将当前目录的所有文件复制到/app目录下</span><br><span class="line"></span><br><span class="line">8.CMD [ &quot;python3&quot;, &quot;main.py&quot; ]</span><br><span class="line">CMD的作用是提供容器的默认指令，也就是我们docker run 的最后一个参数。CMD有三种形式，在一个Dockerfile中，如果有多个CMD指令，那么只有最后一个CMD命令会起作用。</span><br><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)</span><br><span class="line">CMD command param1 param2 (shell form)</span><br><span class="line"></span><br><span class="line">如果CMD命令后只有参数，没有可执行的命令，那么它肯定是配合ENTRYPOINT使用的。同时要注意，如果是配合ENTRYPOINT的时候，CMD和ENTRYPOINT都要使用使用 JSON array 格式。如果用ENTRYPOINT进行改写，则如下所示。</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ &quot;python&quot; ]</span><br><span class="line">CMD [ &quot;main.py&quot; ]</span><br></pre></td></tr></table></figure>
<h2 id="打包镜像">打包镜像</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t kuakua:latest .</span><br><span class="line"> -t 设置镜像名称和标签，如果标签没有设定，默认是latest</span><br><span class="line"> .  在当前目录寻找Dockerfile进行镜像打包。</span><br></pre></td></tr></table></figure>
<h2 id="运行容器">运行容器</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> docker run -d -p 5001:5000 --name kuakua -v /Users/liqingwen/workplace/temp/kuakua/log:/log kuakua:latest</span><br><span class="line"></span><br><span class="line">// 详细解释</span><br><span class="line">-d  表示以守护进程的形式进行执行，后台运行</span><br><span class="line">-p 5001:5000 将容器的5000端口映射到宿主机的5001端口</span><br><span class="line">--name kuakua 将当前容器命名为kuakua</span><br><span class="line">-v bind mount a volumn 将容器的log目录和本地的/Users/liqingwen/workplace/temp/kuakua/log做一个映射。如果容器端log目录下有内容更新，则本地的log目录也会同步更新。</span><br><span class="line">kuakua:latest 镜像名称</span><br></pre></td></tr></table></figure>
<h2 id="项目地址">项目地址</h2>
<p>本项目完整代码已经在github开源，项目地址<a href="https://github.com/aweng126/TestProject/tree/master/kuakua" target="_blank" rel="noopener">夸夸机器人</a>,欢迎大家去尝试一下。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">dockerfile 官方参考文档</a></li>
<li><a href="https://runnable.com/docker/python/dockerize-your-flask-application" target="_blank" rel="noopener">Dockerize your Flask Application</a></li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker初探-认识并使用docker</title>
    <url>/2020/06/15/docker-fundamentals/</url>
    <content><![CDATA[<p>docker是目前最流行的虚拟化技术。<br>
本篇文章主要介绍docker的基本概念以及初步尝试使用docker技术。</p>
<a id="more"></a>
<h2 id="docker是什么">docker是什么</h2>
<p>Docker 属于 Linux容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker将应用程序与该程序的依赖，打包在一个文件里面。只要运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。</p>
<h2 id="docker好在哪">docker好在哪</h2>
<ol>
<li>更高效的利用系统资源</li>
<li>更快速的启动时间</li>
<li>一致的运行环境</li>
<li>持续交付和部署</li>
<li>容易迁移、维护和扩展</li>
</ol>
<h2 id="docker专有名词">docker专有名词</h2>
<ol>
<li>镜像，image, 包括各种环境的定义和说明。</li>
<li>容器，container, 是一个镜像的运行实体，不同容器之间是相互隔离的。</li>
<li>仓库，镜像的仓库，用于用户发布自己的镜像或者查找自己需要的镜像，目前最大的公开仓库为<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker hub</a>,一个项目star越多，说明项目越好越稳定。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdab4a554d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h2 id="常用命令">常用命令</h2>
<h3 id="启动docker">启动docker</h3>
<p>如果是mac或者windows用户，可以直接使用Docker Desktop来可视化处理<br>
如果是linux用户，需要通过命令行来启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service docker start/stop/restart</span><br></pre></td></tr></table></figure>
<h3 id="使用docker">使用docker</h3>
<ol>
<li>help帮助命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image --help</span><br></pre></td></tr></table></figure>
<p>通过这条命令可以查看与docker的镜像相关的命令<br>
将image替换为container，则可以查看到关于container的相关帮助。<br>
同时，可以进一步查看相关命令的细节，比如下面的命令就可以查看image下prune命令的细节。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image prune --help</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>搜索并拉取镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 搜索与ubuntu相关的image</span><br><span class="line">docker search ubuntu</span><br><span class="line"></span><br><span class="line">// 拉取镜像到本地</span><br><span class="line">docker pull ubuntu</span><br><span class="line"></span><br><span class="line">// 如果没有特别声明tag,会默认使用latest标签。</span><br><span class="line">// 当然可以去docker hub去查找image并查看更加细节的东西，比如版本信息，然后在拉取的时候可以指定版本。</span><br><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>列出当前本地的所有镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">或者</span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<p>如果想同时查看中间层镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images -a</span><br><span class="line">或者</span><br><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>删除本地镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 删除固定的某个镜像</span><br><span class="line">docker rmi imageid</span><br><span class="line">docker image rm imageid</span><br><span class="line"></span><br><span class="line">//删除所有玄虚镜像</span><br><span class="line">docker image prune</span><br><span class="line"></span><br><span class="line">// 删除所有玄虚镜像和未使用的景象</span><br><span class="line">docker image prune -a</span><br><span class="line"></span><br><span class="line">// 删除所有仓库名为redis的镜像</span><br><span class="line">docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>启动一个容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 从image启动一个容器</span><br><span class="line">docker run -it --name ubuntu  ubuntu:18.04  /bin/bash</span><br><span class="line"> -i : Keep STDIN open even if not attached 即使没有连接，也要保持标准输入保持打开状态</span><br><span class="line"> -t : Allocate a pseudo-TTY  分配一个伪tty</span><br><span class="line"> -name ubuntu : 为当前容器分配名字为ubuntu</span><br><span class="line"> ubuntu:18.04 ：要运行的镜像</span><br><span class="line"> /bin/bash ：要执行的命令。</span><br><span class="line"></span><br><span class="line">还有一个参数非常常见 </span><br><span class="line"> -d : Run container in background and print container ID 在后台运行容器，且打印容器id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 把之前停止的容器重新启动</span><br><span class="line">docker start containerid</span><br><span class="line">docker attach containerid</span><br></pre></td></tr></table></figure>
<p>使用docker run命令来启动容器，docker在后台运行的标准操作包括</p>
<pre><code>1. 检查本地是否存在指定的镜像，不存在则从公有仓库下载
2. 使用镜像创建并启动容器
3.分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层
4.从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中去
5.从地址池分配一个ip地址给容器
6.执行用户指定的应用程序
7.执行完毕之后容器被终止
</code></pre>
<p>需要注意的是，对于容器要执行的命令而言，如果执行结束，那么容器就会关闭。</p>
<ol start="6">
<li>查看当前正在运行的容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>如果还想查看已经退出的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>连接一个执行之中的容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container exec -it containerid</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>退出正在运行的容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl + D</span><br><span class="line">或者</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>查看镜像所占空间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>删除某些名称中含有dingms的container</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container rm $(docker ps -a |grep dingms | awk &apos;&#123;print $1&#125;&apos;)</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>守护态进程<br>
很多时候，需要让docker在后台运行而不是直接把结果输出到当前宿主下面，这个时候可以用守护态运行。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 没有使用守护态，始终在本地终端输出</span><br><span class="line">docker run  ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line"></span><br><span class="line">//使用守护态,不在本地终端输出，但是在最后结果输出</span><br><span class="line">docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">// 查看当前contain</span><br><span class="line">docker container ls</span><br><span class="line">docker container logs containerid</span><br></pre></td></tr></table></figure>
<ol start="12">
<li>终止某个容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container stop containerid</span><br></pre></td></tr></table></figure>
<p>对于正在运行中的容器，重新启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container restart containerid</span><br></pre></td></tr></table></figure>
<ol start="13">
<li>进入容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker attach containerid</span><br><span class="line"></span><br><span class="line">docker exec -it containerid bash</span><br><span class="line"></span><br><span class="line">用attach进入终端之后，如果exit会直接让容器终止。</span><br><span class="line">但是exec通过exit退出之后，容器不会终止。</span><br></pre></td></tr></table></figure>
<ol start="14">
<li>镜像打包和加载</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 打包镜像</span><br><span class="line">docker save -o ~/Desktop/kuakua.tar kuakua:latest</span><br><span class="line">// 加载tar包到对应的镜像</span><br><span class="line">docker load -i ~/Desktop/kuakua.tar</span><br></pre></td></tr></table></figure>
<ol start="15">
<li>导出和导入容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 导出容器快照文件到本地文件</span><br><span class="line">docker export containerid &gt; name.tar</span><br><span class="line">// 从容器快照文件再导入为镜像</span><br><span class="line">cat name.tar | docker import - test/name:v1.0</span><br><span class="line">// 查看所属镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>从网上找到一个非常棒的图<br>
<img src="https://user-gold-cdn.xitu.io/2019/4/9/16a02cdbf14142a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<h2 id="参考文章">参考文章</h2>
<ol>
<li><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">Docker 从入门到实践</a></li>
<li><a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="noopener">Docker-cli官方文档</a></li>
<li><a href="https://juejin.im/post/5cacbfd7e51d456e8833390c#heading-0" target="_blank" rel="noopener">30 分钟快速入门 Docker 教程</a></li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>go-get碰到timeout怎么办</title>
    <url>/2020/04/23/go-micro-bug-io-timeout/</url>
    <content><![CDATA[<p>go get 下载资源的时候下载缓慢甚至遇到timeout,可以通过设置代理的方式来解决。</p>
<a id="more"></a>
<p>通过如下命令可以查看go对应的各类变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure>
<p>我们重点要看.GO111MODULE这两个选项。</p>
<ol>
<li>GOPROXY: 代表是使用代理。</li>
<li>GO111MODULE: 表示是否使用module.在Go1.11版本之后就非常推荐使用go module 来管理依赖了。所以非常推荐使用。</li>
</ol>
<h2 id="Linux-或者-Mac环境下">Linux 或者 Mac环境下</h2>
<p>直接修改环境变量就可以啦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line">export GO111MODULE=on</span><br><span class="line">export GOPROXY=https://goproxy.io </span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>通过go env再查看一下，上面的路径是否生效。若已经生效，则重新 go get 下载资源即可。</p>
<h2 id="GO-Land-开发">GO Land 开发</h2>
<p>GO111MODULE=ON还是要通过上面的方式进行设定。</p>
<p>如果是使用goland,还可以依次的点击如下选项设置proxy。<br>
GOLAND-&gt;Preferences-&gt;Go-&gt;Go modules(vgo)-&gt;选中Enable Go module integration.<br>
同时设置proxy的值为 <a href="https://goproxy.io" target="_blank" rel="noopener">https://goproxy.io</a> 或者 <a href="https://goproxy.cn" target="_blank" rel="noopener">https://goproxy.cn</a>,direct<br>
点击apply就行。</p>
<p>通过go env再查看一下，上面的路径是否生效。若已经生效，则重新 go get 下载资源即可。</p>
]]></content>
      <categories>
        <category>Bugs</category>
      </categories>
      <tags>
        <tag>go-micro</tag>
        <tag>timout</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>【微服务Go-micro第三篇】相关概念解释</title>
    <url>/2020/04/23/go-micro-3-concept-interpretation/</url>
    <content><![CDATA[<p>在搭建环境的时候其实我就有很多疑问了，怎么有这么多概念？<br>
微服务、RPC, gRPC, protoc等等，它们都是啥？本篇文章来进行比较详细的解释。</p>
<a id="more"></a>
<h2 id="微服务">微服务</h2>
<p>使用一套小服务来开发单个应用的方式，每个服务运行在独立的进程里，一般采用轻量级的通讯机制互联，并且它们可以通过自动化的方式部署。</p>
<h2 id="RPC">RPC</h2>
<ol>
<li>远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议</li>
<li>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li>
<li>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用</li>
</ol>
<h2 id="gRPC">gRPC</h2>
<ol>
<li>gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统</li>
<li>gRPC客户端和服务端可以在多种环境中运行和交互，例如用java写一个服务端，可以用go语言写客户端调用</li>
</ol>
<h2 id="protobuff">protobuff</h2>
<ol>
<li>gRPC可以实现微服务，将大的项目拆分为多个小且独立的业务模块，也就是服务，各服务间使用高效的protobuf协议进行RPC调用，gRPC默认使用protocol  buffer，这是google开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如JSON）</li>
<li>可以用proto files创建gRPC服务，用message类型来定义方法参数和返回类型</li>
</ol>
<h2 id="个人理解">个人理解</h2>
<p>结合这里和我们上一篇的文章，我们可以得到以下结论</p>
<ol>
<li>我们是使用了proto file(user.proto)来定义对应的方法和返回类型，其中message结构来定义接收参数和返回参数的名称以及类型。 service结构来定义对应的远程调用的方法和接受的对应的参数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service user&#123;</span><br><span class="line">        rpc RegisterUser(RegisterUserReq) returns (RegisterUserRsp)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserReq&#123;</span><br><span class="line">        string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserRsp&#123;</span><br><span class="line">        string status = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>protoc命令会按照proto文件中声明的message的格式构造传输对象。gRPC的服务器端和客户端都遵守protocal buffer协议，在客户端会序列化请求对象，在服务端反序列化请求对象，服务器端处理完成之后，序列化响应对象，客户端再反序列化响应对象。所以共同遵守protocal buff 协议让客户端和服务器端可以方便地进行通信，即使最后客户端和服务器端是用不同的语言来实现的也没有关系。</li>
</ol>
<h2 id="protobuf语法">protobuf语法</h2>
<h3 id="简单介绍">简单介绍</h3>
<ol>
<li>以.proto结尾</li>
<li>Message命名采用驼峰命名方式，字段命名采用小写字母加下划线分隔方式</li>
<li>结构定义可以包含：message、service、enum</li>
<li>可以通过required表示这个参数是必须的，optional表示这个参数是可选的。通过default表示这个参数的默认值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; // </span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;</span><br><span class="line">  optional int32 page_number = 2;</span><br><span class="line">  optional int32 result_per_page = 3 [default = 10];</span><br><span class="line">  enum Corpus &#123;</span><br><span class="line">    UNIVERSAL = 0;</span><br><span class="line">    WEB = 1;</span><br><span class="line">    IMAGES = 2;</span><br><span class="line">    LOCAL = 3;</span><br><span class="line">    NEWS = 4;</span><br><span class="line">    PRODUCTS = 5;</span><br><span class="line">    VIDEO = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  optional Corpus corpus = 4 [default = UNIVERSAL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service SearchService &#123;</span><br><span class="line">        rpc Search (SearchRequest) returns (SearchResponse) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>更多使用方式可以参见下面的两个链接。</p>
<h3 id="参考链接">参考链接</h3>
<ol>
<li><a href="https://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="noopener">[译]Protobuf 语法指南</a></li>
<li><a href="http://www.topgoer.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Protobuf%E8%AF%AD%E6%B3%95.html" target="_blank" rel="noopener">1. Protobuf语法</a></li>
</ol>
<h2 id="Go-micro">Go-micro</h2>
<h3 id="什么是go-micro">什么是go-micro</h3>
<p>go-micro是一个框架，提供了分布式开发所需要的核心需求，包括RPC和基于事件驱动的通信。设计理念是可插拔。</p>
<h3 id="Go-micro特点">Go-micro特点</h3>
<ol>
<li>服务发现：自动服务注册和命名解析。服务发现是微服务开发中的核心，当服务A要与服务B协作时，它得知道服务B在哪里。目前默认的服务发现机制是组播multicast DNS (mdns，组播)，是一种零配置网络。</li>
<li>负载均衡：在服务发现的基础上构建客户端的负载均衡。当我们查找一个服务发现它有多个节点时，我们需要一种机制来决定最终路由到哪一个节点。默认使用random hashed load balancing来提供服务的负载均衡。如果出现问题，那么go-micro会尝试使用其他节点。</li>
<li>消息编码：基于内容类型动态编码消息，客户端和服务器端将会使用基于内容类型的编解码器来对Go语言的类型进行无缝隙的编解码。客户端可以编码并发送各种类型额消息，客户端和服务器端默认能够处理这些消息，默认包含 protobuf and json。</li>
<li>请求/相应：RPC通信是基于双向信息流的请求和相应。go-micro提供一种同步的抽象。一个发送给服务的请求会被自动的解析、负载均衡、拨号、转成字节流。默认传输是通过gRPC。</li>
<li>异步信息：发布订阅机制在异步通信和事件驱动架构中非常重要，事件通知在微服务开发中占有重要地位。默认的消息传递系统是http事件消息代理。</li>
<li>可插拔： Go Micro为每个分布式系统抽象出接口。因此，Go Micro的接口都是可插拔的，允许其在运行时不可知的情况下仍可支持。所以只要实现接口，可以在内部使用任何的技术。更多插件请参考：<a href="http://github.com/micro/go-plugins" target="_blank" rel="noopener">github.com/micro/go-plugins</a></li>
</ol>
<h3 id="go-micro通信流程">go-micro通信流程</h3>
<ol>
<li>Server监听客户端的调用，对Brocker推送过来的信息进行处理。并且Server端需要向Register注册自己的存在或消亡，这样Client才能知道自己的状态</li>
<li>Register服务的注册的发现，Client端从Register中得到Server的信息，然后每次调用都根据算法选择一个的Server进行通信，当然通信是要经过编码/解码，选择传输协议等一系列过程的</li>
<li>如果有需要通知所有的Server端可以使用Brocker进行信息的推送，Brocker 信息队列进行信息的接收和发布</li>
</ol>
<h3 id="go-micro接口">go-micro接口</h3>
<p>go-micro之所以可以高度订制和他的框架结构是分不开的，go-micro由8个关键的interface组成，每一个interface都可以根据自己的需求重新实现，这8个主要的inteface也构成了go-micro的框架结构<br>
<img src="http://www.topgoer.com/static/wei/6/1.png" alt=""></p>
<h3 id="go-micro-接口详解">go-micro 接口详解</h3>
<h4 id="Transort通信接口">Transort通信接口</h4>
<p>通信相关接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Socket interface &#123;</span><br><span class="line">   Recv(*Message) error</span><br><span class="line">   Send(*Message) error</span><br><span class="line">   Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Client interface &#123;</span><br><span class="line">   Socket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Listener interface &#123;</span><br><span class="line">   Addr() string</span><br><span class="line">   Close() error</span><br><span class="line">   Accept(func(Socket)) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Transport interface &#123;</span><br><span class="line">   Dial(addr string, opts ...DialOption) (Client, error)</span><br><span class="line">   Listen(addr string, opts ...ListenOption) (Listener, error)</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Codec编码接口">Codec编码接口</h4>
<p>编解码，底层也是protobuf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Codec interface &#123;</span><br><span class="line">   ReadHeader(*Message, MessageType) error</span><br><span class="line">   ReadBody(interface&#123;&#125;) error</span><br><span class="line">   Write(*Message, interface&#123;&#125;) error</span><br><span class="line">   Close() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.1.3. Registry注册接口<br>
服务注册发现的实现：etcd、consul、mdns、kube-DNS、zk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Registry interface &#123;</span><br><span class="line">   Register(*Service, ...RegisterOption) error</span><br><span class="line">   Deregister(*Service) error</span><br><span class="line">   GetService(string) ([]*Service, error)</span><br><span class="line">   ListServices() ([]*Service, error)</span><br><span class="line">   Watch(...WatchOption) (Watcher, error)</span><br><span class="line">   String() string</span><br><span class="line">   Options() Options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Selector负载均衡">Selector负载均衡</h4>
<p>根据不同算法请求主机列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Selector interface &#123;</span><br><span class="line">   Init(opts ...Option) error</span><br><span class="line">   Options() Options</span><br><span class="line">   // Select returns a function which should return the next node</span><br><span class="line">   Select(service string, opts ...SelectOption) (Next, error)</span><br><span class="line">   // Mark sets the success/error against a node</span><br><span class="line">   Mark(service string, node *registry.Node, err error)</span><br><span class="line">   // Reset returns state back to zero for a service</span><br><span class="line">   Reset(service string)</span><br><span class="line">   // Close renders the selector unusable</span><br><span class="line">   Close() error</span><br><span class="line">   // Name of the selector</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Broker发布订阅接口">Broker发布订阅接口</h4>
<p>pull push watch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Broker interface &#123;</span><br><span class="line">   Options() Options</span><br><span class="line">   Address() string</span><br><span class="line">   Connect() error</span><br><span class="line">   Disconnect() error</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Publish(string, *Message, ...PublishOption) error</span><br><span class="line">   Subscribe(string, Handler, ...SubscribeOption) (Subscriber, error)</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Client客户端接口">Client客户端接口</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Client interface &#123;</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Options() Options</span><br><span class="line">   NewMessage(topic string, msg interface&#123;&#125;, opts ...MessageOption) Message</span><br><span class="line">   NewRequest(service, method string, req interface&#123;&#125;, reqOpts ...RequestOption) Request</span><br><span class="line">   Call(ctx context.Context, req Request, rsp interface&#123;&#125;, opts ...CallOption) error</span><br><span class="line">   Stream(ctx context.Context, req Request, opts ...CallOption) (Stream, error)</span><br><span class="line">   Publish(ctx context.Context, msg Message, opts ...PublishOption) error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Server服务端接口">Server服务端接口</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Server interface &#123;</span><br><span class="line">   Options() Options</span><br><span class="line">   Init(...Option) error</span><br><span class="line">   Handle(Handler) error</span><br><span class="line">   NewHandler(interface&#123;&#125;, ...HandlerOption) Handler</span><br><span class="line">   NewSubscriber(string, interface&#123;&#125;, ...SubscriberOption) Subscriber</span><br><span class="line">   Subscribe(Subscriber) error</span><br><span class="line">   Register() error</span><br><span class="line">   Deregister() error</span><br><span class="line">   Start() error</span><br><span class="line">   Stop() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Serveice接口">Serveice接口</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Service interface &#123;</span><br><span class="line">   Init(...Option)</span><br><span class="line">   Options() Options</span><br><span class="line">   Client() client.Client</span><br><span class="line">   Server() server.Server</span><br><span class="line">   Run() error</span><br><span class="line">   String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.topgoer.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1/GoMicro%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">Go Micro接口详解</a></p>
<h2 id="总结">总结</h2>
<p>看了上面那么多概念，我们可以稍微做一下梳理和总结。</p>
<ol>
<li>我们对业务需求进行梳理划分，分解一个一个的单一职责的任务，我们分别通过一个<strong>微服务</strong>来实现对应的任务。</li>
<li><strong>go-micro</strong>是一个可以用来实现微服务的框架，设计理念是可插拔，什么意思呢，就是组件可以随时替换，有多种实现方式。go-micro的整理设计逻辑如下图所示。<br>
<img src="http://www.topgoer.com/static/wei/6/1.png" alt=""></li>
<li>微服务在实现过程中是有一定的技术要求的。</li>
</ol>
<ul>
<li>服务注册与发现：用户想调用一个服务，必须首先找到这个服务，所以对于一个服务而言，就必须在开启时要进行注册，go-micro让Registry来负责这个任务，而Registry有多种实现方式，可以参见下表，而我们搭建环境的时候就用的<strong>etcd</strong>。</li>
<li>要进行负载均衡。用户在找同一个服务的时候可能会有多个节点实现这个服务，所以需要根据相应的<a href="https://blog.csdn.net/lihao21/article/details/54695471" target="_blank" rel="noopener">负载均衡机制</a>进行节点选择。这部分就由Selector来负责。</li>
<li>要进行消息编解码，不同的service在调用的时候是需要传递数据的，数据在编码和解码上要有统一的规则，从而进行序列化和反序列化。编解码支持json和<strong>protobuff</strong>。这部分的编解码工作由Codec来负责。我们在用go-micro编写微服务时，我们会按照protobuf的语法来编写<strong>proto file</strong>，然后通过protoc,protoc-gen-go,protoc-gen-mico来生成对应的消息对象以及相应服务的API.</li>
<li>要进行通信：这部分由transort来负责。</li>
<li>Broker主要对异步信息进行处理</li>
</ul>
<p>4.这几部分具体有哪些实现呢？可以看<a href="https://github.com/micro/go-plugins" target="_blank" rel="noopener">go-plugins</a>这个库中的插件的集合。</p>
<table>
<thead>
<tr>
<th>Directory</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Broker</td>
<td>PubSub messaging; NATS, NSQ, RabbitMQ, Kafka</td>
</tr>
<tr>
<td>Client</td>
<td>RPC Clients; gRPC, HTTP</td>
</tr>
<tr>
<td>Codec</td>
<td>Message Encoding; BSON, Mercury</td>
</tr>
<tr>
<td>Micro</td>
<td>Micro Toolkit Plugins</td>
</tr>
<tr>
<td>Registry</td>
<td>Service Discovery; Etcd, Gossip, NATS</td>
</tr>
<tr>
<td>Selector</td>
<td>Load balancing; Label, Cache, Static</td>
</tr>
<tr>
<td>Server</td>
<td>RPC Servers; gRPC, HTTP</td>
</tr>
<tr>
<td>Transport</td>
<td>Bidirectional Streaming; NATS, RabbitMQ</td>
</tr>
<tr>
<td>Wrapper</td>
<td>Middleware; Circuit Breakers, Rate Limiting, Tracing, Monitoring</td>
</tr>
</tbody>
</table>
<ol start="5">
<li>对我们而言如何使用go-micro呢？</li>
</ol>
<ul>
<li>根据服务需求来写好proto file</li>
<li>根据proto file 生成对应的传输对象以及服务端和客户端的api</li>
<li>编写服务器端和客户端代码</li>
<li>执行服务器端和客户端代码</li>
</ul>
<p>注意：在执行的时候可以指定最下面一层的各个组件，具体指定方式可以通过命令行指定或者设置环境变量或者直接在文件中写死等方式，更加详细的内容可以查看<a href="https://github.com/micro/go-plugins/blob/master/README.md" target="_blank" rel="noopener">Go-Plugins-README</a></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>go-micro</tag>
      </tags>
  </entry>
  <entry>
    <title>【微服务Go-micro第二篇】protoc到底干了啥</title>
    <url>/2020/04/22/go-micro-2-protoc-task/</url>
    <content><![CDATA[<p>本篇文章主要介绍上一篇文章中利用protoc命令生成proto文件对应的另外两个文件的过程，<br>
并简单介绍在实际业务中如何使用这两个文件。</p>
<a id="more"></a>
<h1>先说结论</h1>
<p>上一节我们通过下面的命令使得 user.proto</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protoc --proto_path=. --micro_out=. --go_out=. proto/greeter.proto</span><br></pre></td></tr></table></figure>
<p>生成了如下两个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user.pb.go  user.pb.micro.go</span><br></pre></td></tr></table></figure>
<p>我们现在可以解释为什么会出现这种情况啦。</p>
<ol>
<li><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">protoc</a>是一个代码生成的工具，它其实可以生成多种语言对应的文件,包括但是不限于c++,java,js,python,c#,当然也包括Go。</li>
<li>可以根据命令的参数格式发现–go_out实际上就是将生成的go语言的文件放到当前目录。然后–micro_out就是将生成的微服务的文件放到当前目录，所以就生成了上面的两个文件。</li>
<li>具体是怎么生成的呢？先说生成的go文件，这个文件我看了一下其实主要就是对于proto文件中的message进行编写。因为这个message将会是之后服务器和客户端进行通信的对象结构，所以有一些通用的方法，比如结构体定义，string方法等，在后面微服务的时候可以调用它。再说生成的micro文件，这个文件会针对于service中rpc的定义进行展开。会提供客户端和服务器端对应的api。</li>
<li>先说服务器端api的调用和对应api的使用。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type UserHandler interface &#123;</span><br><span class="line">        RegisterUser(context.Context, *RegisterUserReq, *RegisterUserRsp) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RegisterUserHandler(s server.Server, hdlr UserHandler, opts ...server.HandlerOption) error &#123;</span><br><span class="line">        type user interface &#123;</span><br><span class="line">                RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error</span><br><span class="line">        &#125;</span><br><span class="line">        type User struct &#123;</span><br><span class="line">                user</span><br><span class="line">        &#125;</span><br><span class="line">        h := &amp;userHandler&#123;hdlr&#125;</span><br><span class="line">        return s.Handle(s.NewHandler(&amp;User&#123;h&#125;, opts...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userHandler struct &#123;</span><br><span class="line">        UserHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *userHandler) RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error &#123;</span><br><span class="line">        return h.UserHandler.RegisterUser(ctx, in, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server端api主要要创建一个服务，然后针对于这个服务提供handler方法，对应的handler要实现接口RegisterUser中的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type User struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func(user *User)  RegisterUser(ctx context.Context, req  *proto.RegisterUserReq,  rsp *proto.RegisterUserRsp) (error)&#123;</span><br><span class="line">        rsp.Status =&quot;ok&quot;+req.Name</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建服务</span><br><span class="line">service := micro.NewService(</span><br><span class="line">                micro.Name(&quot;user&quot;),</span><br><span class="line">        )</span><br><span class="line">proto.RegisterUserHandler(service.Server(), new(User))</span><br></pre></td></tr></table></figure>
<p>更详细的代码可以查看后面的main.go<br>
5. 再说客户端的api和对应api的使用<br>
生成的客户端的api如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type UserService interface &#123;</span><br><span class="line">        RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userService struct &#123;</span><br><span class="line">        c    client.Client</span><br><span class="line">        name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewUserService(name string, c client.Client) UserService&#123;```&#125;</span><br><span class="line"></span><br><span class="line">func (c *userService) RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error) &#123;···&#125;</span><br></pre></td></tr></table></figure>
<p>所以在我们使用的时候，要首先通过NewUserService得到对应的service,然后调用RegisterUser方法来得到请求结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">userService := proto.NewUserService(&quot;user&quot;, service.Client())</span><br><span class="line"></span><br><span class="line">// Call the userregister</span><br><span class="line">rsp, err := userService.RegisterUser(context.TODO(), &amp;proto.RegisterUserReq&#123;Name: &quot;John&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>更加详细的代码可以参见后面client.go中的代码。</p>
<h1>具体代码</h1>
<h2 id="1-user-proto">1.  user.proto</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service user&#123;</span><br><span class="line">        rpc RegisterUser(RegisterUserReq) returns (RegisterUserRsp)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserReq&#123;</span><br><span class="line">        string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterUserRsp&#123;</span><br><span class="line">        string status = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-user-pb-go">2. user.pb.go</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Code generated by protoc-gen-go. DO NOT EDIT.</span><br><span class="line">// versions:</span><br><span class="line">//      protoc-gen-go v1.21.0</span><br><span class="line">//      protoc        v3.11.4</span><br><span class="line">// source: proto/user.proto</span><br><span class="line"></span><br><span class="line">package user</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        proto &quot;github.com/golang/protobuf/proto&quot;</span><br><span class="line">        protoreflect &quot;google.golang.org/protobuf/reflect/protoreflect&quot;</span><br><span class="line">        protoimpl &quot;google.golang.org/protobuf/runtime/protoimpl&quot;</span><br><span class="line">        reflect &quot;reflect&quot;</span><br><span class="line">        sync &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">        // Verify that this generated code is sufficiently up-to-date.</span><br><span class="line">        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)</span><br><span class="line">        // Verify that runtime/protoimpl is sufficiently up-to-date.</span><br><span class="line">        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// This is a compile-time assertion that a sufficiently up-to-date version</span><br><span class="line">// of the legacy proto package is being used.</span><br><span class="line">const _ = proto.ProtoPackageIsVersion4</span><br><span class="line"></span><br><span class="line">type RegisterUserReq struct &#123;</span><br><span class="line">        state         protoimpl.MessageState</span><br><span class="line">        sizeCache     protoimpl.SizeCache</span><br><span class="line">        unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">        Name string `protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) Reset() &#123;</span><br><span class="line">        *x = RegisterUserReq&#123;&#125;</span><br><span class="line">        if protoimpl.UnsafeEnabled &#123;</span><br><span class="line">                mi := &amp;file_proto_user_proto_msgTypes[0]</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                ms.StoreMessageInfo(mi)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) String() string &#123;</span><br><span class="line">        return protoimpl.X.MessageStringOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*RegisterUserReq) ProtoMessage() &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) ProtoReflect() protoreflect.Message &#123;</span><br><span class="line">        mi := &amp;file_proto_user_proto_msgTypes[0]</span><br><span class="line">        if protoimpl.UnsafeEnabled &amp;&amp; x != nil &#123;</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                if ms.LoadMessageInfo() == nil &#123;</span><br><span class="line">                        ms.StoreMessageInfo(mi)</span><br><span class="line">                &#125;</span><br><span class="line">                return ms</span><br><span class="line">        &#125;</span><br><span class="line">        return mi.MessageOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Deprecated: Use RegisterUserReq.ProtoReflect.Descriptor instead.</span><br><span class="line">func (*RegisterUserReq) Descriptor() ([]byte, []int) &#123;</span><br><span class="line">        return file_proto_user_proto_rawDescGZIP(), []int&#123;0&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserReq) GetName() string &#123;</span><br><span class="line">        if x != nil &#123;</span><br><span class="line">                return x.Name</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RegisterUserRsp struct &#123;</span><br><span class="line">        state         protoimpl.MessageState</span><br><span class="line">        sizeCache     protoimpl.SizeCache</span><br><span class="line">        unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">        Status string `protobuf:&quot;bytes,1,opt,name=status,proto3&quot; json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) Reset() &#123;</span><br><span class="line">        *x = RegisterUserRsp&#123;&#125;</span><br><span class="line">        if protoimpl.UnsafeEnabled &#123;</span><br><span class="line">                mi := &amp;file_proto_user_proto_msgTypes[1]</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                ms.StoreMessageInfo(mi)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) String() string &#123;</span><br><span class="line">        return protoimpl.X.MessageStringOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*RegisterUserRsp) ProtoMessage() &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) ProtoReflect() protoreflect.Message &#123;</span><br><span class="line">        mi := &amp;file_proto_user_proto_msgTypes[1]</span><br><span class="line">        if protoimpl.UnsafeEnabled &amp;&amp; x != nil &#123;</span><br><span class="line">                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))</span><br><span class="line">                if ms.LoadMessageInfo() == nil &#123;</span><br><span class="line">                        ms.StoreMessageInfo(mi)</span><br><span class="line">                &#125;</span><br><span class="line">                return ms</span><br><span class="line">        &#125;</span><br><span class="line">        return mi.MessageOf(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Deprecated: Use RegisterUserRsp.ProtoReflect.Descriptor instead.</span><br><span class="line">func (*RegisterUserRsp) Descriptor() ([]byte, []int) &#123;</span><br><span class="line">        return file_proto_user_proto_rawDescGZIP(), []int&#123;1&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *RegisterUserRsp) GetStatus() string &#123;</span><br><span class="line">        if x != nil &#123;</span><br><span class="line">                return x.Status</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var File_proto_user_proto protoreflect.FileDescriptor</span><br><span class="line"></span><br><span class="line">var file_proto_user_proto_rawDesc = []byte&#123;</span><br><span class="line">        0x0a, 0x10, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f,</span><br><span class="line">        0x74, 0x6f, 0x22, 0x25, 0x0a, 0x0f, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73,</span><br><span class="line">        0x65, 0x72, 0x52, 0x65, 0x71, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,</span><br><span class="line">        0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x29, 0x0a, 0x0f, 0x52, 0x65, 0x67,</span><br><span class="line">        0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x73, 0x70, 0x12, 0x16, 0x0a, 0x06,</span><br><span class="line">        0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74,</span><br><span class="line">         0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x73, 0x70, 0x12, 0x16, 0x0a, 0x06,</span><br><span class="line">        0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74,</span><br><span class="line">        0x61, 0x74, 0x75, 0x73, 0x32, 0x3c, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x34, 0x0a, 0x0c,</span><br><span class="line">        0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x12, 0x10, 0x2e, 0x52,</span><br><span class="line">        0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x1a, 0x10,</span><br><span class="line">        0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x73, 0x70,</span><br><span class="line">        0x22, 0x00, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">        file_proto_user_proto_rawDescOnce sync.Once</span><br><span class="line">        file_proto_user_proto_rawDescData = file_proto_user_proto_rawDesc</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func file_proto_user_proto_rawDescGZIP() []byte &#123;</span><br><span class="line">        file_proto_user_proto_rawDescOnce.Do(func() &#123;</span><br><span class="line">                file_proto_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_user_proto_rawDescData)</span><br><span class="line">        &#125;)</span><br><span class="line">        return file_proto_user_proto_rawDescData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var file_proto_user_proto_msgTypes = make([]protoimpl.MessageInfo, 2)</span><br><span class="line">var file_proto_user_proto_goTypes = []interface&#123;&#125;&#123;</span><br><span class="line">        (*RegisterUserReq)(nil), // 0: RegisterUserReq</span><br><span class="line">        (*RegisterUserRsp)(nil), // 1: RegisterUserRsp</span><br><span class="line">&#125;</span><br><span class="line">var file_proto_user_proto_depIdxs = []int32&#123;</span><br><span class="line">        0, // 0: user.RegisterUser:input_type -&gt; RegisterUserReq</span><br><span class="line">        1, // 1: user.RegisterUser:output_type -&gt; RegisterUserRsp</span><br><span class="line">        1, // [1:2] is the sub-list for method output_type</span><br><span class="line">        0, // [0:1] is the sub-list for method input_type</span><br><span class="line">        0, // [0:0] is the sub-list for extension type_name</span><br><span class="line">        0, // [0:0] is the sub-list for extension extendee</span><br><span class="line">        0, // [0:0] is the sub-list for field type_name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123; file_proto_user_proto_init() &#125;</span><br><span class="line">func file_proto_user_proto_init() &#123;</span><br><span class="line">        if File_proto_user_proto != nil &#123;</span><br><span class="line">                return</span><br><span class="line">        &#125;</span><br><span class="line">        if !protoimpl.UnsafeEnabled &#123;</span><br><span class="line">                file_proto_user_proto_msgTypes[0].Exporter = func(v interface&#123;&#125;, i int) interface&#123;&#125; &#123;</span><br><span class="line">                        switch v := v.(*RegisterUserReq); i &#123;</span><br><span class="line">                        case 0:</span><br><span class="line">                                return &amp;v.state</span><br><span class="line">                        case 1:</span><br><span class="line">                                return &amp;v.sizeCache</span><br><span class="line">                        case 2:</span><br><span class="line">                                return &amp;v.unknownFields</span><br><span class="line">                        default:</span><br><span class="line">                                return nil</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                file_proto_user_proto_msgTypes[1].Exporter = func(v interface&#123;&#125;, i int) interface&#123;&#125; &#123;</span><br><span class="line">                        switch v := v.(*RegisterUserRsp); i &#123;</span><br><span class="line">                        case 0:</span><br><span class="line">                                return &amp;v.state</span><br><span class="line">                        case 1:</span><br><span class="line">                                return &amp;v.sizeCache</span><br><span class="line">                        case 2:</span><br><span class="line">                                return &amp;v.unknownFields</span><br><span class="line">                        default:</span><br><span class="line">                                return nil</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        type x struct&#123;&#125;</span><br><span class="line">        out := protoimpl.TypeBuilder&#123;</span><br><span class="line">                File: protoimpl.DescBuilder&#123;</span><br><span class="line">                        GoPackagePath: reflect.TypeOf(x&#123;&#125;).PkgPath(),</span><br><span class="line">                        RawDescriptor: file_proto_user_proto_rawDesc,</span><br><span class="line">                        NumEnums:      0,</span><br><span class="line">                        NumMessages:   2,</span><br><span class="line">                        NumExtensions: 0,</span><br><span class="line">                        NumServices:   1,</span><br><span class="line">                &#125;,</span><br><span class="line">                GoTypes:           file_proto_user_proto_goTypes,</span><br><span class="line">                DependencyIndexes: file_proto_user_proto_depIdxs,</span><br><span class="line">                MessageInfos:      file_proto_user_proto_msgTypes,</span><br><span class="line">        &#125;.Build()</span><br><span class="line">        File_proto_user_proto = out.File</span><br><span class="line">        file_proto_user_proto_rawDesc = nil</span><br><span class="line">        file_proto_user_proto_goTypes = nil</span><br><span class="line">        file_proto_user_proto_depIdxs = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-user-pb-micro-go">3. user.pb.micro.go</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Code generated by protoc-gen-micro. DO NOT EDIT.</span><br><span class="line">// source: proto/user.proto</span><br><span class="line"></span><br><span class="line">package user</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        fmt &quot;fmt&quot;</span><br><span class="line">        proto &quot;github.com/golang/protobuf/proto&quot;</span><br><span class="line">        math &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        context &quot;context&quot;</span><br><span class="line">        api &quot;github.com/micro/go-micro/v2/api&quot;</span><br><span class="line">        client &quot;github.com/micro/go-micro/v2/client&quot;</span><br><span class="line">        server &quot;github.com/micro/go-micro/v2/server&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Reference imports to suppress errors if they are not otherwise used.</span><br><span class="line">var _ = proto.Marshal</span><br><span class="line">var _ = fmt.Errorf</span><br><span class="line">var _ = math.Inf</span><br><span class="line"></span><br><span class="line">// This is a compile-time assertion to ensure that this generated file</span><br><span class="line">// is compatible with the proto package it is being compiled against.</span><br><span class="line">// A compilation error at this line likely means your copy of the</span><br><span class="line">// proto package needs to be updated.</span><br><span class="line">const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package</span><br><span class="line"></span><br><span class="line">// Reference imports to suppress errors if they are not otherwise used.</span><br><span class="line">var _ api.Endpoint</span><br><span class="line">var _ context.Context</span><br><span class="line">var _ client.Option</span><br><span class="line">var _ server.Option</span><br><span class="line"></span><br><span class="line">// Api Endpoints for User service</span><br><span class="line"></span><br><span class="line">func NewUserEndpoints() []*api.Endpoint &#123;</span><br><span class="line">        return []*api.Endpoint&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Client API for User service</span><br><span class="line"></span><br><span class="line">type UserService interface &#123;</span><br><span class="line">        RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userService struct &#123;</span><br><span class="line">        c    client.Client</span><br><span class="line">        name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewUserService(name string, c client.Client) UserService &#123;</span><br><span class="line">        return &amp;userService&#123;</span><br><span class="line">                c:    c,</span><br><span class="line">                name: name,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *userService) RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...client.CallOption) (*RegisterUserRsp, error) &#123;</span><br><span class="line">        req := c.c.NewRequest(c.name, &quot;User.RegisterUser&quot;, in)</span><br><span class="line">        out := new(RegisterUserRsp)</span><br><span class="line">        err := c.c.Call(ctx, req, out, opts...)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">                        return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">        return out, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Server API for User service</span><br><span class="line"></span><br><span class="line">type UserHandler interface &#123;</span><br><span class="line">        RegisterUser(context.Context, *RegisterUserReq, *RegisterUserRsp) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func RegisterUserHandler(s server.Server, hdlr UserHandler, opts ...server.HandlerOption) error &#123;</span><br><span class="line">        type user interface &#123;</span><br><span class="line">                RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error</span><br><span class="line">        &#125;</span><br><span class="line">        type User struct &#123;</span><br><span class="line">                user</span><br><span class="line">        &#125;</span><br><span class="line">        h := &amp;userHandler&#123;hdlr&#125;</span><br><span class="line">        return s.Handle(s.NewHandler(&amp;User&#123;h&#125;, opts...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type userHandler struct &#123;</span><br><span class="line">        UserHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *userHandler) RegisterUser(ctx context.Context, in *RegisterUserReq, out *RegisterUserRsp) error &#123;</span><br><span class="line">        return h.UserHandler.RegisterUser(ctx, in, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-main-go">4. main.go</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;datatown/proto&quot;</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type User struct&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(user *User)  RegisterUser(ctx context.Context, req  *proto.RegisterUserReq,  rsp *proto.RegisterUserRsp) (error)&#123;</span><br><span class="line">        rsp.Status =&quot;ok&quot;+req.Name</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service. Optionally include some options here.</span><br><span class="line">        service := micro.NewService(</span><br><span class="line">                micro.Name(&quot;user&quot;),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // Init will parse the command line flags.</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Register handler</span><br><span class="line">        proto.RegisterUserHandler(service.Server(), new(User))</span><br><span class="line"></span><br><span class="line">        // Run the server</span><br><span class="line">        if err := service.Run(); err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-client-go">5. client.go</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;datatown/proto&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service</span><br><span class="line">        service := micro.NewService(micro.Name(&quot;user.client&quot;))</span><br><span class="line">        // Initialise the client and parse command line flags</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Create new user service  client</span><br><span class="line">        userService := proto.NewUserService(&quot;user&quot;, service.Client())</span><br><span class="line"></span><br><span class="line">        // Call the userregister</span><br><span class="line">        rsp, err := userService.RegisterUser(context.TODO(), &amp;proto.RegisterUserReq&#123;Name: &quot;John&quot;&#125;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Print response</span><br><span class="line">        fmt.Println(rsp.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>go-micro</tag>
        <tag>protoc</tag>
      </tags>
  </entry>
  <entry>
    <title>【微服务Go-micro第一篇】环境配置</title>
    <url>/2020/04/22/go-micro-1-build-environment/</url>
    <content><![CDATA[<p>go-micro 是一个基于Go语言的分布式框架，可以用来对外提供微服务。<br>
本篇文章介绍如何在linux系统下进行环境配置，并写好自己的第一个helloworld程序。</p>
<a id="more"></a>
<h2 id="一、依赖安装">一、依赖安装</h2>
<ol>
<li>依赖安装 protoc-gen-micro</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 依赖</span><br><span class="line">go get github.com/micro/micro/v2/cmd/protoc-gen-micro@master </span><br><span class="line"></span><br><span class="line">// 上述包依赖两个protoc 和protoc-gen-go </span><br><span class="line"></span><br><span class="line">// 第一个依赖安装</span><br><span class="line">//[protobuf下载](https://github.com/protocolbuffers/protobuf/releases)</span><br><span class="line">wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.4/protoc-3.11.4-linux-x86_64.zip</span><br><span class="line"></span><br><span class="line">unzip protoc-3.11.4-linux-x86_64.zip -d /root/go/gotool/</span><br><span class="line"></span><br><span class="line">// 路径修改</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line">PATH=/root/go/gotool/bin:$PATH</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line">// 检查是否安装成功，如果出现版本号，则说明安装成功。</span><br><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二个依赖protoc-gen-go的安装</span><br><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>依赖安装 etcd</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://github.com/etcd-io/etcd/releases/download/v3.4.7/etcd-v3.4.7-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzf etcd-v3.4.7-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">cp etcd* /usr/local/bin/</span><br><span class="line"></span><br><span class="line">// 通过如下命令来启动</span><br><span class="line">etcd</span><br></pre></td></tr></table></figure>
<p>要声明etcd来进行注册服务，在bash_profile中添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export MICRO_REGISTRY=etcd</span><br></pre></td></tr></table></figure>
<p>如果碰到用go get 命令报403错误可以使用代理来解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line">//添加如下内容</span><br><span class="line"></span><br><span class="line">export GOPROXY=https://goproxy.io // 设置代理</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>通过go-module来管理依赖<br>
在bash_profile中添加如下内容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GO111MODULE=on</span><br></pre></td></tr></table></figure>
<h2 id="二、helloworld程序">二、helloworld程序</h2>
<h3 id="2-1-官方实例的helloworld">2.1 官方实例的helloworld</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get github.com/micro/micro/v2 </span><br><span class="line"></span><br><span class="line">git clone https://github.com/micro/examples.git</span><br><span class="line">cd examples/service</span><br><span class="line">go run main.go</span><br><span class="line">go run main.go --run_client</span><br></pre></td></tr></table></figure>
<p>结果会出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello john</span><br></pre></td></tr></table></figure>
<p>说明实验成功。</p>
<h3 id="2-2-自己编写helloworld测试">2.2 自己编写helloworld测试</h3>
<ol>
<li>构造项目</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 建立项目</span><br><span class="line">mkdir hello &amp;&amp; cd  hello</span><br><span class="line"></span><br><span class="line">// 利用模块来管理相关的依赖。 </span><br><span class="line">go mod init hello</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编写服务原型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在hello目录下建立服务原型</span><br><span class="line">mkdir proto</span><br><span class="line">vim proto/greeter.proto</span><br></pre></td></tr></table></figure>
<p>greeter.proto 内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service Greeter &#123;</span><br><span class="line">    rpc Hello(Request) returns (Response) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">    string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    string greeting = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>根据服务原型生成对应的代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在hello目录下执行</span><br><span class="line"> protoc --proto_path=. --micro_out=. --go_out=. proto/greeter.proto</span><br></pre></td></tr></table></figure>
<p>此时在hello/proto目录下会有三个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">greeter.pb.go  </span><br><span class="line">greeter.pb.micro.go </span><br><span class="line">greeter.proto</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>编写main.go文件作为服务器代码。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim main.go</span><br><span class="line">// 内容如下</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;hello/proto&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Greeter struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (g *Greeter) Hello(ctx context.Context, req *proto.Request, rsp *proto.Response) error &#123;</span><br><span class="line">        rsp.Greeting = &quot;Hello &quot; + req.Name</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service. Optionally include some options here.</span><br><span class="line">        service := micro.NewService(</span><br><span class="line">                micro.Name(&quot;greeter&quot;),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // Init will parse the command line flags.</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Register handler</span><br><span class="line">        proto.RegisterGreeterHandler(service.Server(), new(Greeter))</span><br><span class="line"></span><br><span class="line">        // Run the server</span><br><span class="line">        if err := service.Run(); err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>编写client.go文件作为客户端代码。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim client.go</span><br><span class="line">// 内容如下</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;context&quot;</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">        micro &quot;github.com/micro/go-micro/v2&quot;</span><br><span class="line">        proto &quot;hello/proto&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // Create a new service</span><br><span class="line">        service := micro.NewService(micro.Name(&quot;greeter.client&quot;))</span><br><span class="line">        // Initialise the client and parse command line flags</span><br><span class="line">        service.Init()</span><br><span class="line"></span><br><span class="line">        // Create new greeter client</span><br><span class="line">        greeter := proto.NewGreeterService(&quot;greeter&quot;, service.Client())</span><br><span class="line"></span><br><span class="line">        // Call the greeter</span><br><span class="line">        rsp, err := greeter.Hello(context.TODO(), &amp;proto.Request&#123;Name: &quot;kingwen&quot;&#125;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Print response</span><br><span class="line">        fmt.Println(rsp.Greeting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>运行程序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">etcd </span><br><span class="line">go main.go</span><br><span class="line">go client.go</span><br></pre></td></tr></table></figure>
<p>结果出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello.kingwen。</span><br></pre></td></tr></table></figure>
<p>说明程序搭建成功。</p>
<p>最后看一下代码结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── client.go</span><br><span class="line">├── default.etcd</span><br><span class="line">│   └── member</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── proto</span><br><span class="line">    ├── greeter.pb.go</span><br><span class="line">    ├── greeter.pb.micro.go</span><br><span class="line">    └── greeter.proto</span><br></pre></td></tr></table></figure>
<h2 id="三、参考链接">三、参考链接</h2>
<ol>
<li><a href="https://xueyuanjun.com/post/21585" target="_blank" rel="noopener">基于 Go Module 管理依赖并将注册中心调整为 Etcd</a></li>
<li><a href="https://github.com/micro/go-micro" target="_blank" rel="noopener">go-micro-github地址</a></li>
<li><a href="https://micro.mu/docs/go-helloworld.html" target="_blank" rel="noopener">micro官方文档</a></li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Go-micro</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy-断点调试</title>
    <url>/2020/04/08/scrapy-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>因为平时我们在写代码的时候都会依靠于debug来进行调试，<br>
那么一般通过命令行启动的scrapy项目要如何进行dubug呢？</p>
<a id="more"></a>
<p>用pycharm来解决这个问题的方式也比较简单。</p>
<ol>
<li>正常加断点</li>
<li>要编写一个run.py文件来模拟命令行启动,文件和spiders目录同级，内容如下。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from scrapy import cmdline</span><br><span class="line"></span><br><span class="line">name = &apos;spidername&apos;</span><br><span class="line">cmd = &apos;scrapy crawl &#123;0&#125;&apos;.format(name)</span><br><span class="line">cmdline.execute(cmd.split())</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>点击右上角的debug来执行即可。</li>
</ol>
<p>再说一下debug的三个选项</p>
<ol>
<li>step into : 单步执行，遇到子函数就进入子函数。</li>
<li>step over: 单步执行，遇到子函数不进入，而是完成子函数之后返回到当前位置，等同于处理一条命令。</li>
<li>step out: 单步执行，但是已经进入到子函数了，下面的部分不再单步执行而是返回到调用子函数的位置。</li>
</ol>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Bug-scrapy-数据错位</title>
    <url>/2020/04/08/Bug-scrapy-%E6%95%B0%E6%8D%AE%E9%94%99%E4%BD%8D/</url>
    <content><![CDATA[<p>在用scrapy进行数据爬取的时候，发现通过meta传递的数据不匹配，最后发现是深拷贝和浅拷贝的问题。</p>
<a id="more"></a>
<h2 id="Bug详情">Bug详情</h2>
<p>yield Request中传递的meta是浅拷贝，所以当我们有多条请求等待处理的时候，前面请求传递的meta会被后面请求传递的meta修改（他们指向同一个对象），所以就会造成前后不匹配。<br>
解决方式就是将其浅拷贝变成深拷贝。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line">···</span><br><span class="line">def parse(self, response):</span><br><span class="line">     yield Request(url=new_url, meta=&#123;&apos;item&apos;: copy.deepcopy(item)&#125;, callback=self.another_parse)</span><br></pre></td></tr></table></figure>
<p>同理，如果下载的时候下载item的时候也报错的话，也要记得将item的传递变成深拷贝即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 原来是yield item ,变成如下的样子即可。</span><br><span class="line">yield copy.deepcopy(item)</span><br></pre></td></tr></table></figure>
<h2 id="参考链接">参考链接</h2>
<p>1.<a href="https://www.jianshu.com/p/42f22085f4c5" target="_blank" rel="noopener">scrapy里面item传递数据后数据不正确的问题</a></p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>python-域名抽取</title>
    <url>/2020/04/04/python-%E5%9F%9F%E5%90%8D%E6%8A%BD%E5%8F%96/</url>
    <content><![CDATA[<p>在看scrapy-cluster源码的时候发现了一个非常实用的包-tldextract，<br>
可以非常方便的抽取出一个url的域名作为redis的key的一部分，感觉很神奇。所以记录一下。</p>
<a id="more"></a>
<p>对于一个网址而言，比如 <a href="http://www.kingwen.cn" target="_blank" rel="noopener">www.kingwen.cn</a>，可以分为三部分。www, kingwen, cn。分别称为二级域名，域名，后缀。tldextract(top-level domain)这个包就可以帮我们非常快的解决这个问题。</p>
<h2 id="安装tldextract包">安装tldextract包</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install tldextract</span><br></pre></td></tr></table></figure>
<h2 id="使用tldextract包">使用tldextract包</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tldextract</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    url = &apos;www.kingwen.cn&apos;</span><br><span class="line">    res = tldextract.extract(url)</span><br><span class="line">    print(res.subdomain, res.domain, res.suffix) # www kingwen cn</span><br><span class="line">    print(res.registered_domain) # kingwen.cn</span><br><span class="line">    url1 = &apos;localhost:8080/hello&apos;</span><br><span class="line">    res = tldextract.extract(url1)</span><br><span class="line">    print(res.subdomain, res.domain, res.suffix) # &apos;&apos;  localhost  &apos;&apos;</span><br></pre></td></tr></table></figure>
<h2 id="源码实现">源码实现</h2>
<p>主要分为三部分。</p>
<ul>
<li>首先是进行切割，将输入的url进行划分，利用# ？ @  : 等特殊符号进行不断的划分，最后将主体的域名部分提取出来。</li>
<li>其次将前一部分的主体域名通过’.'进行划分，形成对应的list。然后按照从位置i匹配到末尾元素的原则找到符合suffix字典（预先定义好的7336条）的第一个位置i.然后返回i。</li>
<li>最后 list[i:]就是suffix. list[:i-1]就是subdomain. list[i]就是domain.从而问题得到解决。</li>
</ul>
<p>尽管比较简单，但是比较实用，所以就记录一下。<br>
在以后用到的时候可以省去很多烦恼。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>domain</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Bug-Scrapy-Filtered_offsite_request</title>
    <url>/2020/03/31/bug-Filtered-offsite-request-Scrapy/</url>
    <content><![CDATA[<p>在写爬虫的时候遇见了一个bug,报错信息为 Filtered offsite request domain[‘mydomain’],<br>
从网上找到了答案并成功解决了问题，特别记录一下。</p>
<a id="more"></a>
<h2 id="检查allowed-domains">检查allowed_domains</h2>
<p>要去查看自己爬取的url是否符合我们的domain。如果我们要爬取的网站的网址为 <a href="https://www.example.com/1.html%EF%BC%8C" target="_blank" rel="noopener">https://www.example.com/1.html，</a> 那么我们就需要添加example.com到我们写好的爬虫中的allow_domains的list列表中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allowed_domains = [&apos;example.com&apos;]</span><br></pre></td></tr></table></figure>
<p>看一下<a href="https://docs.scrapy.org/en/latest/topics/spiders.html" target="_blank" rel="noopener">Scrapy官方文档</a>的解释。</p>
<blockquote>
<p><strong>allowed_domains</strong><br>
An optional list of strings containing domains that this spider is allowed to crawl. Requests for URLs not belonging to the domain names specified in this list (or their subdomains) won’t be followed if OffsiteMiddleware is enabled.</p>
</blockquote>
<p>如果设置进行url过滤,那么对于要新添加到爬取队列中的所有的url中必须包含allow_domains中的一个域名才可以，否则这个url就会被舍弃。</p>
<h2 id="设置-dont-filte-True">设置 dont_filte=True</h2>
<p>可以直接停止scrapy对于url的过滤。也就是在新生成的Request中添加 dont_filte=True，比如下面这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line"> yield Request(url=&apos;https://example.com&apos;, dont_filter=True, callback=self.parse2)</span><br><span class="line">def parse2(self, response):</span><br><span class="line"> pass</span><br></pre></td></tr></table></figure>
<p>看一下<a href="https://docs.scrapy.org/en/latest/topics/request-response.html" target="_blank" rel="noopener">Scrapy官方文档</a>的解释：</p>
<blockquote>
<p>dont_filter (boolean) – indicates that this request should not be filtered by the scheduler. This is used when you want to perform an identical request multiple times, to ignore the duplicates filter. Use it with care, or you will get into crawling loops. Default to False.</p>
</blockquote>
<p>这个方法就比较粗暴，就直接不对url进行过滤。那么也就是说对于所有的爬取到的url都会进行重新爬取，但是如果一旦有url是重复的，可能就会陷入循环。所以尽量不要采用这么暴力的方式。这也是scrapy默认将其设置为False的一个原因。</p>
<p>PS:一定要细心，我个人出现的问题是我想当然的设置了域名，然后真实网站的域名和我设置的域名差一个字母，所以最后就报错了。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>priority_queue的简单使用</title>
    <url>/2020/02/08/priority-queue%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文为c++容器系列第十篇.<br>
主要测试了priority_queue相关的方法，主要作为代码备份方便之后遗忘时查询。</p>
<a id="more"></a>
<p>优先队列，也是对容器的一个封装，形成的adapter,默认每次最先获得所有值中的最大值。<br>
每次插入一个新元素或者pop出一个元素之后，剩下的元素都会重新排一次序。<br>
可以改变compare函数使其变成最小堆，从而每次可以获得最小值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // 声明</span><br><span class="line">    priority_queue&lt;int&gt; pq; // 默认是最大堆，可以通过下面的方式声明为最大堆。</span><br><span class="line">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq1;</span><br><span class="line">    </span><br><span class="line">    // 也可以通过如下方式直接将一个容器内的所有元素装进priority_queue中。</span><br><span class="line">    vector&lt;int&gt; a = &#123;1,4,2,3&#125;;</span><br><span class="line">    priority_queue&lt;int&gt; pq2(less&lt;int&gt;(),a); // 最大堆</span><br><span class="line">    cout&lt;&lt;&quot;qp2.top():&quot;&lt;&lt;pq2.top()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">//    下面这种方式为什么不行？？此处存疑。</span><br><span class="line">//    priority_queue&lt;int&gt; pq3(greater&lt;int&gt;(),a); //最小堆</span><br><span class="line">//    cout&lt;&lt;pq3.top()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //下面针对pq进行操作演示</span><br><span class="line">    pq.push(2);</span><br><span class="line">    pq.push(1);</span><br><span class="line">    pq.emplace(3);</span><br><span class="line">    pq.emplace(4);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;pq.size()&quot;&lt;&lt;pq.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;pq.empty()&quot;&lt;&lt;pq.empty()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    pq.pop();</span><br><span class="line">    cout&lt;&lt;&quot;after pop,pq.size()&quot;&lt;&lt;pq.size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // 遍历: priority_queue默认是最大堆，每次的通过top()获得的元素就是最大值。</span><br><span class="line">    cout&lt;&lt;&quot;pq = &quot;;</span><br><span class="line">    while(!pq.empty())&#123;</span><br><span class="line">        cout&lt;&lt;pq.top()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果。</span><br><span class="line"> qp2.top():4</span><br><span class="line"> pq.size()4</span><br><span class="line"> pq.empty()0</span><br><span class="line"> after pop,pq.size()3</span><br><span class="line"> pq = 3    2    1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>Priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title>stack的简单使用</title>
    <url>/2020/02/08/stack%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文为c++容器系列第九篇.<br>
主要测试了stack相关的方法，主要作为代码备份方便之后遗忘时查询。</p>
<a id="more"></a>
<p>严格来讲，stack其实也不算是容器，它是在容器的基础上进行疯转从而具备后进先出(LIFO)特性的adapter。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    // 声明</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line">    stack&lt;int&gt; s1(&#123;1,2,3&#125;);</span><br><span class="line">    stack&lt;int&gt; s2(s1);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;s2= &quot;;</span><br><span class="line">     while(!s2.empty())&#123;</span><br><span class="line">         cout&lt;&lt;s2.top()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">         s2.pop();</span><br><span class="line">     &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //操作</span><br><span class="line">    cout&lt;&lt;&quot;s.empty(): &quot;&lt;&lt;s.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.size(): &quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    // 这里也需要注意一下，必须在确认stack中元素个数不为0的情况下，</span><br><span class="line">    // 才可以使用s.top()来获取栈顶元素，否则就会报错。</span><br><span class="line">    //cout&lt;&lt;&quot;s.top():&quot;&lt;&lt;s.top()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    s.push(1);</span><br><span class="line">    s.emplace(2);</span><br><span class="line">    cout&lt;&lt;&quot;after push2 s.size(): &quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push2 s.empty(): &quot;&lt;&lt;s.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push2 top element is\t&quot;&lt;&lt;s.top()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s.pop();</span><br><span class="line">    cout&lt;&lt;&quot;after pop(),s.size():&quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after pop(),s.top():&quot;&lt;&lt;s.top()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s.push(3);</span><br><span class="line">    s.push(4);</span><br><span class="line">    s.push(5);</span><br><span class="line">    // 遍历</span><br><span class="line">    cout&lt;&lt;&quot;after push 345,s= &quot;;</span><br><span class="line">    while(!s.empty())&#123;</span><br><span class="line">        cout&lt;&lt;s.top()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> s2= 3    2    1</span><br><span class="line"> s.empty(): 1</span><br><span class="line"> s.size(): 0</span><br><span class="line"> after push2 s.size(): 2</span><br><span class="line"> after push2 s.empty(): 0</span><br><span class="line"> after push2 top element is    2</span><br><span class="line"> after pop(),s.size():1</span><br><span class="line"> after pop(),s.top():1</span><br><span class="line"> after push 345,s= 5    4    3    1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>queue的简单使用</title>
    <url>/2020/02/08/queue%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文为c++容器系列第八篇.<br>
主要测试了queue相关的方法，主要作为代码备份方便之后遗忘时查询。</p>
<a id="more"></a>
<p>准确来讲，queue并不是容器，而是在容器的基础上进行了一定封装的adapter.符合先进先出(FIFO)的特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // 声明</span><br><span class="line">    queue&lt;int&gt; q ;</span><br><span class="line">    queue&lt;int&gt; q1(&#123;1,2,3,4&#125;);</span><br><span class="line">    queue&lt;int&gt; q2(q1);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;q2: &quot;;</span><br><span class="line">    while(q2.size() != 0)&#123;</span><br><span class="line">         cout&lt;&lt;q2.front()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">         q2.pop();</span><br><span class="line">     &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // 其他操作。 如果队列为空，那么调用front和back的时候就会报错，</span><br><span class="line">    // 所以给我们的警示就是在通过front和back方法获取队列元素的时候，需要提前确定内部是存在对应的元素的。</span><br><span class="line">    //cout&lt;&lt;&quot;q.front():&quot;&lt;&lt;q.front()&lt;&lt;endl;</span><br><span class="line">    //cout&lt;&lt;&quot;q.back():&quot;&lt;&lt;q.back()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;q.empty():&quot;&lt;&lt;q.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;q.size():&quot;&lt;&lt;q.size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    q.push(1);</span><br><span class="line">    q.emplace(2);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;after push q.front():&quot;&lt;&lt;q.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push q.back():&quot;&lt;&lt;q.back()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push q.empty():&quot;&lt;&lt;q.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;after push q.size():&quot;&lt;&lt;q.size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    q.pop();</span><br><span class="line">    cout&lt;&lt;&quot;after pop(): &quot;;</span><br><span class="line">    while(q.size() != 0)&#123;</span><br><span class="line">        cout&lt;&lt;q.front()&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果</span><br><span class="line"> q2: 1    2    3    4</span><br><span class="line"> q.empty():1</span><br><span class="line"> q.size():0</span><br><span class="line"> after push q.front():1</span><br><span class="line"> after push q.back():2</span><br><span class="line"> after push q.empty():0</span><br><span class="line"> after push q.size():2</span><br><span class="line"> after pop(): 2    Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>multimap的简单使用</title>
    <url>/2020/02/07/multimap%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文为c++容器系列第七篇.<br>
主要测试了multimap相关的方法，主要作为代码备份方便之后遗忘时查询。<br>
map,multimap,unordered_map,unordered_multimap仅仅有稍许差别，方法和multimap基本类似，所以不再另行写文章啦。</p>
<a id="more"></a>
<h2 id="写在最前面">写在最前面</h2>
<ol>
<li>map和multimap的差别仅仅在于multimap插入的key值可以相同，其他操作都类似。所有不再单独另写文章啦。</li>
<li>unordered_map的使用方法和map几乎完全一致。记得引入头文件然后声明的时候声明就好啦。所以也不再单独再重新写一篇文章啦。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 引入头文件</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">// 使用的时候如同下面这种方式声明即可。</span><br><span class="line">unordered_map&lt;int,int&gt; mmap;</span><br></pre></td></tr></table></figure>
<p>同样的需要记住的是，带有unordered前缀的容器都是没有upper_bound和lower_bound的。</p>
<h2 id="multimap的测试代码">multimap的测试代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class K&gt;</span><br><span class="line">void print(const string s,const K&amp; mmap)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    for(auto&amp; a:mmap)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a.first&lt;&lt;&quot;,&quot;&lt;&lt;a.second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    multimap&lt;int,char&gt; dict &#123;</span><br><span class="line">        &#123;1,&apos;A&apos;&#125;,</span><br><span class="line">        &#123;2,&apos;B&apos;&#125;,</span><br><span class="line">        &#123;2,&apos;C&apos;&#125;,</span><br><span class="line">        &#123;3,&apos;D&apos;&#125;,</span><br><span class="line">        &#123;3,&apos;E&apos;&#125;,</span><br><span class="line">        &#123;2,&apos;F&apos;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //通过empty()来判断multimap是否为空</span><br><span class="line">    cout&lt;&lt;&quot;dict.empty() &quot;&lt;&lt;dict.empty()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //通过size()来判断元素个数</span><br><span class="line">    cout&lt;&lt;&quot;dict.size() &quot;&lt;&lt;dict.size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    print(&quot;插入前 size = &quot;+to_string(dict.size()),dict);</span><br><span class="line">    // 通过insert插入元素</span><br><span class="line">    dict.insert(&#123;4,&apos;G&apos;&#125;);</span><br><span class="line">    dict.insert(pair&lt;int, char&gt;(4,&apos;F&apos;));</span><br><span class="line">    dict.insert(make_pair(4, &apos;H&apos;));</span><br><span class="line">    dict.insert(&#123;&#123;5,&apos;I&apos;&#125;,&#123;5,&apos;J&apos;&#125;&#125;);</span><br><span class="line">    print(&quot;插入后 size = &quot;+to_string(dict.size()),dict);</span><br><span class="line"></span><br><span class="line">    // 通过erase来删除特定key的元素,参数可以是key，也可以是一个iterator</span><br><span class="line">    dict.erase(1);</span><br><span class="line">    print(&quot;删除key=1后 size = &quot;+to_string(dict.size()),dict);</span><br><span class="line"></span><br><span class="line">    // 返回类型是pair&lt;iterator,iterator&gt;,仅仅返回符合条件的pair</span><br><span class="line">    auto range = dict.equal_range(2);</span><br><span class="line">    //cout&lt;&lt;typeid(range).name()&lt;&lt;endl; //pair类型</span><br><span class="line">    cout&lt;&lt;&quot;equal_range(2) &quot;&lt;&lt;endl;</span><br><span class="line">    for(auto i = range.first;i!=range.second;++i)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;i.first\t&quot;&lt;&lt;i-&gt;first&lt;&lt;&quot;\ti.second\t&quot;&lt;&lt;i-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // lower_bound</span><br><span class="line">    auto lower = dict.lower_bound(2);</span><br><span class="line">    cout&lt;&lt;&quot;lower_bound(2) &quot;&lt;&lt;(lower-&gt;first)&lt;&lt;&quot; &quot;&lt;&lt;lower-&gt;second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    // upper_bound</span><br><span class="line">    auto upper = dict.upper_bound(2);</span><br><span class="line">    cout&lt;&lt;&quot;upper_bound(2) &quot;&lt;&lt;(upper-&gt;first)&lt;&lt;&quot; &quot;&lt;&lt;upper-&gt;second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    // equal_range返回的两个pair实际上就是用lower_bound和upper_bound来实现的</span><br><span class="line">    cout&lt;&lt;&quot;lower_bound == range.first &quot;&lt;&lt; (lower == range.first)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;upper_bound == range.second &quot;&lt;&lt; (upper == range.second)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //通过count来判断key等于给定的值一共有多少个pair</span><br><span class="line">    cout&lt;&lt;&quot;count(2) &quot;&lt;&lt;dict.count(2)&lt;&lt;endl;</span><br><span class="line">    //这个数量可以通过range的两个iterator来实现查找</span><br><span class="line">    cout&lt;&lt;&quot;distance(range.first,range.second) &quot;&lt;&lt;distance(range.first,range.second)&lt;&lt;endl;</span><br><span class="line">    //或者使用lower_bound和upper_bound来实现</span><br><span class="line">    cout&lt;&lt;&quot;distance(lower,upper)&quot;&lt;&lt;distance(lower, upper)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //通过find来判断是否存在key,返回一个iterator,如果有多个key符合条件，不一定会返回哪一个。</span><br><span class="line">    auto find2 = dict.find(2);</span><br><span class="line">    cout&lt;&lt;&quot;find2 &quot;&lt;&lt;find2-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;find2-&gt;second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //如果通过find来查找的时候没有找到对应的key,那么就会返回dict.end()这个iterator</span><br><span class="line">    auto find10 = dict.find(10);</span><br><span class="line">    cout&lt;&lt;&quot;find10==dict.end &quot;&lt;&lt;(find10==dict.end())&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    auto a = dict.begin();</span><br><span class="line">    cout&lt;&lt;&quot;dict.begin().type &quot;&lt;&lt;typeid(a).name()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //关于各类iterator</span><br><span class="line">    cout&lt;&lt;&quot;正向遍历dict.begin()-&gt;dict.end()&quot;&lt;&lt;endl;</span><br><span class="line">    for(auto a = dict.begin(); a!=dict.end(); a++)&#123;</span><br><span class="line">       // a-&gt;second = &apos;M&apos;; 这里修改就没有问题</span><br><span class="line">        cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;a-&gt;second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;正向遍历，dict.cbegin()-&gt;dict.cend()&quot;&lt;&lt;endl;</span><br><span class="line">    for(auto a = dict.cbegin(); a!=dict.cend(); a++)&#123;</span><br><span class="line">       // a -&gt; second = &apos;N&apos;; 这里修改就有问题，原因是返回的const_iterator是不允许修改的。</span><br><span class="line">        cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;a-&gt;second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;反向遍历，dict.rbegin()-&gt;dict.rend()&quot;&lt;&lt;endl;</span><br><span class="line">    for(auto a = dict.rbegin(); a!=dict.rend(); a++)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;a-&gt;second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;反向遍历，dict.rbegin()-&gt;dict.rend()&quot;&lt;&lt;endl;</span><br><span class="line">    for(auto a = dict.rbegin(); a!=dict.rend(); a++)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;a-&gt;second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;反向遍历，dict.crbegin()-&gt;dict.crend()&quot;&lt;&lt;endl;</span><br><span class="line">       for(auto a = dict.crbegin(); a!=dict.crend(); a++)&#123;</span><br><span class="line">           cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;a-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;a-&gt;second&lt;&lt;&quot;&#125; &quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果</span><br><span class="line"> dict.empty() 0</span><br><span class="line"> dict.size() 6</span><br><span class="line"> 插入前 size = 6</span><br><span class="line"> &#123;1,A&#125; &#123;2,B&#125; &#123;2,C&#125; &#123;2,F&#125; &#123;3,D&#125; &#123;3,E&#125;</span><br><span class="line"> 插入后 size = 11</span><br><span class="line"> &#123;1,A&#125; &#123;2,B&#125; &#123;2,C&#125; &#123;2,F&#125; &#123;3,D&#125; &#123;3,E&#125; &#123;4,G&#125; &#123;4,F&#125; &#123;4,H&#125; &#123;5,I&#125; &#123;5,J&#125;</span><br><span class="line"> 删除key=1后 size = 10</span><br><span class="line"> &#123;2,B&#125; &#123;2,C&#125; &#123;2,F&#125; &#123;3,D&#125; &#123;3,E&#125; &#123;4,G&#125; &#123;4,F&#125; &#123;4,H&#125; &#123;5,I&#125; &#123;5,J&#125;</span><br><span class="line"> equal_range(2)</span><br><span class="line"> i.first    2    i.second    B</span><br><span class="line"> i.first    2    i.second    C</span><br><span class="line"> i.first    2    i.second    F</span><br><span class="line"> lower_bound(2) 2 B</span><br><span class="line"> upper_bound(2) 3 D</span><br><span class="line"> lower_bound == range.first 1</span><br><span class="line"> upper_bound == range.second 1</span><br><span class="line"> count(2) 3</span><br><span class="line"> distance(range.first,range.second) 3</span><br><span class="line"> distance(lower,upper)3</span><br><span class="line"> find2 2 B</span><br><span class="line"> find10==dict.end 1</span><br><span class="line"> dict.begin().type NSt3__114__map_iteratorINS_15__tree_iteratorINS_12__value_typeIicEEPNS_11__tree_nodeIS3_PvEElEEEE</span><br><span class="line"> 正向遍历dict.begin()-&gt;dict.end()</span><br><span class="line"> &#123;2,B&#125; &#123;2,C&#125; &#123;2,F&#125; &#123;3,D&#125; &#123;3,E&#125; &#123;4,G&#125; &#123;4,F&#125; &#123;4,H&#125; &#123;5,I&#125; &#123;5,J&#125; 正向遍历，dict.cbegin()-&gt;dict.cend()</span><br><span class="line"> &#123;2,B&#125; &#123;2,C&#125; &#123;2,F&#125; &#123;3,D&#125; &#123;3,E&#125; &#123;4,G&#125; &#123;4,F&#125; &#123;4,H&#125; &#123;5,I&#125; &#123;5,J&#125;</span><br><span class="line"> 反向遍历，dict.rbegin()-&gt;dict.rend()</span><br><span class="line"> &#123;5,J&#125; &#123;5,I&#125; &#123;4,H&#125; &#123;4,F&#125; &#123;4,G&#125; &#123;3,E&#125; &#123;3,D&#125; &#123;2,F&#125; &#123;2,C&#125; &#123;2,B&#125;</span><br><span class="line"> 反向遍历，dict.rbegin()-&gt;dict.rend()</span><br><span class="line"> &#123;5,J&#125; &#123;5,I&#125; &#123;4,H&#125; &#123;4,F&#125; &#123;4,G&#125; &#123;3,E&#125; &#123;3,D&#125; &#123;2,F&#125; &#123;2,C&#125; &#123;2,B&#125;</span><br><span class="line"> 反向遍历，dict.crbegin()-&gt;dict.crend()</span><br><span class="line"> &#123;5,J&#125; &#123;5,I&#125; &#123;4,H&#125; &#123;4,F&#125; &#123;4,G&#125; &#123;3,E&#125; &#123;3,D&#125; &#123;2,F&#125; &#123;2,C&#125; &#123;2,B&#125;</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>set的简单用法</title>
    <url>/2020/02/07/set%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>本文为c++容器系列第六篇.<br>
主要测试了set相关的方法，主要作为代码备份方便之后遗忘时查询。<br>
set,multiset,unordered_set,unordered_multiset仅仅有稍许差别，方法和set基本类似，所以不再另行写文章啦。</p>
<a id="more"></a>
<h2 id="写在最前面">写在最前面</h2>
<ol>
<li>由于set和unordered_set的功能几乎完全一致，用的时候记得引入unordered_set的头文件，然后声明对象的时候将set换成unordered_set就可以啦。就像是下面这样</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 引入头文件</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">// 声明对象</span><br><span class="line">unordered_set&lt;int&gt; a = &#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure>
<p>还需要注意的一点就是unordered_set是没有upper_bound和lower_bound方法的。<br>
2. set和multiset都是通过set头文件导入的，multiset相比于set的不同点就在于可以插入相同的元素，用的时候记住就可以啦，所以也不再另行写文章，所有操作参考本文章就行。</p>
<h2 id="set测试代码">set测试代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printSet(const string s,const T&amp; mset)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:mset)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // 声明</span><br><span class="line">    set&lt;int&gt; a;</span><br><span class="line">    set&lt;int&gt; a1 = &#123;1,2,3&#125;;</span><br><span class="line">    set&lt;int&gt; a2(a1);</span><br><span class="line">    set&lt;int&gt; a3(a1.begin(),a1.begin());</span><br><span class="line">    </span><br><span class="line">    printSet(&quot;a:&quot;, a);</span><br><span class="line">    printSet(&quot;a1:&quot;,a1 );</span><br><span class="line">    printSet(&quot;a2:&quot;, a2);</span><br><span class="line">    printSet(&quot;a3:&quot;, a3);</span><br><span class="line">    </span><br><span class="line">    //capacity相关</span><br><span class="line">    cout&lt;&lt;&quot;a.size(): &quot;&lt;&lt;a.size()&lt;&lt;endl;</span><br><span class="line">    a.insert(1);</span><br><span class="line">    cout&lt;&lt;&quot;after insert 1, a.size()&quot;&lt;&lt;a.size()&lt;&lt;endl;</span><br><span class="line">    //set的特性就是不能插入重复元素,如果插入那么就会报错。</span><br><span class="line">    // a.insert(1);</span><br><span class="line">    //cout&lt;&lt;&quot;a.size()&quot;&lt;&lt;a.size()&lt;&lt;endl;</span><br><span class="line">    //printSet(&quot;after 2 time insert 1: &quot;, a);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;a.empty(): &quot;&lt;&lt;a.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;a.max_size(): &quot;&lt;&lt;a.max_size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //modifiers</span><br><span class="line">    a.insert(3);</span><br><span class="line">    printSet(&quot;after insert 3: &quot;, a);</span><br><span class="line">    </span><br><span class="line">    auto find3 = a.find(3);</span><br><span class="line">    a.erase(find3);</span><br><span class="line">    printSet(&quot;after erase3: &quot;, a);</span><br><span class="line"></span><br><span class="line">    a.clear();</span><br><span class="line">    printSet(&quot;after clear:&quot;, a);</span><br><span class="line">    </span><br><span class="line">    a = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    // Look up相关</span><br><span class="line">    //find 会返回一个itertor</span><br><span class="line">    auto f = a.find(2);</span><br><span class="line">    if(f!=a.end())&#123;</span><br><span class="line">        cout&lt;&lt;&quot;find \t&quot;&lt;&lt;*f&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;&quot;not found 2&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;a.find(2)\t&quot;&lt;&lt;*a.find(2)&lt;&lt;endl;</span><br><span class="line">    // count</span><br><span class="line">    cout&lt;&lt;&quot;a.count(3): &quot;&lt;&lt;a.count(3)&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">    // equal_range</span><br><span class="line">    auto equal2 = a.equal_range(2);</span><br><span class="line">    for(auto i = equal2.first; i != equal2.second; i++)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;equal2: &quot;&lt;&lt;*i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     如果我的equal_range判断的值在原来的set中没有会怎么样呢？会等价于a.end()</span><br><span class="line">     所以这里其实是告诉我们，在使用equal_range方法的时候，</span><br><span class="line">     要记得先判断一下返回的pair的第一个iterator指向的是否是end()。</span><br><span class="line">     或者在使用equal_range之前可以先通过find或者count先判断一下要找的key是存在的。</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    auto equal6 = a.equal_range(6);</span><br><span class="line">    cout&lt;&lt;&quot;equal6: &quot;&lt;&lt;*equal6.first&lt;&lt;&quot; &quot;&lt;&lt;*equal6.second&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;equal6.first == a.end(): &quot;&lt;&lt;(equal6.first == a.end())&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;equal6.second == a.end(): &quot;&lt;&lt;(equal6.second == a.end())&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // 确认set中不会有重复元素，那么如果找到，则两个iterator之差肯定为1，</span><br><span class="line">    // 如果找不到，那么差为0,后来发现set的iterator也不可做差运算，此处存疑。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // upper_bound 和 lower_bound</span><br><span class="line">    auto ub = a.upper_bound(4);</span><br><span class="line">    auto lb = a.lower_bound(2);</span><br><span class="line">    cout&lt;&lt;&quot;lower_bound(2): &quot;&lt;&lt;*lb&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;upper_bound(4): &quot;&lt;&lt;*ub&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // 遍历操作</span><br><span class="line">    set&lt;int&gt;::iterator iter = a.begin(); // 等价于auto iter = a.begin();</span><br><span class="line">    for(;iter!=a.end();iter++)&#123;</span><br><span class="line">        cout&lt;&lt;*iter&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果</span><br><span class="line"> a:</span><br><span class="line"> a1:    1    2    3</span><br><span class="line"> a2:    1    2    3</span><br><span class="line"> a3:</span><br><span class="line"> a.size(): 0</span><br><span class="line"> after insert 1, a.size()1</span><br><span class="line"> a.empty(): 0</span><br><span class="line"> a.max_size(): 576460752303423487</span><br><span class="line"> after insert 3:     1    3</span><br><span class="line"> after erase3:     1</span><br><span class="line"> after clear:</span><br><span class="line"> find     2</span><br><span class="line"> a.find(2)    2</span><br><span class="line"> a.count(3): 1</span><br><span class="line"> equal2: 2</span><br><span class="line"> equal6: 32766 32766</span><br><span class="line"> equal6.first == a.end(): 1</span><br><span class="line"> equal6.second == a.end(): 1</span><br><span class="line"> lower_bound(2): 2</span><br><span class="line"> upper_bound(4): 5</span><br><span class="line"> 1    2    3    4    5    Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title>array的简单使用</title>
    <url>/2020/02/06/array%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文为c++容器系列第五篇.<br>
主要测试了array相关的方法，主要作为代码备份方便之后遗忘时查询。</p>
<a id="more"></a>
<p>array是c++11新加入的，是对c类型的树组进行了进一步的封装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;array&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printArray(string s,const T&amp; marr)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:marr)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //声明</span><br><span class="line">    array&lt;int,3&gt; marr = &#123;3,2,4&#125;;</span><br><span class="line">    array&lt;int,2&gt; marr1&#123;1,2&#125;;</span><br><span class="line">    printArray(&quot;marr&quot;,marr);</span><br><span class="line">    printArray(&quot;marr1 &quot;,marr1);</span><br><span class="line">    </span><br><span class="line">    // access 相关</span><br><span class="line">    cout&lt;&lt;&quot;marr[0]: &quot;&lt;&lt;marr[0]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.at(0): &quot;&lt;&lt;marr.at(0)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.data(): &quot;&lt;&lt;*marr.data()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.front(): &quot;&lt;&lt;marr.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.back(): &quot;&lt;&lt;marr.back()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //capacity 相关</span><br><span class="line">    cout&lt;&lt;&quot;marr.size(): &quot;&lt;&lt;marr.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.empty(): &quot;&lt;&lt;marr.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;marr.max_size(): &quot;&lt;&lt;marr.max_size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //Operations</span><br><span class="line">    printArray(&quot;before sort&quot;, marr);</span><br><span class="line">    sort(marr.begin(),marr.end());</span><br><span class="line">    printArray(&quot;after sort&quot;, marr);</span><br><span class="line">    </span><br><span class="line">    marr.fill(5);</span><br><span class="line">    printArray(&quot;marr.fill(5)&quot;, marr);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果</span><br><span class="line"> marr    3    2    4</span><br><span class="line"> marr1     1    2</span><br><span class="line"> marr[0]: 3</span><br><span class="line"> marr.at(0): 3</span><br><span class="line"> marr.data(): 3</span><br><span class="line"> marr.front(): 3</span><br><span class="line"> marr.back(): 4</span><br><span class="line"> marr.size(): 3</span><br><span class="line"> marr.empty(): 0</span><br><span class="line"> marr.max_size(): 3</span><br><span class="line"> before sort    3    2    4</span><br><span class="line"> after sort    2    3    4</span><br><span class="line"> marr.fill(5)    5    5    5</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>forward_list的简单使用</title>
    <url>/2020/02/06/forward-list%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文为c++容器系列第四篇.<br>
主要测试了forward_list相关的方法，主要作为代码备份方便之后遗忘时查询。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">keypoints：</span><br><span class="line">1) 假设单向链表为： 1-&gt;2-&gt;3 则front位置是1，push_front,emplace_front,pop_front都是在此处操作的，</span><br><span class="line">2）没有size()函数，</span><br><span class="line">3）erase和erase函数需要使用c++20支持</span><br><span class="line">4）iterator不支持++，--，+number等操作。</span><br><span class="line">5）插入函数insert_after。</span><br><span class="line">6）forward_list为单向链表，而list是双向链表。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;forward_list&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printList(string s,const T&amp; mlist)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:mlist)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //常见的list的声明方式</span><br><span class="line">    forward_list&lt;int&gt; mlist&#123;1,2,3,4&#125;;</span><br><span class="line">    // 发现不能通过 list&lt;int&gt; mlist1(mlist.begin(),mlist.end()-2);这种方式声明，</span><br><span class="line">    // 也不能通过 list&lt;int&gt; mlist1(mlist.begin(),--mlist.end())这种方式声明,list是可以的。</span><br><span class="line">    forward_list&lt;int&gt; mlist1(mlist.begin(),mlist.end());</span><br><span class="line">    </span><br><span class="line">    forward_list&lt;int&gt; mlist2(mlist);</span><br><span class="line">    forward_list&lt;int&gt; mlist3(5,1);</span><br><span class="line">    forward_list&lt;int&gt; mlist4 = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    </span><br><span class="line">    printList(&quot;mlist&quot;, mlist);</span><br><span class="line">    printList(&quot;mlist1&quot;, mlist1);</span><br><span class="line">    printList(&quot;mlist2&quot;, mlist2);</span><br><span class="line">    printList(&quot;mlist3&quot;, mlist3);</span><br><span class="line">    printList(&quot;mlist4&quot;, mlist4);</span><br><span class="line">    </span><br><span class="line">    //front 获得第一个元素</span><br><span class="line">    cout&lt;&lt;&quot;mlist front: &quot;&lt;&lt;mlist.front()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //遍历通过iterator</span><br><span class="line">    cout&lt;&lt;&quot;print all elements by iterator: &quot;;</span><br><span class="line">    forward_list&lt;int&gt;::iterator a  = mlist.begin();</span><br><span class="line">    for(;a!=mlist.end();a++)&#123;</span><br><span class="line">        cout&lt;&lt;*a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // capacity相关 没有size()函数,为啥？此处存疑。</span><br><span class="line">    cout&lt;&lt;&quot;mlist empty &quot;&lt;&lt;mlist.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist max_size &quot;&lt;&lt;mlist.max_size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // Modifiers相关</span><br><span class="line">    //插入操作</span><br><span class="line">    mlist.insert_after(mlist.begin(), 10);</span><br><span class="line">    // 同样不能通过类似于 mlist.insert(mlist.begin()+2, 10);来插入元素</span><br><span class="line">    mlist.emplace_after(mlist.begin(), 9);</span><br><span class="line">    printList(&quot;insert begin(): &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //插入到头部</span><br><span class="line">    mlist.push_front(10);</span><br><span class="line">    printList(&quot;push_front 10: &quot;, mlist);</span><br><span class="line">    mlist.emplace_front(9);</span><br><span class="line">    printList(&quot;emplace_front 9: &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除头元素</span><br><span class="line">    mlist.pop_front();</span><br><span class="line">    printList(&quot;pop_front : &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//     erase 和erase_if 是c++20提供的</span><br><span class="line">//    auto a4 = find(mlist.begin(),mlist.end(),4);</span><br><span class="line">//    mlist.erase(a4);</span><br><span class="line">//    printList(&quot;after erase a4&quot;, mlist);</span><br><span class="line">//</span><br><span class="line">//    mlist.erase(mlist.begin());</span><br><span class="line">//    printList(&quot;after earse begin()&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // Operations 相关</span><br><span class="line">    // 排序:默认从小到大</span><br><span class="line">    mlist.sort();</span><br><span class="line">    printList(&quot;after sort&quot;, mlist);</span><br><span class="line">    //当然可以改成从大到小</span><br><span class="line">    mlist.sort(greater&lt;int&gt;());</span><br><span class="line">    printList(&quot;after sort big -&gt; small &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //顺序反转</span><br><span class="line">    mlist.reverse();</span><br><span class="line">    printList(&quot;after reverse &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除重复节点</span><br><span class="line">    mlist.unique();</span><br><span class="line">    printList(&quot;after unique&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //删除list中值为10的节点</span><br><span class="line">    mlist.remove(10);</span><br><span class="line">    printList(&quot;after remove 10:&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 删除list中值大于等于3的节点,这里使用了lamda表达式</span><br><span class="line">    mlist.remove_if([](int n)&#123;return n&gt;=3;&#125;);</span><br><span class="line">    printList(&quot;after remove &gt;=3 :&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;before clear mlist.empty() is &quot;&lt;&lt; mlist.empty()&lt;&lt;endl;</span><br><span class="line">    mlist.clear();</span><br><span class="line">    cout&lt;&lt;&quot;after clear mlist.empty() is &quot;&lt;&lt; mlist.empty()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> mlist    1    2    3    4</span><br><span class="line"> mlist1    1    2    3    4</span><br><span class="line"> mlist2    1    2    3    4</span><br><span class="line"> mlist3    1    1    1    1    1</span><br><span class="line"> mlist4    1    2    3    4    5</span><br><span class="line"> mlist front: 1</span><br><span class="line"> print all elements by iterator: 1    2    3    4</span><br><span class="line"> mlist empty 0</span><br><span class="line"> mlist max_size 1152921504606846975</span><br><span class="line"> insert begin():     1    9    10    2    3    4</span><br><span class="line"> push_front 10:     10    1    9    10    2    3    4</span><br><span class="line"> emplace_front 9:     9    10    1    9    10    2    3    4</span><br><span class="line"> pop_front :     10    1    9    10    2    3    4</span><br><span class="line"> after sort    1    2    3    4    9    10    10</span><br><span class="line"> after sort big -&gt; small     10    10    9    4    3    2    1</span><br><span class="line"> after reverse     1    2    3    4    9    10    10</span><br><span class="line"> after unique    1    2    3    4    9    10</span><br><span class="line"> after remove 10:    1    2    3    4    9</span><br><span class="line"> after remove &gt;=3 :    1    2</span><br><span class="line"> before clear mlist.empty() is 0</span><br><span class="line"> after clear mlist.empty() is 1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>Forward_list</tag>
      </tags>
  </entry>
  <entry>
    <title>list的简单使用</title>
    <url>/2020/02/06/list%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文为c++容器系列第三篇.<br>
主要测试了list相关的方法，主要作为代码备份方便之后遗忘时查询。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printList(string s,const T&amp; mlist)&#123;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:mlist)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //常见的list的声明方式</span><br><span class="line">    list&lt;int&gt; mlist&#123;1,2,3,4&#125;;</span><br><span class="line">    // 发现不能通过 list&lt;int&gt; mlist1(mlist.begin(),mlist.end()-2);这种方式声明，但是可以通过下面这种方式进行声明。此处存疑</span><br><span class="line">    list&lt;int&gt; mlist1(mlist.begin(),--mlist.end());</span><br><span class="line">    </span><br><span class="line">    list&lt;int&gt; mlist2(mlist);</span><br><span class="line">    list&lt;int&gt; mlist3(5,1);</span><br><span class="line">    list&lt;int&gt; mlist4 = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    </span><br><span class="line">    printList(&quot;mlist&quot;, mlist);</span><br><span class="line">    printList(&quot;mlist1&quot;, mlist1);</span><br><span class="line">    printList(&quot;mlist2&quot;, mlist2);</span><br><span class="line">    printList(&quot;mlist3&quot;, mlist3);</span><br><span class="line">    printList(&quot;mlist4&quot;, mlist4);</span><br><span class="line">    </span><br><span class="line">    //front 和back 获得第一个元素和最后一个元素</span><br><span class="line">    cout&lt;&lt;&quot;mlist front: &quot;&lt;&lt;mlist.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist back: &quot;&lt;&lt;mlist.back()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //遍历通过iterator</span><br><span class="line">    cout&lt;&lt;&quot;print all elements by iterator: &quot;;</span><br><span class="line">    list&lt;int&gt;::iterator a  = mlist.begin();</span><br><span class="line">    for(;a!=mlist.end();a++)&#123;</span><br><span class="line">        cout&lt;&lt;*a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // capacity相关</span><br><span class="line">    cout&lt;&lt;&quot;mlist empty &quot;&lt;&lt;mlist.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist size() &quot;&lt;&lt;mlist.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;mlist max_size &quot;&lt;&lt;mlist.max_size()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // Modifiers相关</span><br><span class="line">    //插入操作</span><br><span class="line">    mlist.insert(mlist.begin(), 10);</span><br><span class="line">    // 同样不能通过类似于 mlist.insert(mlist.begin()+2, 10);来插入元素</span><br><span class="line">    mlist.emplace(mlist.begin(), 9);</span><br><span class="line">    printList(&quot;insert begin(): &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //插入到头部</span><br><span class="line">    mlist.push_front(10);</span><br><span class="line">    printList(&quot;push_front 10: &quot;, mlist);</span><br><span class="line">    mlist.emplace_front(9);</span><br><span class="line">    printList(&quot;emplace_front 9: &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除头元素</span><br><span class="line">    mlist.pop_front();</span><br><span class="line">    printList(&quot;pop_front : &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 插入到尾部</span><br><span class="line">    mlist.push_back(10);</span><br><span class="line">    printList(&quot;push_back 10: &quot;, mlist);</span><br><span class="line">    mlist.emplace_back(11);</span><br><span class="line">    printList(&quot;emplace_back 11&quot;, mlist);</span><br><span class="line">    // 删除尾部元素</span><br><span class="line">    mlist.pop_back();</span><br><span class="line">    printList(&quot;pop back&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    auto a4 = find(mlist.begin(),mlist.end(),4);</span><br><span class="line">    mlist.erase(a4);</span><br><span class="line">    printList(&quot;after erase a4&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    mlist.erase(mlist.begin());</span><br><span class="line">    printList(&quot;after earse begin()&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 排序:默认从小到大</span><br><span class="line">    mlist.sort();</span><br><span class="line">    printList(&quot;after sort&quot;, mlist);</span><br><span class="line">    //当然可以改成从大到小</span><br><span class="line">    mlist.sort(greater&lt;int&gt;());</span><br><span class="line">    printList(&quot;after sort big -&gt; small &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //顺序反转</span><br><span class="line">    mlist.reverse();</span><br><span class="line">    printList(&quot;after reverse &quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //去除重复节点</span><br><span class="line">    mlist.unique();</span><br><span class="line">    printList(&quot;after unique&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    //删除list中值为10的节点</span><br><span class="line">    mlist.remove(10);</span><br><span class="line">    printList(&quot;after remove 10:&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    // 删除list中值大于等于3的节点,这里使用了lamda表达式</span><br><span class="line">    mlist.remove_if([](int n)&#123;return n&gt;=3;&#125;);</span><br><span class="line">    printList(&quot;after remove &gt;=3 :&quot;, mlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;before clear the size of list is &quot;&lt;&lt; mlist.size()&lt;&lt;endl;</span><br><span class="line">    mlist.clear();</span><br><span class="line">    cout&lt;&lt;&quot;after clear the size of list is &quot;&lt;&lt; mlist.size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> mlist    1    2    3    4</span><br><span class="line"> mlist1    1    2    3</span><br><span class="line"> mlist2    1    2    3    4</span><br><span class="line"> mlist3    1    1    1    1    1</span><br><span class="line"> mlist4    1    2    3    4    5</span><br><span class="line"> mlist front: 1</span><br><span class="line"> mlist back: 4</span><br><span class="line"> print all elements by iterator: 1    2    3    4</span><br><span class="line"> mlist empty 0</span><br><span class="line"> mlist size() 4</span><br><span class="line"> mlist max_size 768614336404564650</span><br><span class="line"> insert begin():     9    10    1    2    3    4</span><br><span class="line"> push_front 10:     10    9    10    1    2    3    4</span><br><span class="line"> emplace_front 9:     9    10    9    10    1    2    3    4</span><br><span class="line"> pop_front :     10    9    10    1    2    3    4</span><br><span class="line"> push_back 10:     10    9    10    1    2    3    4    10</span><br><span class="line"> emplace_back 11    10    9    10    1    2    3    4    10    11</span><br><span class="line"> pop back    10    9    10    1    2    3    4    10</span><br><span class="line"> after erase a4    10    9    10    1    2    3    10</span><br><span class="line"> after earse begin()    9    10    1    2    3    10</span><br><span class="line"> after sort    1    2    3    9    10    10</span><br><span class="line"> after sort big -&gt; small     10    10    9    3    2    1</span><br><span class="line"> after reverse     1    2    3    9    10    10</span><br><span class="line"> after unique    1    2    3    9    10</span><br><span class="line"> after remove 10:    1    2    3    9</span><br><span class="line"> after remove &gt;=3 :    1    2</span><br><span class="line"> before clear the size of list is 2</span><br><span class="line"> after clear the size of list is 0</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>deque的简单使用</title>
    <url>/2020/02/06/deque%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文为c++容器系列第二篇.<br>
主要测试了deque相关的方法，主要作为代码备份方便之后遗忘时查询。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void printContainer(const char * msg,const T&amp; s)&#123;</span><br><span class="line">    cout&lt;&lt;msg&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    copy(s.begin(),s.end(),ostream_iterator&lt;int&gt;(cout, &quot; &quot;));</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //三种声明方式</span><br><span class="line">    deque&lt;int&gt; s=&#123;1,2,3,4&#125;;</span><br><span class="line">    deque&lt;int&gt; s1&#123;1,2,3,4&#125;;</span><br><span class="line">    deque&lt;int&gt; s2(s.begin(),s.end()-1);</span><br><span class="line"></span><br><span class="line">    printContainer(&quot;deque s&quot;,s);</span><br><span class="line">    printContainer(&quot;deque s1&quot;,s1);</span><br><span class="line">    printContainer(&quot;deque s2 &quot;,s2);</span><br><span class="line">    </span><br><span class="line">    //两种获取对应位置元素的方式</span><br><span class="line">    cout&lt;&lt;&quot;s[0] &quot;&lt;&lt;s[0]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;a.at[0] &quot;&lt;&lt;s.at(0)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    //打印出全部的元素</span><br><span class="line">    cout&lt;&lt;&quot;print all elements &quot;&lt;&lt;endl;</span><br><span class="line">    for(auto i:s)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;&quot;print all elements by iteror&quot;&lt;&lt;endl;</span><br><span class="line">    auto siter = s.begin();</span><br><span class="line">    while(siter!=s.end())&#123;</span><br><span class="line">        cout&lt;&lt;*siter&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        siter++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;s.front() &quot;&lt;&lt;s.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.back() &quot;&lt;&lt;s.back()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;s.begin() &quot;&lt;&lt;*s.begin()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.end()-s.begin() &quot;&lt;&lt;s.end()-s.begin()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;s.empty() &quot;&lt;&lt;s.empty()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.size() &quot;&lt;&lt;s.size()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;s.max_size() &quot;&lt;&lt;s.max_size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    //s.clear();</span><br><span class="line">    //cout&lt;&lt;&quot;after clear s.empty() &quot;&lt;&lt;s.empty()&lt;&lt;endl;  // 1</span><br><span class="line"></span><br><span class="line">    s.push_front(5);</span><br><span class="line">    printContainer(&quot;after push front 5: &quot;,s);</span><br><span class="line">    s.pop_front();</span><br><span class="line">    printContainer(&quot;after pop front: &quot;,s);</span><br><span class="line"></span><br><span class="line">    s.push_back(5);</span><br><span class="line">    printContainer(&quot;after push back5: &quot;,s);</span><br><span class="line">    s.pop_back();</span><br><span class="line">    printContainer(&quot;after pop back: &quot;,s);</span><br><span class="line"></span><br><span class="line">    s.emplace(s.begin()+2,5);</span><br><span class="line">    printContainer(&quot;emplace begin+2 &quot;,s);</span><br><span class="line"></span><br><span class="line">    s.emplace_back(6);</span><br><span class="line">    printContainer(&quot;emplace back&quot;,s);</span><br><span class="line"></span><br><span class="line">    s.erase(s.begin()+2);</span><br><span class="line">    printContainer(&quot;erase begin+2&quot;,s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //用列表容器1的内容给s赋值，将s输出</span><br><span class="line">    reverse(s.begin(),s.end());</span><br><span class="line">    printContainer(&quot;deque l by assign:&quot;,s);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果</span><br><span class="line"> deque s    1 2 3 4</span><br><span class="line"> deque s1    1 2 3 4</span><br><span class="line"> deque s2     1 2 3</span><br><span class="line"> s[0] 1</span><br><span class="line"> a.at[0] 1</span><br><span class="line"> print all elements</span><br><span class="line"> 1    2    3    4</span><br><span class="line"> print all elements by iteror</span><br><span class="line"> 1    2    3    4</span><br><span class="line"> s.front() 1</span><br><span class="line"> s.back() 4</span><br><span class="line"> s.begin() 1</span><br><span class="line"> s.end()-s.begin() 4</span><br><span class="line"> s.empty() 0</span><br><span class="line"> s.size() 4</span><br><span class="line"> s.max_size() 4611686018427387903</span><br><span class="line"> after push front 5:     5 1 2 3 4</span><br><span class="line"> after pop front:     1 2 3 4</span><br><span class="line"> after push back5:     1 2 3 4 5</span><br><span class="line"> after pop back:     1 2 3 4</span><br><span class="line"> emplace begin+2     1 2 5 3 4</span><br><span class="line"> emplace back    1 2 5 3 4 6</span><br><span class="line"> erase begin+2    1 2 3 4 6</span><br><span class="line"> deque l by assign:    6 4 3 2 1</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title>vector的简单使用</title>
    <url>/2020/02/06/vector%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文为c++容器系列第一篇.<br>
主要测试了vector相关的方法，主要作为代码备份方便之后遗忘时查询。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double getAverage(const vector&lt;double&gt; &amp;arr)&#123;</span><br><span class="line">    double sum =0;</span><br><span class="line">    for (unsigned i=0;i&lt;arr.size();i++)&#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum/arr.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void printVector(const char * msg,T&amp; s)&#123;</span><br><span class="line">    cout&lt;&lt;msg&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    for(auto a:s)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&apos;\n&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //vector 初始化的方式</span><br><span class="line">    vector&lt;double&gt; arr =&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">    vector&lt;int&gt; arr1(5,1);</span><br><span class="line">    vector&lt;int&gt; arr2&#123;1,2,3,4,5&#125;;</span><br><span class="line">    auto arr3 = &#123;1,2,3&#125;;</span><br><span class="line">    vector&lt;int&gt; arr4(arr2.begin(),arr2.begin()+2);</span><br><span class="line">    vector&lt;int&gt; arr5(5);</span><br><span class="line">    </span><br><span class="line">    printVector(&quot;print initial content arr:&quot;,arr);   //1    2    3    4    5    6</span><br><span class="line">    printVector(&quot;print initial content arr1:&quot;,arr1); // 1    1    1    1    1</span><br><span class="line">    printVector(&quot;print initial content arr2:&quot;,arr2); // 1    2    3    4    5</span><br><span class="line">    printVector(&quot;print initial content arr3:&quot;,arr3); // 1    2    3</span><br><span class="line">    printVector(&quot;print initial content arr4:&quot;,arr4); // 1    2</span><br><span class="line">    printVector(&quot;print initial content arr5:&quot;,arr5); // 0    0    0    0    0</span><br><span class="line">    </span><br><span class="line">    //直接通过索引获取数据</span><br><span class="line">    cout&lt;&lt;&quot;arr[2]: \t&quot;&lt;&lt;arr[2]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;arr.at(2) \t &quot;&lt;&lt;arr.at(2)&lt;&lt;endl;</span><br><span class="line">    // 通过front获得头元素。通过back获得尾部元素</span><br><span class="line">    cout&lt;&lt;&quot;arr.front() \t&quot;&lt;&lt;arr.front()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;arr.back() \t&quot;&lt;&lt;arr.back()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;arr.data()\t&quot;&lt;&lt;*(arr.data()+1)&lt;&lt;endl; </span><br><span class="line">    // arr.data()返回值是一个指针，指向数组的第一个值</span><br><span class="line">    // arr.begin()返回值是一个iterator, 同样指向数组的第一个值。</span><br><span class="line">    cout&lt;&lt;&quot;*data() == *begin() &quot;&lt;&lt;(*arr.data()==*arr.begin())&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;arr.begin()\t&quot;&lt;&lt;*arr.begin()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    // size()是获取当前vector的元素个数</span><br><span class="line">    cout&lt;&lt;&quot;arr.size()\t&quot;&lt;&lt;arr.size()&lt;&lt;endl;</span><br><span class="line">    // empty()是判断当前数组是否为空</span><br><span class="line">    cout&lt;&lt;&quot;arr.empty()\t&quot;&lt;&lt;arr.empty()&lt;&lt;endl;</span><br><span class="line">    // capacity() returns the number of elements </span><br><span class="line">    that can be held in currently allocated storage</span><br><span class="line">    cout&lt;&lt;&quot;arr.capacity()\t&quot;&lt;&lt;arr.capacity()&lt;&lt;endl;</span><br><span class="line">    // returns the maximum possible number of elements</span><br><span class="line">    cout&lt;&lt;&quot;arr.max_size()\t&quot;&lt;&lt;arr.max_size()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    // 清空整个数组</span><br><span class="line">    arr.clear();</span><br><span class="line">    printVector(&quot;arr.clear()&quot;, arr);</span><br><span class="line"> </span><br><span class="line">    //insert 在对应位置前面添加一个元素，成为这个位置的元素</span><br><span class="line">    arr.insert(arr.begin(), 1);</span><br><span class="line">    printVector(&quot;insert begin \t&quot;, arr);</span><br><span class="line">    arr.insert(arr.begin(), 4);</span><br><span class="line">    printVector(&quot;insert begin&quot;, arr);</span><br><span class="line">    arr.insert(arr.end(),2);</span><br><span class="line">    printVector(&quot;insert end()\t&quot;,arr);</span><br><span class="line">    </span><br><span class="line">    //emplace 在对应位置前面添加一个元素,功能类似于insert.</span><br><span class="line">    //两者的区别在于insert插入的是一个对象，一个已经构建好的对象</span><br><span class="line">    // 而emplace可以直接传入参数，这里隐含一个构造函数。</span><br><span class="line">    arr.emplace(arr.begin(), 3);</span><br><span class="line">    printVector(&quot;emplace begin()&quot;, arr);</span><br><span class="line">    arr.emplace(arr.begin()+1,5);</span><br><span class="line">    printVector(&quot;emplace begin+1&quot;, arr);</span><br><span class="line">    </span><br><span class="line">    //erase：删除iteator所指向的元素。</span><br><span class="line">    arr.erase(arr.begin());</span><br><span class="line">    printVector(&quot;erase begin \t&quot;, arr);</span><br><span class="line">    arr.erase(arr.end()-1);</span><br><span class="line">    printVector(&quot;erase end-1&quot;,arr);</span><br><span class="line">    </span><br><span class="line">    // arr.begin()返回指向vector第一个元素的指针</span><br><span class="line">    // arr.end()返回指向vector最后一个元素再后面一个元素的指针。</span><br><span class="line">    printVector(&quot;print arr &quot;, arr);</span><br><span class="line">    cout&lt;&lt;&quot;arr.begin() \t&quot;&lt;&lt;*arr.begin()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;arr.end()-1 \t&quot;&lt;&lt;*(arr.end()-1)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;arr.end() \t&quot;&lt;&lt;*arr.end()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    // 通过iterator打印整个vector</span><br><span class="line">    cout&lt;&lt;&quot;print the vector&quot;&lt;&lt;endl;</span><br><span class="line">    // 下面两个构造方式等价，auto 是c++11的新特性。</span><br><span class="line">    //vector&lt;double&gt;::iterator a = arr.begin();</span><br><span class="line">    auto a = arr.begin();</span><br><span class="line">    while(a!=arr.end())&#123;</span><br><span class="line">        cout&lt;&lt;*a&lt;&lt;&apos;\t&apos;;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // vector 添加一个元素到末尾</span><br><span class="line">    arr.push_back(6);</span><br><span class="line">    printVector(&quot;push back 6： &quot;, arr);</span><br><span class="line">    </span><br><span class="line">    // vector 删除最后一个元素</span><br><span class="line">    arr.pop_back();</span><br><span class="line">    printVector(&quot;pop back 6： &quot;, arr);</span><br><span class="line">    </span><br><span class="line">    // 先打印原来的数据。</span><br><span class="line">    printVector(&quot;former vector&quot;, arr);</span><br><span class="line">    </span><br><span class="line">    // 这个其实也是构造函数，得到arr树组的反序树组</span><br><span class="line">    vector&lt;int&gt; rarr(arr.rbegin(),arr.rend());</span><br><span class="line">    printVector(&quot;reverse arr&quot;, rarr);</span><br><span class="line">    </span><br><span class="line">    // 可以直接通过stl中的reverse方式来将原来的vector进行逆序</span><br><span class="line">    reverse(arr.begin(),arr.end());</span><br><span class="line">    printVector(&quot;reverse former arr&quot;, arr);</span><br><span class="line">    </span><br><span class="line">    // 调用前面的方法得到树组的平均数</span><br><span class="line">    cout&lt;&lt;&quot;average of arr:&quot;&lt;&lt;getAverage(arr)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 运行结果</span><br><span class="line"> print initial content arr:    1    2    3    4    5    6</span><br><span class="line"> print initial content arr1:    1    1    1    1    1</span><br><span class="line"> print initial content arr2:    1    2    3    4    5</span><br><span class="line"> print initial content arr3:    1    2    3</span><br><span class="line"> print initial content arr4:    1    2</span><br><span class="line"> print initial content arr5:    0    0    0    0    0</span><br><span class="line"> arr[2]:     3</span><br><span class="line"> arr.at(2)      3</span><br><span class="line"> arr.front()     1</span><br><span class="line"> arr.back()     6</span><br><span class="line"> arr.data()    2</span><br><span class="line"> *data() == *begin() 1</span><br><span class="line"> arr.begin()    1</span><br><span class="line"> arr.size()    6</span><br><span class="line"> arr.empty()    0</span><br><span class="line"> arr.capacity()    6</span><br><span class="line"> arr.max_size()    2305843009213693951</span><br><span class="line"> arr.clear()</span><br><span class="line"> insert begin         1</span><br><span class="line"> insert begin    4    1</span><br><span class="line"> insert end()        4    1    2</span><br><span class="line"> emplace begin()    3    4    1    2</span><br><span class="line"> emplace begin+1    3    5    4    1    2</span><br><span class="line"> erase begin         5    4    1    2</span><br><span class="line"> erase end-1    5    4    1</span><br><span class="line"> print arr     5    4    1</span><br><span class="line"> arr.begin()     5</span><br><span class="line"> arr.end()-1     1</span><br><span class="line"> arr.end()     2</span><br><span class="line"> print the vector</span><br><span class="line"> 5    4    1    push back 6：     5    4    1    6</span><br><span class="line"> pop back 6：     5    4    1</span><br><span class="line"> former vector    5    4    1</span><br><span class="line"> reverse arr    1    4    5</span><br><span class="line"> reverse former arr    1    4    5</span><br><span class="line"> Program ended with exit code: 0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-孩子们的游戏</title>
    <url>/2020/01/29/%E5%89%91%E6%8C%87offer-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第六十七篇。<br>
主要知识点为约瑟夫环，偏向于数学一点，值得认真仔细的看。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数…这样下去…直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)<br>
如果没有小朋友，请返回-1；</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>通过一个环形链表来循环跑圈，每次删除编号为m-1的节点，直到最后只剩下一个节点，就是想要的节点。</p>
<h3 id="思路2">思路2</h3>
<p>约瑟夫环。<br>
最开始是n个人，m个数字，如果从0开始编码，那么第一个删除的节点k = (m-1)%n,继续向后从0开始对k+1,k+2,……,0,1,……，n-2,n-1进行编号，则前后的对应关系如下。<br>
X  -&gt; Y<br>
k+1 -&gt; 0<br>
k+2 -&gt; 1<br>
……<br>
0  -&gt; n-k-1<br>
1  -&gt; n-k<br>
……<br>
n-1 -&gt; n-2<br>
我们可以发现变化后的编号Y和变化前的编号有一定的对应关系，<br>
Y = (X-k-1)%n,对以的X = (Y+k+1)%n,将k = (m-1)%n代入，X = (Y+m)%n，<br>
我们将这个关系用函数表示，F(n,m)表示n个人每次删除第m个数字最后剩下的数字，则上面的关系就变成了F(n,m) = (F(n-1,m)+m)%n,同时很明显的F(1,m) = 0;<br>
进而可以利用递归得到我们最后的解。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int LastRemaining_Solution(int n, int m)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n &lt; 1 || m &lt; 1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(n == 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // F[n] = (F[n - 1] + m) % n</span><br><span class="line">            return (LastRemaining_Solution(n-1,m)+m)%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二叉搜索树与双向链表</title>
    <url>/2020/01/28/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第六十六篇。<br>
主要知识点为二叉搜索树还有双向链表，这个题目个人感觉比较难，但是题目非常好。<br>
值得我们认真且细致的去理解两者之间的关系，并将这个问题做出来。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>首先我们要明晰二叉搜索树和双向链表各自的特点。</li>
<li>然后在处理的时候可以将这个二叉搜索树分为三部分，左子树，根节点，右子树。我们的目标实际上就是将左子树转化成的双向链表链接上根节点再链接到右子树转化成的双向链表，所以自然就会想到用递归来实现。</li>
<li>最后就是细节的处理，要注意在链接左子树和根节点的时候，是将左子树的最大的节点和根节点链接起来，其实就是右下角的节点，<br>
在链接根节点和右子树的时候，是将根节点和右子树中最小的节点进行链接，其实也就是最左下角的节点。</li>
</ul>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* Convert(TreeNode* pRootOfTree)&#123;</span><br><span class="line">         if(pRootOfTree==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">        if(pRootOfTree-&gt;left==NULL&amp;&amp;pRootOfTree-&gt;right==NULL)</span><br><span class="line">            return pRootOfTree;//如果是叶子结点则直接返回当前节点</span><br><span class="line">        TreeNode* left = Convert(pRootOfTree-&gt;left);//找到左子树最左端节点</span><br><span class="line">        TreeNode* curr = left;</span><br><span class="line">        </span><br><span class="line">        //找到左子树最右侧节点</span><br><span class="line">        while(curr!=NULL&amp;&amp;curr-&gt;right!=NULL)</span><br><span class="line">            curr=curr-&gt;right;</span><br><span class="line">        //连接根节点和左子树</span><br><span class="line">        if(curr!=NULL)&#123;</span><br><span class="line">            curr-&gt;right=pRootOfTree;</span><br><span class="line">            pRootOfTree-&gt;left = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //找到右子树最左端节点</span><br><span class="line">        TreeNode* right = Convert(pRootOfTree-&gt;right);</span><br><span class="line">        //连接根节点和右子树</span><br><span class="line">        if(right!=NULL)&#123;</span><br><span class="line">            pRootOfTree-&gt;right = right;</span><br><span class="line">            right-&gt;left = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        return left!=NULL?left:pRootOfTree;//返回最左边节点的位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinarySearchTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-替换空格</title>
    <url>/2020/01/28/%E5%89%91%E6%8C%87offer-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第六十五篇。<br>
主要知识点为字符串，平常就是一个调库可以解决的问题，这里要自己来实现。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>由于c++的char类型没有封装好的用来替换字符的方法，所以我们可以用python直接调用库来解决。</p>
<h3 id="思路2">思路2</h3>
<p>其实可以再申请一段空间作为res，然后依次的遍历原来的char，碰到非空格就直接加到res中，碰到空格就加上“%20”，最后将原来的指针指向新的res即可。</p>
<h3 id="思路3">思路3</h3>
<p>思路2存在一个问题就是需要再申请一段空间，其实可以直接在原来的char上进行操作。<br>
按照正常情况，char字符串是以‘\0’为标识结束的，所以我们可以往后延长数据，延长（2*空格个数）个字节，因为本来的一个空格现在变成了‘20%’。<br>
用两个指针分别指向原来的字符串和延长后字符串的最后一位，依次向前遍历，将非空格数据进行后移，将空格数据进行替换。<br>
等到两个指针重合说明已经替换完成，从而这个问题就结束了。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    # s 源字符串 </span><br><span class="line">    # 直接调用替换函数 24ms 5868k</span><br><span class="line">    def replaceSpace(self, s):</span><br><span class="line">        # write code here</span><br><span class="line">        return s.replace(&apos; &apos;,&apos;%20&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="思路3代码">思路3代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        int spaceNum = 0;</span><br><span class="line">        char *p = str;</span><br><span class="line">        while(*p != &apos;\0&apos;)&#123;</span><br><span class="line">            if(*p == &apos; &apos;)&#123;</span><br><span class="line">                spaceNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        char* last = p+spaceNum*2;</span><br><span class="line">        while(p != last)&#123;</span><br><span class="line">            if(*p == &apos; &apos;)&#123;</span><br><span class="line">                *(last--) = &apos;0&apos;;</span><br><span class="line">                *(last--) = &apos;2&apos;;</span><br><span class="line">                *(last--) = &apos;%&apos;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                *(last--) = *(p);</span><br><span class="line">            &#125;</span><br><span class="line">            p--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-剪绳子</title>
    <url>/2020/01/27/%E5%89%91%E6%8C%87offer-%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第六十四篇。<br>
主要知识点为整数拆分，可以用贪心算法或者动态规划来解决。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="">题目描述</a></h2>
<p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>
输入描述:<br>
输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）<br>
输出描述:<br>
输出答案。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1贪心算法">思路1贪心算法</h3>
<p>设绳长为n，则有如下的结论</p>
<ol>
<li>n = 2,剪成2段，1*1 = 1</li>
<li>n = 3,剪成2段，1*2 = 2</li>
<li>n = 4,剪成2段，2*2 = 4</li>
<li>n = 5,剪成2段, 2*3 = 6</li>
<li>n = 6,剪成2段，3*3 = 9</li>
</ol>
<p>当n &gt; 5的时候3*(n-3)&gt; 2*(n-2)<br>
所以答案就是尽可能的多剪长度为3的段,同时不要长度为1的段;如果有1，那就和3一起拼成一个4，切割成2和2。</p>
<h3 id="思路2动态规划">思路2动态规划</h3>
<p>假设长度为n的绳子的结果为f(n)，如果我们切一刀,变为n-i和i两段，<br>
那么f(n)应该等于f(n-i)*f(i),所以在计算后面的f值的时候，会用到前面的f值，<br>
所以对前面的结果进行保存。自底向上的得到我们最后的解。<br>
然后考虑到类似于2,3,4这种其实不切一刀要比切一刀的结果更大，所以在计算f(n)的时候要将i*(n-i)考虑在内，意味着说这段如果只切一刀（切完的两端不再进行进一步的切割，比如4就切成2和2，而不是f(2)*f(2)）会得到一个什么样的结果。<br>
所以综合以上考虑,对于长为n的绳子，f(n) = max(f(n-i)*f(i),(n-i)*i), i的取值从1到n-1;</p>
<h2 id="解题代码">解题代码</h2>
<h2 id="思路1代码">思路1代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cutRope(int number) &#123;</span><br><span class="line">        if(number == 2) return 1;</span><br><span class="line">        if(number == 3) return 2;</span><br><span class="line">        if(number == 4) return 4;</span><br><span class="line">        if(number == 5) return 6;</span><br><span class="line">        return 3*cutRope(number-3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h2 id="思路2代码">思路2代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cutRope(int number) &#123;</span><br><span class="line">        // 方法2 ：dp</span><br><span class="line">        vector&lt;int&gt; dp(number+1,0);</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2; i&lt;=number; i++)&#123;</span><br><span class="line">            for(int j = 1;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i] = max(dp[i],max(dp[i-j]*j,(i-j)*j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
        <tag>DP</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-机器人的运动范围</title>
    <url>/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第六十三篇。<br>
主要知识点为二维数组的遍历和元素的处理，这个题目和前面的那个矩阵中的路径题目是类似的。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&amp;tqId=11219&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h2 id="解题思路">解题思路</h2>
<p>本题目和矩阵中寻找路径是类似的，<br>
我们可以将这个题目要处理的数据范围抽象成为rows*cols的一个矩阵（或者第一象限），然后从一个结点开始出发，判断其四周的数据是不是合法的，类似于深度优先搜索对每个结点进行遍历。<br>
同样的为了保证访问的数据不会重复，需要通过一个数组来保存每个数据之前是否已经被处理过。<br>
这种处理方式比较经典，要多加锻炼。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int movingCount(int threshold, int rows, int cols)</span><br><span class="line">    &#123;</span><br><span class="line">        if(threshold &lt;= 0 || rows &lt;=0 || cols &lt;= 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bool *flags = new bool[rows*cols];</span><br><span class="line">        for(int i = 0; i &lt; rows * cols; i++)&#123;</span><br><span class="line">             flags[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(threshold,rows,cols,0,0,flags);</span><br><span class="line">    &#125;</span><br><span class="line">    int helper(int threshold,int rows,int cols,int i,int j,bool *flags)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        if(checkToGo(threshold,rows,cols,i,j,flags))&#123;</span><br><span class="line">            flags[i*cols+j] = true;</span><br><span class="line">            res = 1+helper(threshold,rows,cols,i+1,j,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i-1,j,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i,j+1,flags)</span><br><span class="line">                +helper(threshold,rows,cols,i,j-1,flags);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    bool checkToGo(int threshold,int rows,int cols,int i,int j,bool *flags)&#123;</span><br><span class="line">        if(i&gt;=0 &amp;&amp; i&lt;rows &amp;&amp; j&gt;=0 &amp;&amp; j&lt;cols &amp;&amp; checkThreshold(threshold,i,j) &amp;&amp; flags[i*cols+j] == false)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool checkThreshold(int threshold,int i,int j)&#123;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        while(i)&#123;</span><br><span class="line">            temp += i%10;</span><br><span class="line">            i = i/10;</span><br><span class="line">        &#125;</span><br><span class="line">        while(j)&#123;</span><br><span class="line">            temp += j%10;</span><br><span class="line">            j = j/10;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp&lt;=threshold;</span><br><span class="line">    &#125;</span><br><span class="line">    private:</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(cols*rows*lg(max(rows,cols)),空间复杂度为O(cols*rows)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-矩阵中的路径</title>
    <url>/2020/01/27/%E5%89%91%E6%8C%87offer-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第六十二篇。<br>
主要知识点为数组，在矩阵中查找对应的字符串序列，类似于走迷宫或者找包围区间的题目。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&amp;tqId=11218&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h2 id="解题思路">解题思路</h2>
<p>遍历矩阵中的每个结点作为起始结点，然后从这个点开始向四周遍历，寻找字符串的下一个字符，如果字符串匹配到最后的结束标志’\0’,那就返回true,反之就返回false.<br>
需要注意的一点是之前访问过的就不能访问了，所以需要找一个数组或者矩阵来标志这个节点之前是否已经访问过。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPath(char* matrix, int rows, int cols, char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(rows&lt;=0 || cols&lt;=0 || !str || !matrix) return false;</span><br><span class="line">        vector&lt;bool&gt; flags(rows*cols,0);</span><br><span class="line">        for(int i = 0; i &lt; rows; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; cols; j++)&#123;</span><br><span class="line">                if(helper(matrix,rows,cols,i,j,str,flags)) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool helper(char* matrix,int rows,int cols,int i,int j,char* str,vector&lt;bool&gt; flags)&#123;</span><br><span class="line">        if(*str == &apos;\0&apos;) return true;</span><br><span class="line">        if(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; rows &amp;&amp; j &lt; cols &amp;&amp; matrix[i*cols+j] == *str &amp;&amp; flags[i*cols+j] == false)&#123;</span><br><span class="line">            flags[i*cols+j] = true;</span><br><span class="line">            bool find = false;</span><br><span class="line">            find = helper(matrix,rows,cols,i,j+1,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i,j-1,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i+1,j,str+1,flags)</span><br><span class="line">                ||helper(matrix,rows,cols,i-1,j,str+1,flags);</span><br><span class="line">            if(find == false)&#123;</span><br><span class="line">                flags[i*cols+j] = false;</span><br><span class="line">            &#125;</span><br><span class="line">            return find;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(rows*cols*logn),空间复杂度为O(rows*cols)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-滑动窗口的最大值</title>
    <url>/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第六十一篇。<br>
主要知识点为数组，题目看起来很炫酷，但是实际上就是一个给定区间的遍历找最大值而已。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>直接使用stl的max_element方法来获得对应区间的最大值。</p>
<h3 id="思路2">思路2</h3>
<p>朴素算法，自己实现类似于max_element的方法。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">    &#123;</span><br><span class="line">       // 方法1: 直接使用stl中的max_element函数得到对应的窗口</span><br><span class="line">       if(num.size() == 0 || size &lt;=0 ||size&gt;num.size() ) return&#123;&#125;;</span><br><span class="line">       vector&lt;int&gt; res;</span><br><span class="line">       for(int i = 0; i&lt;=num.size()-size; i++)&#123;</span><br><span class="line">            int cur = *max_element(num.begin()+i,num.begin()+i+size);</span><br><span class="line">            res.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">    &#123;</span><br><span class="line">       // 方法2:朴素的方法依次向后比较窗口大小个元素</span><br><span class="line">       if(num.size() == 0 || size &lt;=0 ||size&gt;num.size() ) return&#123;&#125;;</span><br><span class="line">       vector&lt;int&gt; res;</span><br><span class="line">       for(int i = 0; i &lt;= num.size()-size; i++)&#123;</span><br><span class="line">           int temp = num[i];</span><br><span class="line">           for(int j = i+1; j&lt;i+size; j++)&#123;</span><br><span class="line">               if(num[j]&gt;temp)&#123;</span><br><span class="line">                   temp = num[j];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res.push_back(temp);</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-数据流中的中位数</title>
    <url>/2020/01/27/%E5%89%91%E6%8C%87offer-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第六十篇。<br>
主要知识点为数组，依旧是数组遍历然后分析找中位数，比较简单。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="">题目描述</a></h2>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>找一个数组，用来存储所有插入的数据，并保持数组内的数据有序（可以用插入排序的方式）。<br>
在获得中间数的时候，可以通过奇偶直接从数组中获取处理并返回。</p>
<h3 id="思路2">思路2</h3>
<p>在进行插入的时候可以直接使用stl的upper_bound获得对应的插入位置。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Insert(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        mvec.push_back(num);</span><br><span class="line">        len++;</span><br><span class="line">        //sort(mvec.begin(),mvec.end());</span><br><span class="line">        int i = len;</span><br><span class="line">        for( ; i &gt;= 1; i--)&#123;</span><br><span class="line">            if(num&lt;=mvec[i])&#123;</span><br><span class="line">                mvec[i] = mvec[i-1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mvec[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double GetMedian()</span><br><span class="line">    &#123; </span><br><span class="line">        int mindex = (len-1)/2;</span><br><span class="line">        if(len%2 == 0)&#123;</span><br><span class="line">            return ((mvec[mindex]+(double)mvec[mindex+1])/2);  </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (double)mvec[mindex];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; mvec;</span><br><span class="line">    int len = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h2 id="思路2代码">思路2代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MedianFinder &#123;</span><br><span class="line">public:</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void addNum(int num) &#123;</span><br><span class="line">        auto a = upper_bound(mvec.begin(),mvec.end(),num);</span><br><span class="line">        mvec.insert(a, num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    double findMedian() &#123;</span><br><span class="line">        int mid = mvec.size()/2;</span><br><span class="line">        if(mvec.size()%2 == 0)&#123;</span><br><span class="line">            return (double)(mvec[mid]+mvec[mid-1])/2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (double)mvec[mid];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; mvec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="line"> * MedianFinder* obj = new MedianFinder();</span><br><span class="line"> * obj-&gt;addNum(num);</span><br><span class="line"> * double param_2 = obj-&gt;findMedian();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>PS:思路2代码是在leetcode网站剑指offer模块<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41. 数据流中的中位数</a>实现的.</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二叉搜索树的第k个结点</title>
    <url>/2020/01/27/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五十九篇。<br>
主要知识点为二叉搜索树，二叉搜索树由于本身的特性，其中序遍历结果是有序的，<br>
针对这一点，经常有题目出现。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&amp;tqId=11215&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。<br>
例如（5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>中序遍历，将遍历的节点数据保存到一个数组中，然后返回数组的第K个节点即可。</p>
<h3 id="思路2">思路2</h3>
<p>找一个全局计数器表示中序遍历到多少个节点，如果到第K个节点就可以直接返回当前结果了。如果没有到第K个节点，那么就返回NULL。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        if(!pRoot || k&lt;=0) return NULL; </span><br><span class="line">        inorder(pRoot,res);</span><br><span class="line">        if(res.size() &lt; k)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            return res[k-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;TreeNode*&gt; res;</span><br><span class="line">    void inorder(TreeNode* root,vector&lt;TreeNode*&gt;&amp; res)&#123;</span><br><span class="line">        if(!root) return ;</span><br><span class="line">        if(root-&gt;left) inorder(root-&gt;left,res);</span><br><span class="line">        res.push_back(root);</span><br><span class="line">        if(root-&gt;right) inorder(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        if(!pRoot || k&lt;=0) return NULL; </span><br><span class="line">        inorder(pRoot,k);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    TreeNode* res = NULL;</span><br><span class="line">    void inorder(TreeNode* root,int k)&#123;</span><br><span class="line">        if(!root) return ;</span><br><span class="line">        if(root-&gt;left) inorder(root-&gt;left,k);</span><br><span class="line">        count++;</span><br><span class="line">        if(count == k)&#123;</span><br><span class="line">            res = root;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right) inorder(root-&gt;right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinarySearchTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-序列化二叉树</title>
    <url>/2020/01/27/%E5%89%91%E6%8C%87offer-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五十八篇。<br>
主要知识点为二叉树，针对于一棵给定的二叉树进行编码和解码。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=4&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<h2 id="解题思路">解题思路</h2>
<p>首先就是按照正常的先序遍历的思路对原来的二叉树进行存储，用,来隔离每个节点，用#来表示空节点。用递归的思路来进行编码。<br>
解码的时候操作反过来，针对于之前编码生成的字符串，从头到尾依次遍历，通过**,**来对节点进行分离，通过#来判定当前节点为空，通过递归的方式生成之前的二叉树。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char* Serialize(TreeNode *root) &#123;   </span><br><span class="line">        if(!root) return &quot;#&quot;;</span><br><span class="line">        string r = to_string(root-&gt;val);</span><br><span class="line">        r.push_back(&apos;,&apos;);</span><br><span class="line">        char *left = Serialize(root-&gt;left);</span><br><span class="line">        char *right = Serialize(root-&gt;right);</span><br><span class="line">        char *ret = new char[strlen(left) + strlen(right) + r.size()];</span><br><span class="line">        strcpy(ret, r.c_str());</span><br><span class="line">        strcat(ret, left);</span><br><span class="line">        strcat(ret, right);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* Deserialize(char *str) &#123;</span><br><span class="line">        return decode(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    TreeNode* decode(char *&amp;str) &#123;</span><br><span class="line">        if(*str==&apos;#&apos;)&#123;</span><br><span class="line">            str++;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        int num = 0;</span><br><span class="line">        while(*str != &apos;,&apos;)</span><br><span class="line">            num = num*10 + (*(str++)-&apos;0&apos;);</span><br><span class="line">        str++;</span><br><span class="line">        TreeNode *root = new TreeNode(num);</span><br><span class="line">        root-&gt;left = decode(str);</span><br><span class="line">        root-&gt;right = decode(str);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-把二叉树打印成多行</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五十七篇。<br>
主要知识点为二叉树，就是简单的层序遍历而已。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=11213&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h2 id="解题思路">解题思路</h2>
<p>就是简单的层序遍历。<br>
用队列保存每一层的结果，方便遍历下一层，<br>
同时本层的结果放到一个数组中进行存储。<br>
所有层数组的集合就是我们的最终结果。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* root) &#123;</span><br><span class="line">            if(!root) return &#123;&#125;;</span><br><span class="line">            vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">            queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">            while(!q.empty())&#123;</span><br><span class="line">                vector&lt;int&gt; level;</span><br><span class="line">                for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                    auto a = q.front(); q.pop();</span><br><span class="line">                    level.push_back(a-&gt;val);</span><br><span class="line">                    if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                    if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(level);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-按之字形顺序打印二叉树</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五十六篇。<br>
主要知识点为二叉树，就是层序遍历的变形而已。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h2 id="解题思路">解题思路</h2>
<p>层序遍历的思路。<br>
通过队列来保存每一层的节点，方便下一层的遍历,同时本层的结果要放在本层的数组中，<br>
由于要之字形进行保存，也就是说奇数层和偶数层要分别处理，所以要记录层数,用于之后的判断。</p>
<ul>
<li>单数层添加的时候插入到本层数组的后面，实现从左到右依次添加的效果;</li>
<li>双数层添加的时候每次插入到数组的头部，实现类似从右往左添加的效果。</li>
</ul>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        int levelnum = 1;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; level;</span><br><span class="line">            for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                auto a = q.front(); q.pop();</span><br><span class="line">                if(levelnum%2 == 1)&#123;</span><br><span class="line">                   level.push_back(a-&gt;val);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                   level.insert(level.begin(),a-&gt;val);   </span><br><span class="line">                &#125;</span><br><span class="line">                if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">            levelnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-对称的二叉树</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五十五篇。<br>
主要知识点为二叉树，就是简单的判断一棵树是不是对称二叉树。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>
注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h2 id="解题思路">解题思路</h2>
<p>什么时候一棵树是对称的呢？<br>
首先，根节点相同；<br>
其次，如果左右子树都不存在，肯定是对称的；如果左右子树只存在一个，那么肯定是不对称的。<br>
如果左右子树都存在，那么左子树是对称的，右子树也是对称的。<br>
最后，通过辅助函数，递归调用，问题就可以得到解决。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetrical(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        return helper(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    bool helper(TreeNode* root1,TreeNode* root2)&#123;</span><br><span class="line">        if(!root1 &amp;&amp; !root2) return true;</span><br><span class="line">        if(!root1 || !root2) return false;</span><br><span class="line">        if(root1-&gt;val != root2-&gt;val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return helper(root1-&gt;left,root2-&gt;right) &amp;&amp; helper(root1-&gt;right,root2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二叉树的下一个节点</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五十四篇。<br>
主要知识点为二叉树，查找二叉树中序遍历给定节点的下一个节点。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h2 id="解题思路">解题思路</h2>
<p>对于给定的节点，</p>
<ol>
<li>如果存在右子树，那么给定节点中序遍历的下一个节点就是右子树的最左侧节点。</li>
<li>如果不存在右子树，那么就可能存在两种情况，
<ol>
<li>当前节点是根节点的左子树，那么它中序遍历的下一个节点就是它的根节点。</li>
<li>当前节点是根节点的右子树，那么它中序遍历的下一个节点是当前所在左子树的根节点。</li>
</ol>
</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeLinkNode *left;</span><br><span class="line">    struct TreeLinkNode *right;</span><br><span class="line">    struct TreeLinkNode *next;</span><br><span class="line">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeLinkNode* res;</span><br><span class="line">        // 当前节点存在右子树</span><br><span class="line">        if(pNode &amp;&amp; pNode-&gt;right)&#123;</span><br><span class="line">            TreeLinkNode* temp = pNode-&gt;right;</span><br><span class="line">            while(temp-&gt;left)&#123;</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = temp;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">         // 当前节点不存在右子树，</span><br><span class="line">           TreeLinkNode* par = pNode-&gt;next;</span><br><span class="line">           while(pNode-&gt;next &amp;&amp; par-&gt;right == pNode)&#123;</span><br><span class="line">               pNode = pNode-&gt;next;</span><br><span class="line">               par  = pNode-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           res = par;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-删除链表中重复的结点</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五十三篇。<br>
主要知识点为链表的遍历，去除重复元素。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=11209&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>将整个链表进行遍历，通过map来保存每个节点出现的次数。之后再重建链表，链表结点的值仅仅对应于出现一次的元素。返回新链表即可。</p>
<h3 id="思路2">思路2</h3>
<p>可以直接在原来的链表上进行操作，具体的思路如下：<br>
首先在头节点之前建立一个帮助结点，帮助结点之后的就是我们真正的没有重复结点的链表。<br>
然后我们从head结点开始向后遍历，如果碰到有相同元素，那么一直向后遍历，越过这些重复元素。如果元素值没有重复，那么就都向后遍历一个节点。直到遍历结束。</p>
<p>下面以1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5为例进行详细说明，<br>
我们开始创建辅助节点将原来的链表变成-1-&gt;1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5,<br>
然后有两个指针一个指针p指向之前的头节点1，一个指针last指向辅助节点-1，开始遍历。提醒一下，他们两个操作的可是同一个链表。</p>
<ol>
<li>1!=2,所以1不重复，所以p前移指向2，last前移指向1；</li>
<li>2!=3,所以2不重复，所以p前移指向3，last前移指向2；</li>
<li>3==3，所以3是重复的，这个时候p继续前移，直到指向第一个不是3的节点，也就是4，last的next指向4.（这样的话所有的3就已经被删除了）</li>
<li>4==4，所以4也是重复的，这个时候p继续前移，直到指向第一个不是4的节点，也就是5，last的next指向5，(这样的话所有的4就已经被删除了)</li>
<li>5已经没有后继节点了，所有结束。</li>
</ol>
<p>然后整个的链表就变成了-1-&gt;1-&gt;2-&gt;5,最后结果返回-1的next即可。<br>
相比于前一种思路可以极大的提高空间同时提升效率。</p>
<h3 id="扩展">扩展</h3>
<p>本题目的目标是1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5变成1-&gt;2-&gt;5，题目等同于<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">leetcode-83-RemoveDuplicatesfromSortedListII</a><br>
但是也有类似的题目是从1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5变成1-&gt;2-&gt;3-&gt;4-&gt;5。比如<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">leetcode-82-RemoveDuplicatesfromSortedList</a></p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* first = new ListNode(-1);</span><br><span class="line">        first-&gt;next = head;</span><br><span class="line">        ListNode* last = first;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">           if(p-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">               //如果有重复元素，那么就跳过。</span><br><span class="line">               int val = p-&gt;val;</span><br><span class="line">               while(p &amp;&amp; p-&gt;val == val)&#123;</span><br><span class="line">                   p = p-&gt;next;</span><br><span class="line">               &#125;   </span><br><span class="line">               //此时p指向不是之前相等值的第一个元素，但是不能保证这个值也不重复，</span><br><span class="line">               //所以此时继续进入到循环之中进行判断。</span><br><span class="line">               //通过last-&gt;next = p 删除了中间值为val的所有值。</span><br><span class="line">               last-&gt;next = p;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               // 如果不重复，那就直接链接到last上。p继续后移</span><br><span class="line">               last= p;</span><br><span class="line">               p = p-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        return first-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)<br>
还可以这样写，速度会比上面的写法要快一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!pHead) return NULL;</span><br><span class="line">        ListNode* p = pHead;</span><br><span class="line">        ListNode* first = new ListNode(-1);</span><br><span class="line">        first-&gt;next = pHead;</span><br><span class="line">        ListNode* tail = first;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            if((p-&gt;next &amp;&amp; p-&gt;val != p-&gt;next-&gt;val) || !p-&gt;next)&#123;</span><br><span class="line">                tail = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                int a  = p-&gt;val;</span><br><span class="line">                while(p &amp;&amp; p-&gt;val == a)&#123;</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;next = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="扩展代码">扩展代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        // 去掉重复元素,重复元素保留一次</span><br><span class="line">        if(!head) return NULL;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p &amp;&amp; p-&gt;next)&#123;</span><br><span class="line">            if(p-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-链表中环的入口节点</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五十二篇。<br>
主要知识点为链表的遍历，同样的使用一个set就可以解决问题。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h2 id="解题思路">解题思路</h2>
<p>思路非常清晰，从头开始遍历，遍历的时候先判断当前节点是否在set中，如果已经在，那么这个节点肯定就是那个入口节点。如果不在，继续向后遍历。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;ListNode*&gt; mset;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            if(mset.count(p)) return p;</span><br><span class="line">            mset.insert(p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-字符流中第一个不重复的字符</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五十一篇。<br>
主要知识点为字符串中每个字符的出现次数，同样的题目其实已经出现很多次了，相信大家都已经可以做到手到擒来了。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&amp;tqId=11207&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。<br>
输出描述:<br>
如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<h2 id="解题思路">解题思路</h2>
<p>对于插入的每个字符都进行一次保存，然后对于每个字符出现的次数都可以通过map来保存出现次数，最后遍历一遍map找到第一个出现次数为1的字符就可以了。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string s = &quot;&quot;;</span><br><span class="line">    map&lt;char,int&gt; mmap;</span><br><span class="line">  //Insert one char from stringstream</span><br><span class="line">    void Insert(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">       s += ch;</span><br><span class="line">       if(mmap[ch])&#123;</span><br><span class="line">           mmap[ch]++;</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           mmap[ch] = 1;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //return the first appearence once char in current stringstream</span><br><span class="line">    char FirstAppearingOnce()</span><br><span class="line">    &#123;</span><br><span class="line">        for(char a:s)&#123;</span><br><span class="line">            if(mmap[a] == 1)</span><br><span class="line">               return a;</span><br><span class="line">        &#125;</span><br><span class="line">        return &apos;#&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-表示数值的字符串</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五十篇。<br>
主要知识点为字符串，重点在于细心，认真的去判断成为数值的条件，然后再去做题就比较快。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&amp;tqId=11206&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,“5e2”,“-123”,“3.1416&quot;和”-1E-16&quot;都表示数值。 但是&quot;12e&quot;,“1a3.14”,“1.2.3”,&quot;±5&quot;和&quot;12e+4.3&quot;都不是。</p>
<h2 id="解题思路">解题思路</h2>
<p>这个题目主要要考虑以下的问题</p>
<ol>
<li>小数点，正负号，指数标志可能会出现多次的问题。解决方式是设置一个标志，用来记录它们之前是否已经出现。</li>
<li>直接以小数点或者指数标志或者正负号结尾：解决方式在每个条件结束的时候进行一次是否到结尾的判断</li>
<li>string以‘\0’为标志结束。可以用来结束循环。</li>
<li>非法字符的问题。 对于前面没有处理的其他的非法情况都直接返回false</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumeric(char* string)</span><br><span class="line">    &#123;</span><br><span class="line">        if(string == NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 应对仅仅只有+或者-的情况</span><br><span class="line">        if(*string == &apos;+&apos; || *string == &apos;-&apos;)&#123;</span><br><span class="line">            string++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //标记小数点、整数部分、指数部分是否存在，</span><br><span class="line">        bool point = false, numint = false, nume = false;</span><br><span class="line">        while(*string != &apos;\0&apos;)&#123;</span><br><span class="line">            //处理小数</span><br><span class="line">            if(*string == &apos;.&apos;)&#123;</span><br><span class="line">                if( point || nume) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                string++;</span><br><span class="line">                point = true;</span><br><span class="line">                if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //处理科学计数法</span><br><span class="line">            else if(*string == &apos;E&apos; || *string == &apos;e&apos;)&#123;</span><br><span class="line">                if(numint == false || nume)&#123;</span><br><span class="line">                     return false;</span><br><span class="line">                &#125;</span><br><span class="line">                string++; </span><br><span class="line">                nume = true;</span><br><span class="line">                if(*string == &apos;+&apos; || *string == &apos;-&apos;)&#123;</span><br><span class="line">                    string++;</span><br><span class="line">                &#125;</span><br><span class="line">                if(*string == &apos;\0&apos;)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //处理正常数据</span><br><span class="line">            else if(*string &gt;= &apos;0&apos; &amp;&amp; *string &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                numint = true;</span><br><span class="line">                string++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-正则表达式匹配</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四十九篇。<br>
这个题目比较难，甚至我觉得是整个剑指offer里面最难的一道题目了，<br>
也是参考了网上的答案加上自己的理解来解决这道题目，no more talk, show you code!</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>请实现一个函数用来匹配包括’.‘和’<em>‘的正则表达式。模式中的字符’.‘表示任意一个字符，而’</em>'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab<em>ac</em>a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配</p>
<h2 id="解题思路">解题思路</h2>
<p>本题目其实关注的点比较多，下面一个一个来说</p>
<ol>
<li>匹配串或者模式串为空的情况</li>
<li>字符串是以’\0’为标志结束的</li>
<li>**.**的处理，可以表示任何一个字符,要注意此时匹配串是不是已经到了结尾</li>
<li><em>号的处理，由于</em>可以表示它前面的字符出现0次，1次，甚至多次，所以这个时候就会让模式串和匹配串进行不同的后续的比较。</li>
</ol>
<p>代码里面的注释写的非常清楚了，所以直接看代码吧。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool match(char* str, char* pattern)</span><br><span class="line">    &#123;</span><br><span class="line">        // 两者任意一个为空，则返回空。</span><br><span class="line">        if(str == NULL || pattern == NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return matchCore(str, pattern);</span><br><span class="line">     &#125;</span><br><span class="line">    //本部分以str = aaa 为例进行说明。</span><br><span class="line">    bool matchCore(char* str, char* pattern)&#123;</span><br><span class="line">        // 字符串和模式串都运行到了结尾，则匹配完成。返回true</span><br><span class="line">        if(*str == &apos;\0&apos; &amp;&amp; *pattern == &apos;\0&apos;)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 字符串没有到结尾，模式串到结尾了，则返回false</span><br><span class="line">        // 模式串没有到结尾，字符串到结尾了，则根据后续判断进行，需要对&apos;*&apos;做处理</span><br><span class="line">        if((*str != &apos;\0&apos; &amp;&amp; *pattern == &apos;\0&apos;))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果模式串的下一个字符是&apos;*&apos;，</span><br><span class="line">        if(*(pattern + 1) == &apos;*&apos;)&#123;</span><br><span class="line">            // 如果字符串和模式串相等，或者模式串是&apos;.&apos;，并且字符串没有到结尾，则继续匹配</span><br><span class="line">            if(*str == *pattern || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;))&#123;</span><br><span class="line">                // 可能存在三种情况。</span><br><span class="line">                // 1. *匹配前面字符0次， 如pattern = a*aaa</span><br><span class="line">                // 2. *匹配前面字符1次， 如pattern = a*aa</span><br><span class="line">                // 3. *匹配前面字符不止一次，如pattern = a*</span><br><span class="line">                return    // *匹配0次</span><br><span class="line">                    matchCore(str, pattern + 2)|| </span><br><span class="line">                          // *匹配1次</span><br><span class="line">                    matchCore(str + 1, pattern + 2) ||</span><br><span class="line">                          // *匹配不止1次</span><br><span class="line">                    matchCore(str + 1, pattern);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果字符串和模式串不相等，则跳过当前模式串的字符和&apos;*&apos;，进入新一轮的匹配</span><br><span class="line">            else&#123;</span><br><span class="line">                // 比如pattern = b*aaa</span><br><span class="line">                return matchCore(str, pattern + 2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果字符串和模式串相等，或者模式串是&apos;.&apos;，并且字符串没有到结尾，则继续匹配</span><br><span class="line">        if(*str == *pattern || (*pattern == &apos;.&apos; &amp;&amp; *str != &apos;\0&apos;))&#123;</span><br><span class="line">            return matchCore(str + 1, pattern + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>Codinginterviews</tag>
        <tag>正则表达</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-构建乘积数组</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四十八篇。<br>
主要知识点为数组，但是可以通过类似于矩阵的方式来进行性能的提升。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;tqId=11204&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…*A[i-1]<em>A[i+1]</em>…*A[n-1]。不能使用除法。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>暴力求解，双层循环，对每个结果进行单独的计算即可。</p>
<h3 id="思路2">思路2</h3>
<p>其实我们在计算的时候可以发现很多计算是重复的，举例来说<br>
1, 2, 3, 4, 5<br>
计算第一个数字的时候是2*3*4*5,<br>
计算第二个数字的时候是1*3*4*5,<br>
计算第三个数字的时候是1*2*4*5,<br>
计算第四个数字的时候是1*2*3*5,<br>
计算第五个数字的时候是1*2*3*4。<br>
这样就可以发现很多运算是重复的，比如第一行的3<em>4</em>5和第二行的3<em>4</em>5，<br>
如何去掉重复的计算呢？就是我们接下来要考虑的问题。<br>
同样以1, 2, 3, 4, 5为例来进行说明，我们可以发现同一行的计算可以分成左右两个部分。<br>
计算第一个数字的时候是(1)*(2*3*4*5),<br>
计算第二个数字的时候是(1*1)*(3*4*5),<br>
计算第三个数字的时候是(1*2*1)*(4*5),<br>
计算第四个数字的时候是(1*2*3*1)*(5),<br>
计算第五个数字的时候是(1*2*3*4*1)()。<br>
左面括号中下一行的数字是上一行的数字再乘上一个数字，<br>
右面括号中上一行的数字是下一行的数组再乘上一个数字。<br>
而最终的结果就是左边的括号乘上右面的括号。<br>
非常优秀的思路。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        //  方法1: 双层遍历 O(n^2)</span><br><span class="line">        vector&lt;int&gt; res ;</span><br><span class="line">        int temp = 1;</span><br><span class="line">        for(int i  = 0;i&lt; A.size();i++)&#123;</span><br><span class="line">            for(int j = 0; j&lt; A.size(); j++)&#123;</span><br><span class="line">                if(i != j)&#123;</span><br><span class="line">                   temp = A[j] *temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            temp = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        //  方法2: 巧妙运用一下前一次和后一次的关系</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        vector&lt;int&gt; left = &#123;1&#125;;</span><br><span class="line">        vector&lt;int&gt; right = &#123;1&#125;;</span><br><span class="line">        for(int i = 1; i &lt;= A.size()-1; i++)&#123;</span><br><span class="line">            left.push_back(left.back()* A[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for( int i = A.size()-2; i&gt;=0;i--)&#123;</span><br><span class="line">            right.insert(right.begin(),right.front()*A[i+1]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i&lt;A.size();i++)&#123;</span><br><span class="line">            res.push_back(left[i] * right[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-数组中重复的数字</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四十七篇。<br>
主要知识点为数组，找数组中重复的数字，类似于之前找出现一次或者两次的数字。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h2 id="解题思路">解题思路</h2>
<p>找个set来存一下之前出现过的数据，然后在新遍历到数据的时候只要先看一下set中有没有存在，若存在，则直接返回即可，若不存在，将这个数据放到set中，继续向后遍历。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // Parameters:</span><br><span class="line">    //        numbers:     an array of integers</span><br><span class="line">    //        length:      the length of array numbers</span><br><span class="line">    //        duplication: (Output) the duplicated number in the array number</span><br><span class="line">    // Return value:       true if the input is valid, and there are some duplications in the array number</span><br><span class="line">    //                     otherwise false</span><br><span class="line">    bool duplicate(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; mset;</span><br><span class="line">        for(int i = 0; i&lt;length; i++)&#123;</span><br><span class="line">            if(!mset.count(numbers[i]))&#123;</span><br><span class="line">                mset.insert(numbers[i]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-把字符串转化成整数</title>
    <url>/2020/01/26/%E5%89%91%E6%8C%87offer-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四十六篇。<br>
主要知识点为字符串的判断和边界条件的判定，细心一点就没有问题。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&amp;tqId=11202&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br>
输入描述:<br>
输入一个字符串,包括数字字母符号,可以为空<br>
输出描述:<br>
如果是合法的数值表达则返回该数字，否则返回0</p>
<h2 id="解题思路">解题思路</h2>
<p>本题目需要考虑的边界有以下几个：</p>
<ol>
<li>正负号的判定</li>
<li>数字中间可能有非法字符</li>
<li>数字结果可能会超出INT类型的范围。<br>
考虑好以上几个边界本题目就可以得到解决。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int StrToInt(string str) &#123;</span><br><span class="line">       if(str.size() == 0) return 0;</span><br><span class="line">       int flag  = 0; //默认正数</span><br><span class="line">       if(str[0] == &apos;+&apos;)&#123;</span><br><span class="line">           flag = 1;</span><br><span class="line">       &#125;else if(str[0] == &apos;-&apos;)&#123;</span><br><span class="line">           flag = 2;</span><br><span class="line">       &#125;</span><br><span class="line">       int start = flag&gt;0?1:0;</span><br><span class="line">       long res = 0;</span><br><span class="line">       while(start &lt; str.size())&#123;</span><br><span class="line">           if(str[start]&gt;&apos;0&apos; &amp;&amp; str[start] &lt;&apos;9&apos;)&#123;</span><br><span class="line">               res = res*10 + (str[start]-&apos;0&apos;);</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           start++;</span><br><span class="line">       &#125;</span><br><span class="line">       res = (flag == 2)?(-res):res;</span><br><span class="line">       //判断是否出现溢出</span><br><span class="line">       if(res &gt;INT_MAX || res &lt; INT_MIN)&#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-不用加减乘除做加法</title>
    <url>/2020/01/25/%E5%89%91%E6%8C%87offer-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四十五篇。<br>
主要知识点为位运算，思路非常神奇，可以打破我们的思维定势。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="">题目描述</a></h2>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<h2 id="解题思路">解题思路</h2>
<p>当我们计算两个数字之和的时候，实际上一方面我们计算两个数当前位的加法运算，另一方面是计算当前位的进位运算，本题目我们采用同样的思路来对二进制进行计算，当前位的计算用位的异或操作，具体操作为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1^1 = 0; 1^0 = 1; 0^1 = 1; 0^0 = 0;</span><br></pre></td></tr></table></figure>
<p>而进位运算通过位的与运算来进行计算，具体操作为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&amp;1 = 1; 1&amp;0 = 0; 0&amp;1 = 0; 0&amp;0 = 0;</span><br></pre></td></tr></table></figure>
<p>下面我们举例来进行说明：<br>
比如2+4变成二进制为010和100，<br>
这样直接通过位的异或计算当前位就是110，而进位计算010&amp;100 = 0，<br>
所以最终计算结果的二进制就是110，也就是6；</p>
<p>比如2+6，它们的二进制分别为010和110，<br>
计算当前位为010^110= 100,计算进位010&amp;110=010。<br>
由于是进的位，所以在进行下一步计算的时候，进位结果要左移一位之后再来和之前的计算结果进行计算，<br>
所以当前位运算结果变为100^100 = 000,进位结果变为100&amp;100 = 100，<br>
进位结果继续左移1位得到1000，和原来当前位数字000进行异或计算得到0000^1000=1000，而进位0000&amp;1000 = 0，运算结束。<br>
所以最后结果就是1000也就是8。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Add(int num1, int num2)</span><br><span class="line">    &#123;</span><br><span class="line">        //return num1+num2;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        while(num2 != 0)&#123;</span><br><span class="line">            temp = num1^num2;</span><br><span class="line">            num2 = (num1&amp;num2)&lt;&lt;1;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-扑克牌顺子</title>
    <url>/2020/01/25/%E5%89%91%E6%8C%87offer-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四十四篇。<br>
没有用到啥比较厉害的算法，主要还是学习一下思路,有思路事情就变得的非常简单啦。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<h2 id="解题思路">解题思路</h2>
<p>由于大小王可以替代任何牌，所以我们对这次要单独处理。<br>
然后我们找到抽到的排面中最小且不为0的数字，<br>
然后开始依次找其他四个比它大且构成顺子的四张牌。如果有对应的牌，那么就继续判断下一张；<br>
如果没有对应的牌，但是有0，就意味着可以用小王来替换对应的牌，然后继续判断下一张；<br>
如果既没有对应的牌，然后也没有大小王可以用来替换，那么肯定就不能构成顺子，就直接返回false即可。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">        int zeros = count(numbers.begin(),numbers.end(),0);</span><br><span class="line">        int mmin = INT_MAX;</span><br><span class="line">        for(int i:numbers)&#123;</span><br><span class="line">            if(i != 0 &amp;&amp; i&lt;mmin)&#123;</span><br><span class="line">                mmin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i&lt;5;i++)&#123;</span><br><span class="line">            if(count(numbers.begin(),numbers.end(),mmin+i))&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;else if(zeros &gt; 0)&#123;</span><br><span class="line">                zeros--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-反转单词序列</title>
    <url>/2020/01/24/%E5%89%91%E6%8C%87offer-%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四十三篇。<br>
主要知识点依旧是字符串,注意观察题目规律，细心一点就行，也比较简单。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="">题目描述</a></h2>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么</p>
<h2 id="解题思路">解题思路</h2>
<p>观察题目我们就可以发现，其实每个单词内部的字母都是正序的，然后每个单词都是用空格隔开的，然后单词的顺序是逆序的，所以我们很自然的就可以想到每次按照顺序读取一个单词，然后单词之间按照逆序进行拼接即可。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string ReverseSentence(string str) &#123;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        string temp = &quot;&quot;;</span><br><span class="line">        for(char a:str)&#123;</span><br><span class="line">            if(a != &apos; &apos;)&#123;</span><br><span class="line">                temp.push_back(a);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res = temp+&quot; &quot;+res;</span><br><span class="line">                temp = &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = temp+&quot; &quot;+res;</span><br><span class="line">        return res.substr(0,res.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-左旋转字符串</title>
    <url>/2020/01/24/%E5%89%91%E6%8C%87offer-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四十二篇。<br>
主要知识点为字符串，非常简单，都没啥值得说的。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h2 id="解题思路">解题思路</h2>
<p>这里其实有三种情况需要考虑，</p>
<ol>
<li>K等于字符串的长度： 这个时候可以直接返回原来的字符串。</li>
<li>K小于字符串的长度： 这个时候相当于对于原来的字符串进行截取，一段是前面K位，一段是剩下的。然后左右置换重新拼接即可。</li>
<li>K大于字符串的长度： 这个时候实际上相当于已经左移一圈了，继续左移实际上最后效果相当于左移<br>
K = K % len.<br>
然后该情况就变成了第二种情况。</li>
</ol>
<p>本题目给的测试用例不是很好，或者说题目意思说的不明确，当循环左移到头之后怎么办呢？是直接返回，还是按照循环左移这个名字来真的循环呢？两种理解都可以过所有样例,感觉题目出的非常不好。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string LeftRotateString(string str, int n) &#123;</span><br><span class="line">        int slen = str.size();</span><br><span class="line">        if(slen == 0) return str;</span><br><span class="line">        //if(slen &lt; n) return str; // 如果左移位数超过字符串长度，直接返回，也可以过测试用例。</span><br><span class="line">        int realn = n%slen;</span><br><span class="line">        string head = str.substr(0,realn);</span><br><span class="line">        string tail = str.substr(realn);</span><br><span class="line">        return tail+head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-和为S的两个数字</title>
    <url>/2020/01/24/%E5%89%91%E6%8C%87offer-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四十一篇。<br>
主要知识点为数组的遍历，找个set存一下想要的元素有没有存在即可，比较简单。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>可以通过两层循环来解决。但是时间复杂度是O(n^2)。或者这里是有序的，可以在内层循环用二分查找，那么时间复杂度将会变为O(nlgn)。</p>
<h3 id="思路2">思路2</h3>
<p>使用set来保存所有元素，然后重新遍历一遍数组，查找是否存在和当前数值的和为S的数字。<br>
如果有多对数字的和等于S，输出两个数的乘积最小的，这个有一个类似于贪心的操作就是如果和一定，那么两个值越接近，那么乘积越大，对应的，我们要求找乘积最小的，所以只要从最小值开始遍历即可。<br>
这里扩展一下，之前在leetcode上还有一道题目同样是找两个和为S的数字，但是那个题目要求返回的是两个值的索引，那个地方要用map,对应的key和value分别是值和索引。而本题目中只要求返回两个值即可，所以只要用set来确认有没有对应元素存在即可。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; mset;</span><br><span class="line">        for(auto a:array)&#123;</span><br><span class="line">            mset.insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto a:array)&#123;</span><br><span class="line">            if(mset.count(sum-a))&#123;</span><br><span class="line">                return &#123;a,sum-a&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-和为S的连续正数序列</title>
    <url>/2020/01/24/%E5%89%91%E6%8C%87offer-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四十篇。<br>
主要知识点为双指针，通过双指针来定位符合条件的正数序列，从而解决整个问题。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;tPage=3&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<p>输出描述：<br>
输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<h2 id="解题思路">解题思路</h2>
<p>通过双指针来存储可能符合要求的正数序列。</p>
<ol>
<li>当指针范围正数序列大于要求值，当前序列和要减去当前左指针所指的值，然后左指针右移。</li>
<li>当指针范围正数序列小于要求值，则右指针右移，当前序列和要加上当前右指针所指的值。</li>
<li>如果等于要求值S,则判断是否符合序列的条件，如果符合，则加入结果中，如果不符合，则继续判断。直到到达边界。<br>
如果引申一下，这个题目也可以用在解决有序数组中找和为S的正数序列。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int l = 1,r = 1,tsum = 1;</span><br><span class="line">        while(l &lt;= r)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            tsum += r;</span><br><span class="line">            while(tsum &gt; sum)&#123;</span><br><span class="line">                tsum -= l;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(tsum == sum &amp;&amp; l != r)&#123;</span><br><span class="line">                vector&lt;int&gt; temp ;</span><br><span class="line">                for(int i = l;i&lt;=r;i++) temp.push_back(i);</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-数组中只出现一次的数字</title>
    <url>/2020/01/23/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三十九篇。<br>
主要知识点为数组的遍历。有两个只出现一次的数字，找出它们。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&amp;tqId=11193&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h2 id="解题思路">解题思路</h2>
<p>找一个map来存储每个数字以及他们出现的次数。<br>
遍历整个map，找到那两个出现次数为1的数字即可。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; mmap;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        for(auto a:data)&#123;</span><br><span class="line">            mmap[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto a:mmap)&#123;</span><br><span class="line">            if(a.second == 1)&#123;</span><br><span class="line">                res.push_back(a.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *num1 = res[0];</span><br><span class="line">        *num2 = res[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-平衡二叉树</title>
    <url>/2020/01/23/%E5%89%91%E6%8C%87offer-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三十八篇。<br>
主要知识点为平衡二叉树,也就是判断一棵树的左右子树的高度差是否大于1。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<h2 id="解题思路">解题思路</h2>
<p>我们上一篇写过一个方法用来求一棵树的深度，<br>
那么本题目就可以利用上面的那个方法来进行计算左右子树的深度，然后判断其高度差是否大于1。<br>
如果大于1，则返回false,否则继续判断其子树是否为平衡二叉树。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Depth(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        else return max(Depth(root-&gt;left),Depth(root-&gt;right))+1;</span><br><span class="line">    &#125;</span><br><span class="line">    bool IsBalanced_Solution(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        if(abs(Depth(root-&gt;left)-Depth(root-&gt;right))&gt;1)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return IsBalanced_Solution(root-&gt;left)&amp;&amp;IsBalanced_Solution(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(n^2)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>AVLTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二叉树的深度</title>
    <url>/2020/01/23/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三十七篇。<br>
主要知识点为二叉树，可以用递归或层序遍历两种方式来解决这个问题。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>由于树结构的特殊性，天然的可以利用递归来解决这一类的问题。</p>
<h3 id="思路2">思路2</h3>
<p>可以使用层序遍历来解决这个问题。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int TreeDepth(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        // 方法一 ：递归求解</span><br><span class="line">        if(!pRoot) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">         return max(TreeDepth(pRoot-&gt;left),TreeDepth(pRoot-&gt;right))+1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int TreeDepth(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        // 方法二： 队列层序遍历</span><br><span class="line">        if(!pRoot) return 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;pRoot&#125;&#125;;</span><br><span class="line">        int dep = 0;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                TreeNode* a = q.front(); q.pop();</span><br><span class="line">                if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            dep++;</span><br><span class="line">        &#125;</span><br><span class="line">        return dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-数字在排序数组中出现的次数</title>
    <url>/2020/01/23/%E5%89%91%E6%8C%87offer-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三十六篇。<br>
主要知识点为二分查找,但是可以偷懒用stl来解决掉。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tqId=11190&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>统计一个数字在排序数组中出现的次数。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>直接使用stl的count方法</p>
<h3 id="思路2">思路2</h3>
<p>先使用stl的find方法找到第一个值，然后向后遍历计数</p>
<h3 id="思路3">思路3</h3>
<p>利用二分查找，先找到第一个大于这个val的索引，然后找到小于这个val的最大的索引，做差然后减去1就是这个值出现的次数。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">        // 方法1 使用stl的count</span><br><span class="line">        return count(data.begin(),data.end(),k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(logn),空间复杂度为O(1)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line"></span><br><span class="line">        //方法2  使用stl的find</span><br><span class="line">        auto a = find(data.begin(),data.end(),k);</span><br><span class="line">        if(a == data.end())&#123;</span><br><span class="line">         return 0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          int res = 0;</span><br><span class="line">           while(*a == k)&#123;</span><br><span class="line">               res++; a++;</span><br><span class="line">           &#125;</span><br><span class="line">           return res; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(logn),空间复杂度为O(1)</p>
<h3 id="思路3代码">思路3代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 暂时还没有写好，等我写好再来补充。</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Codinginterviews</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-数组中的逆序对</title>
    <url>/2020/01/23/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三十五篇。<br>
在数组中寻找逆序对是归并排序的一个非常典型的应用。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>设置一个计数器，双层for循环，碰到逆序对则计数器+1，最后返回结果即可。</p>
<h3 id="思路2">思路2</h3>
<p>利用数据交换的排序方法来变相计算逆序对的数目。这里采用的是冒泡排序。</p>
<h3 id="思路3">思路3</h3>
<p>基于归并排序来进行计数。关于归并排序大家可以查具体的算法书的介绍。<br>
这里我说一下为什么归并排序相比较于思路1和思路2要好的多。<br>
我们知道归并排序首先是将数据进行分块，直到分到每个小块只有一个元素，然后将小块合并有序的大块。合并的时候采用有序链表合并的方法进行合并，针对于本问题而言，也就是在合并的时候进行逆序对的计算。<br>
下面举例说明一下。比如我们合并的某一步骤，分别得到A = {3,5,6}和 B = {1,2,8}两个序列。<br>
在合并的时候我们对两个数组进行从头的遍历进行合并，合并结果按照从小到大进行排列。</p>
<ol>
<li>首先由于A中的3是要大于B中的1的，有序序列为{1},因为A中元素是升序的，A的第一个元素就大于1，所以A中所有的数据都是大于1的，从而仅仅是和1比较的时候就有3个逆序对，这样就可以直接通过A的前后索引计算出来，而不是一一比较再得到。</li>
<li>然后比较A中的3和B中的2.更新有序序列为{1,2}，此时针对于B可以得到逆序对有3个。</li>
<li>然后比较A中的3和B中的8.更新有序序列为{1,2,3},此时没有新的逆序对增加</li>
<li>然后比较A中的5和B中的8，更新有序序列为{1,2,3,5}，此时没有新的逆序对增加</li>
<li>然后比较A中的6和B中的8，更新有序序列为{1,2,3,5,6},此时没有新的逆序对增加</li>
<li>由于A已经遍历完成，将B中剩余元素添加到有序序列中即可。也就得到{1,2,3,5,6,8}。</li>
<li>最后得到上面两个序列的逆序对有6个。<br>
对于其他的有序数组也采用类似的方式进行逆序对的计算。从而解决这个问题。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">        // 方法1 双层for循环</span><br><span class="line">        long res = 0;</span><br><span class="line">        for(int i = 0;i&lt;data.size();i++)&#123;</span><br><span class="line">            for(int j = i+1;j&lt;data.size();j++)&#123;</span><br><span class="line">               if(data[i]&gt;data[j]) res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res%1000000007;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(1)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">        //方法2: 冒泡排序 O(n^2) 通过率为50% </span><br><span class="line">        if(data.size() == 0) return 0;</span><br><span class="line">        return helperByBubbleSort(data);  </span><br><span class="line">    &#125;</span><br><span class="line">    // 方法2的辅助函数</span><br><span class="line">    int helperByBubbleSort(vector&lt;int&gt; data)&#123;</span><br><span class="line">        long res = 0;</span><br><span class="line">        bool notfinish = true;</span><br><span class="line">        int len = data.size();</span><br><span class="line">        for(int i = 0; i &lt; len-1 &amp;&amp; notfinish; i++)&#123;</span><br><span class="line">            notfinish = false;</span><br><span class="line">            for(int j = 0; j &lt; len-i-1; j++)&#123;</span><br><span class="line">                if(data[j] &gt; data[j+1])&#123;</span><br><span class="line">                    swap(data[j],data[j+1]);</span><br><span class="line">                    notfinish = true;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res%1000000007;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度最坏的情况为O(n^2),最好的情况为O(n),空间复杂度为O(1)</p>
<h3 id="思路3代码">思路3代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">        //方法3: 归并排序</span><br><span class="line">        if(data.size() == 0) return 0;</span><br><span class="line">        return helperByMergeSort(data,0,data.size()-1)%1000000007;</span><br><span class="line">    &#125;</span><br><span class="line">    // 方法3的辅助函数</span><br><span class="line">    int helperByMergeSort(vector&lt;int&gt;&amp; data,int start,int end)&#123;</span><br><span class="line">        if(start == end) return 0;</span><br><span class="line">        int mid = start+((end-start)&gt;&gt;1);</span><br><span class="line">        int left = helperByMergeSort(data,start,mid);</span><br><span class="line">        int right = helperByMergeSort(data,mid+1,end);</span><br><span class="line">        vector&lt;int&gt; temp(end-start+1,0);</span><br><span class="line">        int i = start, j = mid+1, count = 0, index = 0;</span><br><span class="line">        while(i &lt;= mid &amp;&amp; j&lt;=end)&#123;</span><br><span class="line">            if(data[i] &gt; data[j])&#123;</span><br><span class="line">                count = (count + mid - i + 1)%1000000007;</span><br><span class="line">                temp[index++] = data[j++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp[index++]= data[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果存在一部分没有取完</span><br><span class="line">        while(i&lt;=mid)&#123;</span><br><span class="line">            temp[index++] = data[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&lt;=end)&#123;</span><br><span class="line">            temp[index++] = data[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        //把排好序的结果放回原数组中</span><br><span class="line">        for(int i = start; i&lt;= end; i++)&#123;</span><br><span class="line">            data[i] = temp[i-start];</span><br><span class="line">        &#125;</span><br><span class="line">        return (count+left+right)%1000000007;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(nlogn),空间复杂度为O(n)</p>
<h2 id="参考">参考</h2>
<p>1.<a href="https://juejin.im/post/5b6cfb746fb9a04fae213694" target="_blank" rel="noopener">剑指Offer-37-数组中逆序对</a><br>
2. <a href="https://cuijiahua.com/blog/2018/01/basis_35.html" target="_blank" rel="noopener">剑指Offer（三十五）：数组中的逆序对</a><br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-两个链表的第一个公共结点</title>
    <url>/2020/01/22/%E5%89%91%E6%8C%87offer-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三十四篇。<br>
主要知识点为链表，找两个链表的第一个公共结点,用个set,非常简单。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入两个链表，找出它们的第一个公共结点。</p>
<h2 id="解题思路">解题思路</h2>
<p>遍历一个链表，然后将所有节点存到set中，然后依次遍历另一个链表，在set中查看是否有这个节点，如果有，就返回这个节点。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">            val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">        set&lt;ListNode*&gt; mset;</span><br><span class="line">        ListNode* p = pHead1;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            mset.insert(p);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* q = pHead2;</span><br><span class="line">        while(q)&#123;</span><br><span class="line">            if(mset.count(q)) return q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-第一个只出现一次的字符</title>
    <url>/2020/01/22/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三十三篇。<br>
主要知识点为字符串，找个map来存一下出现次数，很简单。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&amp;tqId=11187&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
<h2 id="解题思路">解题思路</h2>
<p>构造一个map,对于字符串中的每个字符匹配一个对应的出现次数。然后遍历整个map,返回第一个出现次数为1的字符。<br>
或者再从头到尾遍历字符串，查找map中对应字符出现的次数，返回第一个出现次数为1的字符。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FirstNotRepeatingChar(string str) &#123;</span><br><span class="line">        if(str.size() == 0) return -1;</span><br><span class="line">        unordered_map&lt;char,int&gt; mmap;</span><br><span class="line">        for(int i = 0;i&lt;str.size();i++)&#123;</span><br><span class="line">            if(mmap.count(str[i]))&#123;</span><br><span class="line">               mmap[str[i]] += 10000;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">               mmap[str[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = INT_MAX;</span><br><span class="line">        for(auto a:mmap)&#123;</span><br><span class="line">            res = res&gt;a.second?a.second:res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Map</tag>
        <tag>Codinginterviews</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-丑数</title>
    <url>/2020/01/22/%E5%89%91%E6%8C%87offer-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三十二篇。<br>
主要知识点为枚举。两种解题方法：一种是暴力枚举，一种是比较优美的枚举。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&amp;tqId=11186&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>从1开始计数，依次的判断每个数字是不是丑数，给丑数建立一个计数器，如果计数器为N,则返回这个结果。</p>
<h3 id="思路2">思路2</h3>
<p>因为丑数的质因子只有2.3.5三个数字，那么我们依次的去找他们之间乘积的最小值即可（可能每次每个数字乘的次数不一样，但是依旧是找最小的）。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        int count = 1;</span><br><span class="line">        int temp = 1;</span><br><span class="line">        while(count &lt; index)&#123;</span><br><span class="line">            if(isUglyNumber(++temp))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isUglyNumber(int num)&#123;</span><br><span class="line">        while(num%5 == 0)&#123;</span><br><span class="line">            num /= 5;</span><br><span class="line">        &#125;</span><br><span class="line">        while(num%3 == 0)&#123;</span><br><span class="line">            num /= 3;</span><br><span class="line">        &#125;</span><br><span class="line">        while(num%2 == 0)&#123;</span><br><span class="line">            num /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return num == 1?true:false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlgn),空间复杂度为O(1)，非常意料之内的在牛客上超时了。</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        vector&lt;int&gt; res =&#123;1&#125;;</span><br><span class="line">        int p2 = 0,p3 = 0,p5 = 0;</span><br><span class="line">        int  temp  = 0;</span><br><span class="line">        for(int i = 1;i&lt;index;i++)&#123;</span><br><span class="line">            temp = min(res[p2]*2,min(res[p5]*5,res[p3]*3));</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            if(temp == res[p2]*2) p2++;</span><br><span class="line">            if(temp == res[p3]*3) p3++;</span><br><span class="line">            if(temp == res[p5]*5) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[index-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h2 id="思路1测试代码">思路1测试代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*test.cpp*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool isUglyNumber(int num)&#123;</span><br><span class="line">    while(num%5 == 0)&#123;</span><br><span class="line">        num /= 5;</span><br><span class="line">    &#125;</span><br><span class="line">    while(num%3 == 0)&#123;</span><br><span class="line">        num /= 3;</span><br><span class="line">    &#125;</span><br><span class="line">    while(num%2 == 0)&#123;</span><br><span class="line">        num /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return num == 1?true:false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">    int count = 1;</span><br><span class="line">    int temp = 1;</span><br><span class="line">    while(count &lt; index)&#123;</span><br><span class="line">        if(isUglyNumber(++temp))&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cout&lt;&lt; GetUglyNumber_Solution(1400)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的时候</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test</span><br><span class="line">./test</span><br></pre></td></tr></table></figure>
<p>结果是516560652.答案正确。<br>
除了运算的慢点，所需要的时间长点，其他没啥毛病。<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-把数组排成最小的数</title>
    <url>/2020/01/22/%E5%89%91%E6%8C%87offer-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三十一篇。<br>
本题目解题思路非常的好，将数组的排列问题变成了字符串的比较问题。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&amp;tqId=11185&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h2 id="解题思路">解题思路</h2>
<p>主要思路就是将所有的数字进行排序，排序的依据就是两个数字拼接后的字符串的字典序。<br>
从而使得最后将数组所有元素进行拼接之后得到的结果就是最小的数字。<br>
非常巧妙。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(int a, int b)&#123;</span><br><span class="line">        string A = to_string(a)+to_string(b);</span><br><span class="line">        string B = to_string(b)+to_string(a);</span><br><span class="line">        return A&lt;B;</span><br><span class="line">    &#125;</span><br><span class="line">    string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        sort(numbers.begin(),numbers.end(),cmp);</span><br><span class="line">        for(int a:numbers)&#123;</span><br><span class="line">            res += to_string(a);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlgn),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-连续子数组的最大和</title>
    <url>/2020/01/21/%E5%89%91%E6%8C%87offer-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三十篇。<br>
主要知识点为动态规划，可以说这个题目是最常见的一个动态规划的题目了。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h2 id="解题思路">解题思路</h2>
<p>动态规划<br>
dp[i]数组表示从索引0到索引i之间的数组范围的最大连续子序列的和。<br>
dp[0] = array[0]<br>
dp[i] = max{array[i]+dp[i-1],array[i]}<br>
res = max{dp[i]}</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(array.size(),0);</span><br><span class="line">        dp[0] = array[0];</span><br><span class="line">        for(int i = 1;i&lt;array.size();i++)&#123;</span><br><span class="line">            dp[i] = max(dp[i-1]+array[i],array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return *max_element(dp.begin(),dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-数组中出现次数超过一半的数字</title>
    <url>/2020/01/21/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第二十九篇。<br>
主要知识点为数组，找出数组中出现次数超过一半的数字，两种方式解决这个问题。map计数和两军对决。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&amp;tqId=11181&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>找个map来存储每个字符出现的次数，然后遍历一遍map找到次数大于一半的数字即可。</p>
<h3 id="思路2">思路2</h3>
<p>可以想象成战场厮杀，要找的数字为红方，其他为蓝方，红蓝双方士兵实力相等，一换一。由于要找的数字出现次数超过一半，所以厮杀结束之后剩下的必然是我们要找的数字。<br>
回到本题目中来，我们按照数组顺序来依次上场，保存当前场上的序号和次数，若下一个字符和当前场上字符一致，则出现次数+1，若不一致，则-1，若次数减为0,则场上的人由下一次人来替换，出现次数变为1.等到所有的数据都遍历结束，则剩下的就是可能是结果的数据，然后计算该数据在整个数组中出现的次数，判断是否符合出现次数超过一般的条件，若符合，返回target，否则返回0。<br>
以a = {1,2,3,2,2,2,5,4,2}为例。</p>
<ol>
<li>索引为0时。保存target = 1,time = 1;</li>
<li>索引为1时，由于a[1]!= target, 所以原来target出现的次数要减1，保存target = 1, time = 0;</li>
<li>索引为2时，由于time = 0,所以更新target = 3,time = 1;</li>
<li>索引为3时，a[3] = 2与target不一致，所以更新target = 3,time = 0;</li>
<li>索引为4时，target = 2,time = 1;</li>
<li>索引为5时，target = 2,time = 2;</li>
<li>索引为6时，target = 2,time = 1;</li>
<li>索引为7时，target = 2,time = 0;</li>
<li>索引为8时，target = 2,time = 1;</li>
</ol>
<p>所以2是一个可能的解，然后在数组中计算target 2出现次数为5，超过数组长度的一半，所以返回target2.</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; mmap;</span><br><span class="line">        for(auto a:numbers)&#123;</span><br><span class="line">            mmap[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int temp = numbers.size()/2;</span><br><span class="line">        for(auto a:mmap)&#123;</span><br><span class="line">            if(a.second&gt; temp) return a.first;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        // 方法2: 两军对决</span><br><span class="line">        int target = 0,time = 0;</span><br><span class="line">        for(int i = 0; i &lt; numbers.size(); i++)&#123;</span><br><span class="line">            if(time == 0)&#123;</span><br><span class="line">                target = numbers[i];</span><br><span class="line">                time = 1;</span><br><span class="line">            &#125;else if(target != numbers[i])&#123;</span><br><span class="line">                time--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                time++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        time = count(numbers.begin(),numbers.end(),target);</span><br><span class="line">        return time&gt;numbers.size()/2?target:0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Map</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-字符串的排列</title>
    <url>/2020/01/20/%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第二十八篇。<br>
主要知识点为字符串，给定n个字符，给出所有的可能的排列，非常经典。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>
输入格式：输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>可以直接使用stl中的next_permutation操作来依次的获得下一个排序的结果。</p>
<h3 id="思路2">思路2</h3>
<p>基于前缀的排列生成。每次在排完前面的之后，对后面所有的元素进行全排列。<br>
以题目中的a,b,c为例进行说明。第一位有三种情况，</p>
<ol>
<li>情况1:第一位是a,将a作为前缀，那么后面需要对b和c进行全排列
<ol>
<li>情况1.1: 第二位是b,则此时就构成了ab，将ab作为前缀，然后对c进行全排列
<ol>
<li>情况1.1.1: 第三位是c,所以此时和前缀拼接构成abc.作为输出结果。</li>
</ol>
</li>
<li>情况1.2: 第二位是c,则此时就构成了ac, 将ac作为前缀，然后对b进行全排列
<ol>
<li>情况1.1.2: 第三位是b,所以此时和前缀拼接构成acb.作为输出结果。</li>
</ol>
</li>
</ol>
</li>
<li>情况2:第一位是b,将b作为前缀，那么后面需要对a和c进行全排列
<ol>
<li>情况2.1: 第二位是a,则此时就构成了ba，将ba作为前缀，然后对c进行全排列
<ol>
<li>情况2.1.1: 第三位是c,所以此时和前缀进行拼接构成bac.作为输出结果。</li>
</ol>
</li>
<li>情况2.2: 第二位是c,则此时就构成了bc,将bc作为前缀，然后对a进行全排列
<ol>
<li>情况2.1.2: 第三位是b,所以此时和前缀进行拼接构成bca.作为输出结果。</li>
</ol>
</li>
</ol>
</li>
<li>情况3:第一位是c,将c作为前缀，那么后面需要对a和b进行全排列
<ol>
<li>情况3.1: 第二位是b,则此时就构成了cb，将cb作为前缀，然后对a进行全排列
<ol>
<li>情况3.1.1: 第三位是a,所以此时和前缀进行拼接构成cba.作为输出结果。</li>
</ol>
</li>
<li>情况3.2: 第二位是a,则此时就构成了ca, 此时将ca作为前缀，然后对b进行全排列
<ol>
<li>情况3.1.2: 第三位是b,所以此时和前缀进行拼接构成cab.作为输出结果。<br>
综上所述，最终结果有六个{abc,acb,bac,bca,cba,cab}<br>
但是考虑到一个情况是如果有重复字符，比如两个a,<br>
那么按照上面的基于前缀的答案就变成了{aa,aa},而我们想要的答案是{aa},<br>
所以我们最后可以通过set来进行去重。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="思路3">思路3</h3>
<p>基于交换的全排列生成，可以避免有重复元素.<br>
<img src="https://img-blog.csdn.net/20160426160344631" alt=""><br>
上面这个图也很经典，<br>
第一列到第二列的变化是abc中的索引为0的字符和字符串的每个字符进行替换之后的样子。<br>
第二列到第三列的变化是在第一列的基础上索引为1的字符和它以及它之后每个字符替换之后的样子。<br>
第三列是在第二列的基础上索引为2的字符和它以及它之后每个字符进行替换之后的样子。<br>
从而实现了字符的全排列。<br>
为什么说这个方法可以避免重复元素呢。<br>
以bb来举例。 如果按照前缀进行排列且未经过set处理，必然结果是{bb,bb}。<br>
而基于交换的方法的话，从0号索引开始和与前面字符不重复的每一位进行替换。所以索引0和索引0替换，得到{b,b},0和1进行替换的时候，发现之前已经存在b了，所以就不再替换。1和1替换的时候，发现之前也存在b了，所以也不再进行替换，所以最后结果仅仅只有{bb}，从而避免了重复。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; Permutation(string str) &#123;</span><br><span class="line">        // 方法1： 直接使用stl中的next_permutation方法</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        if(str.size() == 0) return res;</span><br><span class="line">        do&#123;</span><br><span class="line">            res.push_back(str);</span><br><span class="line">        &#125;while(next_permutation(str.begin(),str.end()));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;string&gt; Permutation(string str) &#123;</span><br><span class="line">        //方法2： 基于前缀的排列生成。每次在排完前面的之后，对后面所有的元素进行全排列</span><br><span class="line">        if(str.size() == 0) return res;</span><br><span class="line">        helper2(&quot;&quot;,str);</span><br><span class="line">        //去除重复元素 如 aa 前面的res会生成 aa 和 aa， 而我们的结果只要返回&#123;aa&#125;即可</span><br><span class="line">        set&lt;string&gt; s(res.begin(),res.end());</span><br><span class="line">        res = vector&lt;string&gt;(s.begin(),s.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    // 方法2的辅助函数。</span><br><span class="line">    void helper2(string prefix, string str)&#123;</span><br><span class="line">        if(str.size() == 0)&#123;</span><br><span class="line">            res.push_back(prefix);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(int i = 0;i &lt; str.size(); i++)&#123;</span><br><span class="line">                helper2(prefix+str[i],str.substr(0,i)+str.substr(i+1,str.size()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路3代码">思路3代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;string&gt; Permutation(string str) &#123;</span><br><span class="line">        </span><br><span class="line">        //方法3: 基于交换的全排列生成，可以避免有重复元素</span><br><span class="line">        if(str.size() == 0) return res;</span><br><span class="line">        helper3(str,0);</span><br><span class="line">        sort(res.begin(),res.end());</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法3的辅助函数</span><br><span class="line">    void helper3(string str,int begin)&#123;</span><br><span class="line">        if(begin == str.size())&#123;</span><br><span class="line">            res.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = begin; i&lt; str.size(); i++)&#123;</span><br><span class="line">           if(!HasDuplicate(str,begin,i))&#123;</span><br><span class="line">                swap(str[begin],str[i]);</span><br><span class="line">                helper3(str,begin+1);</span><br><span class="line">                swap(str[begin],str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    bool HasDuplicate(string str,int begin,int end)&#123;</span><br><span class="line">        for(int i = begin;i &lt; end; i++)&#123;</span><br><span class="line">            if(str[i] == str[end]) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h2 id="参考资料">参考资料</h2>
<p>1.<a href="https://blog.csdn.net/gatieme/article/details/51251158" target="_blank" rel="noopener">剑指Offer–028-字符串的排列</a><br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-复杂链表的复制</title>
    <url>/2020/01/20/%E5%89%91%E6%8C%87offer-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第二十七篇。<br>
主要知识点为链表，同样是先遍历后操作，本来有只有一个后继结点，现在多加一个random结点。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h2 id="解题思路">解题思路</h2>
<p>首先按照正常的链表的遍历将这个链表进行一次深度复制（正常遍历指的就是通过next指针进行遍历），<br>
注意在复制的过程中通过一个map来保存原结点和新节点的对应关系，<br>
然后再遍历一遍，将新链表中random的链接关系补充上。<br>
整个题目就可以得到解决。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct RandomListNode &#123;</span><br><span class="line">    int label;</span><br><span class="line">    struct RandomListNode *next, *random;</span><br><span class="line">    RandomListNode(int x) :</span><br><span class="line">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">       if(!head) return NULL;</span><br><span class="line">       unordered_map&lt;RandomListNode*,RandomListNode*&gt; mmap;</span><br><span class="line">       RandomListNode* nhead = new RandomListNode(head-&gt;label);</span><br><span class="line">       mmap[head] = nhead;</span><br><span class="line">       RandomListNode* ntail = nhead, *p = head-&gt;next;</span><br><span class="line">       while(p)&#123;</span><br><span class="line">           RandomListNode* temp = new RandomListNode(p-&gt;label);</span><br><span class="line">           mmap[p] = temp;</span><br><span class="line">           ntail-&gt;next = temp;</span><br><span class="line">           ntail = ntail-&gt;next;</span><br><span class="line">           p = p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       p = head;</span><br><span class="line">       while(p)&#123;</span><br><span class="line">          mmap[p]-&gt;random = mmap[p-&gt;random];</span><br><span class="line">          p = p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       return nhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二叉树中和为某一值的路径</title>
    <url>/2020/01/20/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第二十六篇。<br>
主要知识点为二叉树，在二叉树的遍历的基础上去判断是否有存在路径之和等于定值。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<h2 id="解题思路">解题思路</h2>
<ol>
<li>从最简单的情况开始考虑，如果树只有一个根结点，那么我们只要判断这个节点的值是不是只要等于目标值target即可。</li>
<li>再复杂一点，如果有三个节点，根节点和左右子节点。那么我们我们在其实就相当于在子节点中判断值是不是等于目标值减去根节点的值即可。其实等价于简化到了第一种情况——单个节点。</li>
<li>如果层数继续加深，最后的判断其实还是等价于在最后一层判断节点的值是否等于目标值减去整个路径上所有的节点的值。</li>
<li>思想类似于前序遍历，只是本来的打印变成了节点条件的判断放到了最后的叶子结点一层，然后每一层向下一层遍历的时候需要更改期待值。<br>
既然是前序遍历就可以用递归和非递归两种方式来解决这个问题。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<h3 id="代码1-用全局temp-递归来实现">代码1:用全局temp+递归来实现</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">        if(root==NULL)</span><br><span class="line">            return res;</span><br><span class="line">        temp.push_back(root-&gt;val);</span><br><span class="line">        if((expectNumber-root-&gt;val)==0 &amp;&amp; root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)</span><br><span class="line">            &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root-&gt;left,expectNumber-root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right,expectNumber-root-&gt;val);</span><br><span class="line">        if(tmp.size()!=0)&#123;</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="代码2-完全用递归来实现">代码2:完全用递归来实现</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        helper(root,expectNumber,temp);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void helper(TreeNode* root,int expectNumber,vector&lt;int&gt; temp)&#123;</span><br><span class="line">        if(!root || expectNumber &lt; 0) return ;</span><br><span class="line">        temp.push_back(root-&gt;val);</span><br><span class="line">        if(root-&gt;val == expectNumber &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)&#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left) helper(root-&gt;left,expectNumber-root-&gt;val,temp);</span><br><span class="line">        if(root-&gt;right) helper(root-&gt;right,expectNumber-root-&gt;val,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二叉搜索树的后序遍历序列</title>
    <url>/2020/01/20/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第二十五篇。<br>
主要知识点为二叉搜索树，判断一个序列是否为二叉搜索树的后序遍历序列。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h2 id="解题思路">解题思路</h2>
<p>二叉搜索树的性质就是根节点的值要大于左子树所有节点的值，要小于右子树的所有节点的值，左右子树又同样都是二叉搜索树。<br>
后序遍历的顺序是左子树，右子树，然后根节点。<br>
从而我们就可以得出结论，对于一个二叉搜索树的后序遍历来说，一定包含三部分（当然可能存在左右子树为空的情况）。首先最后一个节点是根节点，根节点前面的数据分为两部分，一部分都会比根节点小，这些是原来二叉搜索树的左子树，一部分都会比根节点要大，这就是原来二叉搜索树的右子树。我们在判断的时候可以设定本子树在序列中的左右边界，然后从右边界开始往前找，找到第一个比根节点小的索引，那么这个索引之前到左边界之间的节点的值都应该比根节点的值要小，否则就不会满足二叉搜索树的条件，返回false即可。<br>
然后左右子树的序列又可以以同样的方式来进行判断是否为二叉搜索树。<br>
又可以用一个完美的递归来解决这个问题。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; seq) &#123;</span><br><span class="line">        if(seq.size() == 0) return false;</span><br><span class="line">        return helper(seq,0,seq.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    bool helper(vector&lt;int&gt;&amp; a, int l, int r)&#123;</span><br><span class="line">        if(l&gt;=r) return true;</span><br><span class="line">        int i  = r;</span><br><span class="line">        while(i&gt;l &amp;&amp; a[i-1] &gt; a[r]) i--;</span><br><span class="line">        for(int j = i-1; j&gt;=l;j--) if(a[j] &gt; a[r]) return false;</span><br><span class="line">        return helper(a,l,i-1) &amp;&amp;helper(a,i, r-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinarySearchTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-从上往下打印二叉树</title>
    <url>/2020/01/20/%E5%89%91%E6%8C%87offer-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第二十四篇。<br>
主要知识点就是树的层序遍历，比较经典，也比较简单。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h2 id="解题思路">解题思路</h2>
<p>其实就是层序遍历，通过队列保存某一层的数据，然后依次的读取这一层数据，在遍历过程中，如果节点的左右子树不为空的话，继续加入到队列中，直到队列为空。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return &#123;&#125;;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">                auto a = q.front(); q.pop();</span><br><span class="line">                res.push_back(a-&gt;val);</span><br><span class="line">                if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Queue</tag>
        <tag>Codinginterviews</tag>
        <tag>BinaryTree</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-栈的压入弹出序列</title>
    <url>/2020/01/20/%E5%89%91%E6%8C%87offer-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第二十三篇。<br>
主要知识点依旧是栈Stack，判断一个序列是否可以成为某个入栈序列的出栈序列，题目很好很经典，值得学习。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h2 id="解题思路">解题思路</h2>
<p>因为需要判断的出栈顺序已经确定了，所以我们只要按照压栈顺序来判断一下如此压栈能不能产生对应的出栈顺序即可。<br>
考虑到可能中间出栈的情况，所以我们在每压入一个元素之后要进行相应的判断，如果栈顶元素和出栈数组中标记的元素是对应的，那么当前元素出栈，待判断的元素后移一位，如果不对应，则继续压栈。<br>
直到所有元素压栈完成，可能的出栈操作结束。<br>
这个时候看栈内是否还剩元素，如果不剩元素，那么就是依据出栈数组中的数据已经完成出栈，则出栈顺序成立。否则就是不成立。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        stack&lt;int&gt; mstack;</span><br><span class="line">        int j = 0;</span><br><span class="line">        for(int i = 0;i&lt;pushV.size();i++)&#123;</span><br><span class="line">            mstack.push(pushV[i]);</span><br><span class="line">            while(!mstack.empty() &amp;&amp; mstack.top() == popV[j])&#123;</span><br><span class="line">                mstack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mstack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-包含min函数的栈</title>
    <url>/2020/01/20/%E5%89%91%E6%8C%87offer-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第二十二篇。<br>
主要知识点为栈，要求给栈再pop和push操作之外在添加一个min操作来获得当前栈元素的最小值。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>如果不考虑时间复杂度O(1)限制的话，我们可以加一个栈，然后加一个数组来存，每次找最小元素的话，可以利用stl的min_element来获的，在pop的时候记得将数组中的pop的元素也要删除掉。<br>
但是这样复杂度会比较高。有一个查找和删除的操作。</p>
<h3 id="思路2">思路2</h3>
<p>用一个栈A来正常保存元素，另一个栈B来保存当前元素个数下A栈中最小的元素，两个栈始终保持同样高度。</p>
<ol>
<li>进行pop操作的时候两个都pop。</li>
<li>进行push操作的时候，A正常push，Bpush的时候要判断新加入的元素和之前B的栈顶元素谁大谁小，push进去那个小的元素。</li>
<li>进行min操作的时候，返回B的栈顶元素即可。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    stack&lt;int&gt; mstack;</span><br><span class="line">    vector&lt;int&gt; mvec;</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        mstack.push(value);</span><br><span class="line">        mvec.push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">      int a = mstack.top();</span><br><span class="line">      mstack.pop();</span><br><span class="line">      auto b = find(mvec.begin(),mvec.end(),a);</span><br><span class="line">      mvec.erase(b);</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">       return mstack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return *min_element(mvec.begin(),mvec.end()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //思路2 两个栈进行保存</span><br><span class="line">    stack&lt;int&gt; dstack;</span><br><span class="line">    stack&lt;int&gt; mstack;</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        dstack.push(value);</span><br><span class="line">        if(mstack.empty() || mstack.top()&gt;value)&#123;</span><br><span class="line">            mstack.push(value);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            mstack.push(mstack.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        dstack.pop();</span><br><span class="line">        mstack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">       return dstack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return mstack.top(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-顺指针打印矩阵</title>
    <url>/2020/01/20/%E5%89%91%E6%8C%87offer-%E9%A1%BA%E6%8C%87%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第二十一篇。<br>
给定一个矩阵，顺时针将数据打印出来，没有特殊的难点，主要就是为了考察耐心和细心程度。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：<br>
1  2  3  4<br>
5  6  7  8<br>
9  10 11 12<br>
13 14 15 16</p>
<p>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h2 id="解题思路">解题思路</h2>
<p>建立好上下左右的边界，然后按照顺时针的顺序依次遍历即可。<br>
需要注意只有一行或者一列的情况，不要重复遍历。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;</span><br><span class="line">        int rows = matrix.size(); </span><br><span class="line">        int cols = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if(rows == 0 || cols == 0) return res;</span><br><span class="line">        int left = 0, right = cols-1, up = 0, bottom = rows-1;</span><br><span class="line">        while(left &lt;= right &amp;&amp; up &lt;= bottom)&#123;</span><br><span class="line">            // 上面一行</span><br><span class="line">            for(int i = left; i &lt;= right; i++)&#123;</span><br><span class="line">                res.push_back(matrix[up][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 右侧一列</span><br><span class="line">            for(int i = up+1; i &lt;= bottom; i++)&#123;</span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            // 下面一行</span><br><span class="line">            if(up != bottom)&#123;</span><br><span class="line">                for(int i = right-1; i &gt;= left; i--)&#123;</span><br><span class="line">                res.push_back(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 左侧一列</span><br><span class="line">            if(left != right)&#123;</span><br><span class="line">                for(int i = bottom-1; i &gt; up; i--)&#123;</span><br><span class="line">                res.push_back(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++; right--; up++; bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二叉树的镜像</title>
    <url>/2020/01/20/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第二十篇。<br>
主要知识点为树，给定一棵树来构造它的镜像，用完美的递归逻辑和直观的层序遍历来解决这个问题。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>
二叉树的镜像定义：源二叉树<br>
8<br>
/ \<br>
6  10<br>
/ \  / \<br>
5  7 9 11<br>
镜像二叉树<br>
8<br>
/  \<br>
10   6<br>
/ \  / \<br>
11 9 7  5</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>通过观察这个给定的样例可以发现，对于任何一个节点，都是左右子树进行了替换。原来的左子树变成了如今的右子树，而原来的右子树成为了如今的左子树。由于树的结构的特殊性，这就是一个完美的递归思路啊。</p>
<h3 id="思路2">思路2</h3>
<p>同样还是左右子树来进行替换，我们可以通过<strong>层序遍历</strong>来依次的获得需要将子树进行替换的节点，然后将子树进行替换。扩展一下，前序遍历中序遍历后序遍历应该都是可以的。</p>
<h3 id="思路3">思路3</h3>
<p>尝试一下前序遍历来进行替换。写完了我才发现，其实和思路1是相同的道理，只是我们将左右子树的替换单独拿了出来，替换部分其实就类似于我们遍历的时候的cout语句，殊途同归。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Mirror(TreeNode *root) &#123;</span><br><span class="line">        // 方法1 递归</span><br><span class="line">        if(!root) return;</span><br><span class="line">        root = helper(root);</span><br><span class="line">    &#125;</span><br><span class="line">   TreeNode* helper(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return NULL;</span><br><span class="line">        TreeNode *temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = helper(root -&gt; right);</span><br><span class="line">        root-&gt;right = helper(temp);</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Mirror(TreeNode *root) &#123;</span><br><span class="line">        //方法二 层序遍历</span><br><span class="line">        if(!root) return;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            for(int i = q.size();i&gt;0;i--)&#123;</span><br><span class="line">                TreeNode* a = q.front(); q.pop();</span><br><span class="line">                TreeNode* temp = a-&gt;left;</span><br><span class="line">                a-&gt;left = a-&gt;right;</span><br><span class="line">                a-&gt;right = temp;</span><br><span class="line">                if(a-&gt;left) q.push(a-&gt;left);</span><br><span class="line">                if(a-&gt;right) q.push(a-&gt;right);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路3代码">思路3代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Mirror(TreeNode *root) &#123;</span><br><span class="line">        //方法3 前序遍历</span><br><span class="line">        if(!root) return;</span><br><span class="line">        root = preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* preOrder(TreeNode* root)&#123;</span><br><span class="line">        if(!root)return NULL;</span><br><span class="line">        helper3(root);</span><br><span class="line">        if(root-&gt;left) preOrder(root-&gt;left);</span><br><span class="line">        if(root-&gt;right) preOrder(root-&gt;right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    void helper3(TreeNode* root)&#123;</span><br><span class="line">        TreeNode* temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-树的子结构</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十九篇。<br>
主要知识点为树，主要是对树进行相关的遍历，对树的相似性进行判断。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h2 id="解题思路">解题思路</h2>
<p>依次遍历A的所有节点，然后来判断当前节点所在的部分是不是和B的结构一致就可以。可以直接使用递归。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!pRoot2 || !pRoot1) return false;</span><br><span class="line">        if(pRoot1-&gt;val == pRoot2-&gt;val &amp;&amp; helper(pRoot1,pRoot2))&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return HasSubtree(pRoot1-&gt;left,pRoot2)||HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bool helper(TreeNode* pRoot1,TreeNode* pRoot2)&#123;</span><br><span class="line">        if(!pRoot2) return true;</span><br><span class="line">        if(!pRoot1) return false;</span><br><span class="line">        if(pRoot1-&gt;val == pRoot2-&gt;val)&#123;</span><br><span class="line">            return helper(pRoot1-&gt;left,pRoot2-&gt;left) &amp;&amp; helper(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-合并两个排序的链表</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十八篇。<br>
主要知识点是链表，仍然是在遍历链表的基础上进行相关操作，非常经典。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h2 id="解题思路">解题思路</h2>
<p>找两个指针分别指向两个有序链表的头结点，然后依次找最小值放到存放结果的链表之中即可。<br>
要记得考虑一个链表遍历完而另一个链表没有遍历完的情况。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">            val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* phead1, ListNode* phead2)</span><br><span class="line">    &#123;</span><br><span class="line">         if(!phead1 &amp;&amp; !phead2) return NULL;</span><br><span class="line">        if(!phead1) return phead2;</span><br><span class="line">        if(!phead2) return phead1;</span><br><span class="line">        ListNode *head = NULL, *tail = NULL;</span><br><span class="line">        ListNode *p1= phead1,*p2 = phead2;</span><br><span class="line">        while(p1 &amp;&amp; p2)&#123;</span><br><span class="line">            if(p1-&gt;val &lt;= p2-&gt;val)&#123;</span><br><span class="line">                ListNode* temp = new ListNode(p1-&gt;val);</span><br><span class="line">                if(!head)&#123;</span><br><span class="line">                    head = temp;</span><br><span class="line">                    tail = temp; </span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;next = temp;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                p1= p1-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ListNode* temp = new ListNode(p2-&gt;val);</span><br><span class="line">                  if(!head)&#123;</span><br><span class="line">                    head = temp;</span><br><span class="line">                    tail = temp; </span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;next = temp;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                p2= p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!p1 &amp;&amp; !p2) return head;</span><br><span class="line">        while(p1)&#123;</span><br><span class="line">            ListNode* temp = new ListNode(p1-&gt;val);</span><br><span class="line">                if(!head)&#123;</span><br><span class="line">                    head = temp;</span><br><span class="line">                    tail = temp; </span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;next = temp;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                p1= p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p2)&#123;</span><br><span class="line">            ListNode* temp = new ListNode(p2-&gt;val);</span><br><span class="line">                  if(!head)&#123;</span><br><span class="line">                    head = temp;</span><br><span class="line">                    tail = temp; </span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;next = temp;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                p2= p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-反转链表</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十七篇。<br>
主要知识点为链表，还是在链表遍历的基础上做文章，比较简单。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h2 id="解题思路">解题思路</h2>
<p>新建一个结点head表示头结点。<br>
当遍历原来的链表到结点A的时候，创建一个新的节点A’，值等于A结点的值，A’指向原来的head结点，而head结点指向A结点。<br>
如此这般，将原来的链表遍历完，整个问题也就得到解决了。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">            val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        ListNode *head = NULL;</span><br><span class="line">        ListNode* p = pHead;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            ListNode *temp = new ListNode(p-&gt;val);</span><br><span class="line">            temp-&gt;next = head;</span><br><span class="line">            head = temp;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-链表中倒数第K个节点</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十六篇。<br>
主要知识点为链表，就是在链表遍历的基础上进行查找操作，细心一点也没啥问题。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>先将链表遍历一遍，计算总的结点的个数。<br>
然后计算倒数第k个是正数第多少个，然后再遍历一遍，找到要输出的结点。</p>
<h3 id="思路2">思路2</h3>
<p>通过双指针来解决问题。快的结点要比慢的结点提前k个，<br>
当后面那个走到尾节点所指向的空结点的时候，慢的指针刚好指向要求输出的节点。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">            val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* phead, unsigned int k) &#123;</span><br><span class="line">        //方法一，先跑一遍，计算总的个数。然后计算倒数第k个是正数第多少个，然后再遍历一遍。</span><br><span class="line">        if(!phead || k == 0) return NULL;</span><br><span class="line">        int count = 0;</span><br><span class="line">        ListNode* p = phead;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count &lt; k) return NULL;</span><br><span class="line">        p = phead;</span><br><span class="line">        for(int i = count-k; i&gt;0; i--)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* phead, unsigned int k) &#123;</span><br><span class="line">        //方法二：快慢双指针。</span><br><span class="line">        if(!phead || k == 0) return NULL;</span><br><span class="line">        ListNode* fast, *slow;</span><br><span class="line">        fast = slow = phead;</span><br><span class="line">        for(int i = 0;i&lt;k;i++)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            if(!fast &amp;&amp; i==k-1) return phead;</span><br><span class="line">            if(!fast) return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        while(fast)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者可以用另一种写法，比较优美一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">            val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">        if(!pListHead || k &lt;= 0) return NULL;</span><br><span class="line">        ListNode* fast = pListHead;</span><br><span class="line">        ListNode* slow = pListHead;</span><br><span class="line">        while(k&gt;0 &amp;&amp; fast)&#123;</span><br><span class="line">            k--;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(fast)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return k&gt;0?NULL:slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-调整数组顺序使奇数位于偶数前面</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十五篇。<br>
就是调整数组中元素的顺序，使得奇数在前，偶数在后，题目比较简单，直接动手吧。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>先将原来的数组扫描一遍，将奇数和偶数分别存在两个数组中，然后将两个数组进行拼接即可。</p>
<h3 id="思路2">思路2</h3>
<p>类似于冒泡排序，对于所有的奇数从后往前冒泡，直到排到前面都是奇数的位置，当所有元素冒泡结束后的顺序就是目标顺序。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">        // 方法1</span><br><span class="line">        vector&lt;int&gt; odd;  // 奇数</span><br><span class="line">        vector&lt;int&gt; even; // 偶数</span><br><span class="line">        for(int i = 0;i&lt;array.size();i++)&#123;</span><br><span class="line">            if(array[i]%2 == 0)&#123;</span><br><span class="line">                even.push_back(array[i]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                odd.push_back(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.insert(odd.end(),even.begin(),even.end());</span><br><span class="line">        array = odd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n),是额外的O(n)。</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">        // 方法二:类似于冒泡排序</span><br><span class="line">        for(int i =1; i&lt;array.size();i++)&#123;</span><br><span class="line">            if(array[i]%2==1)&#123;</span><br><span class="line">                int idx = i;</span><br><span class="line">                int temp = array[i];</span><br><span class="line">                while(idx&gt;0 &amp;&amp; array[idx-1]%2 == 0)&#123;</span><br><span class="line">                   array[idx] = array[idx-1];</span><br><span class="line">                   idx--;</span><br><span class="line">                &#125;</span><br><span class="line">                array[idx] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-数值的整数次方</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十四篇。<br>
细心一点，搞清楚正负逻辑，这个题目就是非常简单的送分题。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>
保证base和exponent不同时为0</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>直接使用库函数pow()来进行计算乘方操作。</p>
<h3 id="思路2">思路2</h3>
<p>对exponent进行分情况讨论:大于0，小于0，等于0。<br>
然后要注意最终结果的正负判断。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">       return pow(base,exponent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        double res = 1;</span><br><span class="line">        if(exponent == 0)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else if(exponent&gt;0)&#123;</span><br><span class="line">            while(exponent &gt;0)&#123;</span><br><span class="line">                res *= base;</span><br><span class="line">                exponent--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            while(exponent &lt;0)&#123;</span><br><span class="line">                res *= (1/base);</span><br><span class="line">                exponent++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(base &lt; 0 &amp;&amp; exponent%2 == 1) res *= -1; </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>送分题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二进制中1的个数</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十三篇。<br>
主要知识点为进制转化和位运算以及数据在计算机中的存储方式，解题方式比较巧妙。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>我们知道在计算机中数据是以二进制0和1进行存储的，所以我们可以通过1和这个数据的每一位进行&amp;运算来计算原来数据中1的个数。</p>
<h3 id="思路2">思路2</h3>
<p>通过n = n&amp;(n-1)这个运算会消掉n的二进制表示中最右侧的1，只要判断多少次之后n变成0即可计算出原来n中有多少位1.</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int res = 0;</span><br><span class="line">         int flag = 1;</span><br><span class="line">         while( flag != 0)&#123;</span><br><span class="line">             if(n &amp; flag) res++;</span><br><span class="line">             flag = flag &lt;&lt;1;</span><br><span class="line">         &#125;</span><br><span class="line">         return res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int res = 0;</span><br><span class="line">         while(n != 0)&#123;</span><br><span class="line">             res++;</span><br><span class="line">             n = n &amp;(n-1);</span><br><span class="line">         &#125;</span><br><span class="line">         return res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-矩形覆盖</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十二篇。<br>
主要知识点为斐波那契数列，只是需要先对问题进行分析，同样还是用三种方式来解决这个问题。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">题目描述</a></h2>
<p>我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2<em>1的小矩形无重叠地覆盖一个2</em>n的大矩形，总共有多少种方法？</p>
<h2 id="解题思路">解题思路</h2>
<p>方便解释起见，我们假设整个横着的就是一个宽为2，长为n的大矩形，下面分情况讨论。</p>
<ol>
<li>n = 0 : 结果为0</li>
<li>n = 1 : 结果为1，竖着一个。</li>
<li>n = 2 : 结果为2 竖着两个或者横着两个。</li>
<li>n = 3 : 结果为3，在n=1的基础上横排两个，或者在n=2的基础上竖着加一个。</li>
<li>……<br>
综上，我们就得到结论：f(n) = f(n-1)+f(n-2) 初始项为{0,1,2}</li>
</ol>
<h3 id="思路1">思路1</h3>
<p>直接用递归。</p>
<h3 id="思路2">思路2</h3>
<p>用数组保存</p>
<h3 id="思路3">思路3</h3>
<p>保存两个关键数字。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int n) &#123;</span><br><span class="line">        // 方法1 直接用递归。</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else if(n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return rectCover(n-1)+rectCover(n-2);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int n) &#123;</span><br><span class="line">        //方法2: 数组保存</span><br><span class="line">        vector&lt;int&gt; res = &#123;0,1,2&#125;;</span><br><span class="line">        for(int i = 2;i &lt; n; i++)&#123;</span><br><span class="line">            res.push_back(res[i]+res[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路3代码">思路3代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int n) &#123;</span><br><span class="line">        // 方法3. 用两个关键变量进行保存。</span><br><span class="line">        if(n==0) return 0;</span><br><span class="line">        if(n == 1) return 1;</span><br><span class="line">        if(n == 2) return 2;</span><br><span class="line">        int first = 1,second = 2;</span><br><span class="line">        for(int i = 2; i &lt; n; i++)&#123;</span><br><span class="line">            int temp = first+second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-变态跳台阶</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十一篇。<br>
主要知识点为找规律，可以作为上一篇跳台阶的升级版,依旧比较简单。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="解题思路">解题思路</h2>
<p>直接找规律。</p>
<ol>
<li>第一级台阶：1种方式。</li>
<li>第二级台阶：2种方式。1+1 ：直接跳到2级或者从1级上跳上来。</li>
<li>第三级台阶：4种方式。1+1+2 ：直接跳到3级或者从1级跳上来或者从2级跳上来。</li>
<li>……</li>
<li>第n级台阶：2^(n-1)种方式。 1+1+2+4+……+2^(n-2) = 2^(n-1)。直接跳到n级或者从前面的每一级跳到当前n级。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        return pow(2,number-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-跳台阶</title>
    <url>/2020/01/18/%E5%89%91%E6%8C%87offer-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十篇。<br>
主要内容其实还是斐波那契数列，依旧是上一篇斐波那契的思路，再复习一遍。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h2 id="解题思路">解题思路</h2>
<p>第一级台阶： 1种跳法<br>
第二级台阶： 2种跳法<br>
第三级台阶： 3种跳法：要么从第一级跳2级跳上来，要么从第二级跳1级跳上来。<br>
……<br>
第n级台阶：f(n-2)+f(n-1): 要么从n-2级一次跳两级跳上来，那么从n-1级跳一级跳上来。<br>
所以就是一个非常典型的斐波那契数列，最开始两项分别是1和2.</p>
<h3 id="思路1">思路1</h3>
<p>直接用递归</p>
<h3 id="思路2">思路2</h3>
<p>用数组保存</p>
<h3 id="思路3">思路3</h3>
<p>保存两个关键数字</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int num) &#123;</span><br><span class="line">        //方法1.递归解决</span><br><span class="line">         if(num == 1)&#123;</span><br><span class="line">           return 1;</span><br><span class="line">         &#125;else if( num == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">            return jumpFloor(num-1) + jumpFloor(num-2);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int num) &#123;</span><br><span class="line">        // 方法2: 数组保存</span><br><span class="line">         vector&lt;int&gt; a=&#123;0,1,2&#125;;</span><br><span class="line">         for(int i = 3; i&lt;=num; i++)&#123;</span><br><span class="line">             a.push_back(a[i-1]+a[i-2]);</span><br><span class="line">         &#125;</span><br><span class="line">         return a[num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路3代码">思路3代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int num) &#123;</span><br><span class="line">        // 方法3:</span><br><span class="line">        int first = 1, second = 2;</span><br><span class="line">        if(num == 1) return 1;</span><br><span class="line">        if(num == 2) return 2;</span><br><span class="line">        for(int i = 2; i &lt; num; i++)&#123;</span><br><span class="line">            int temp = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-斐波那契数列</title>
    <url>/2020/01/18/%E5%89%91%E6%8C%87offer-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第九篇。<br>
主要知识点就是斐波那契数列，非常常见，非常经典。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>直接通过斐波那契的概念来进行计算，递归调用。</p>
<h3 id="思路2">思路2</h3>
<p>我们知道递归调用的时候，很多部分都是重复计算的，所以我们可以建立一个数组进行保存。</p>
<h3 id="思路3">思路3</h3>
<p>仔细想想，每次计算的时候，对我们真正有用的数据其实只有两个，所以我们只要能够保存好两个必要的数据即可依次的计算后面的数据，直到算出我们想要的数据。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        //方法1: 递归</span><br><span class="line">        if(n == 0)return 0;</span><br><span class="line">        if(n == 1) return 1;</span><br><span class="line">        return Fibonacci(n-1)+Fibonacci(n-2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        // 方法2: 数据保存在一个数组中</span><br><span class="line">        vector&lt;int&gt; a=&#123;0,1&#125;;</span><br><span class="line">        for(int i = 2;i&lt;=39;i++)&#123;</span><br><span class="line">            a.push_back(a[i-1]+a[i-2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return a[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路3代码">思路3代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        // 方法3. 通过2个常量来进行数据的保存。</span><br><span class="line">        int first = 0,second = 1;</span><br><span class="line">        if(n == 0) return first;</span><br><span class="line">        if(n == 1) return second;</span><br><span class="line">        for(int i = 1; i&lt;n; i++)&#123;</span><br><span class="line">            int temp = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-旋转数组的最小数字</title>
    <url>/2020/01/18/%E5%89%91%E6%8C%87offer-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第八篇。<br>
其实就是找有序数组的最小元素，只是这个有序数组进行了一次旋转而已。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>直接使用stl中的min_element方法。一行代码就可以搞定。</p>
<h3 id="思路2">思路2</h3>
<p>思路2是可以使用类似于二分的方法进行查找，我们在看这个数字经过旋转之后的变化，其实如果一旦二分，我们会发现那个最小元素其实会存在于某个区间内，而这个区间并不满足左边的元素要小于右边的元素。而另一个区间是满足的，因为本身的数组就是非递减排序的，所以只会有一个区间是出现降序排列。这样我们只要找到导致降序的点即可。<br>
还有一个要注意的点，就是这个里面可能会有重复数据，所以可能出现中间元素和尾元素相等的情况，这个时候其实不能确定那个降序点在什么地方，所以这个时候就尾节点区间减少一个即可。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        return *min_element(rotateArray.begin(),rotateArray.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(rotateArray.size() == 0) return 0;</span><br><span class="line">        if(rotateArray.size() == 1) return rotateArray[0];</span><br><span class="line">        int l = 0,r = rotateArray.size()-1;</span><br><span class="line">        while(l&lt;r)&#123;</span><br><span class="line">            int mid = l + (r-l)/2;</span><br><span class="line">            if(rotateArray[mid]&lt;rotateArray[r])&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;else if(rotateArray[mid]&gt;rotateArray[r])&#123;</span><br><span class="line">                l = mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度好的情况为O(logn),不好的情况为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-用两个栈实现队列</title>
    <url>/2020/01/18/%E5%89%91%E6%8C%87offer-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第七篇。<br>
目的就是用两个后进先出的栈来实现一个先进先出的队列，思路比较巧妙。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>思路1比较朴素，我们用一个栈来作为数据存储的栈A，然后另一个作为中转的栈B，当我们存数据的时候，我们将数据压入到栈A中，然后取数据的时候，我们将A的所有数据都压入到B中，这个时候B的出栈顺序也就是队列应该的出队列顺序了，所以此时将B的栈顶元素取出即可，然后再将B中的所有的数据重新压回A中，后续操作皆是如此。</p>
<h3 id="思路2">思路2</h3>
<p>思路2其实是思路1的改进版，我们发现思路1在将数据取出之后，又把所有数据压回A栈，这样就会有很大的浪费，这里其实只要加一层判断，当往外取数据的时候，只要B栈不为空，就直接从B栈出栈栈顶元素即可，如果B栈为空，那么将A栈的数据全部压入到B栈中。从而省去中间多余的数据的来回压入操作。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">      while(!stack1.empty())&#123;</span><br><span class="line">           stack2.push(stack1.top());</span><br><span class="line">           stack1.pop();</span><br><span class="line">       &#125;</span><br><span class="line">      int res =  stack2.top();</span><br><span class="line">      stack2.pop();</span><br><span class="line">      while(!stack2.empty())&#123;</span><br><span class="line">           stack1.push(stack2.top());</span><br><span class="line">           stack2.pop();</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">      if(stack2.empty())&#123;</span><br><span class="line">          while(!stack1.empty())&#123;</span><br><span class="line">              stack2.push(stack1.top());</span><br><span class="line">              stack1.pop();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      int res = stack2.top(); stack2.pop();</span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Queue</tag>
        <tag>Stack</tag>
        <tag>Codinginterviews</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-重建二叉树</title>
    <url>/2020/01/18/%E5%89%91%E6%8C%87offer-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第六篇。<br>
主要就是根据二叉树遍历的前序遍历和中序遍历重新构造出原始的二叉树。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h2 id="解题思路">解题思路</h2>
<p>前序遍历的顺序是 根节点，左子树，右子树。<br>
中序遍历的顺序是 左子树，根节点，右子树。<br>
所以我们可以发现，前序遍历的第一个节点就是根节点，然后我们在中序遍历中找到这个根节点，那么这个根节点之前的就是左子树的中序，根节点之后的就是右子树的中序，然后可以根据左子树的个数，在前序遍历中将左子树和右子树进行分离，而分离的结果可以用来构建左子树和右子树。</p>
<p>下面以题目中的数据为例进行详细说明</p>
<ol>
<li>首先根据前序遍历，可以知道当前的根节点为1。</li>
<li>在中序遍历中寻找节点1， 然后1之前的节点[4,7,2]就是当前树的左子树的中序遍历，1之后的节点[5,3,8,6]就是当前树的右子树的中序遍历。</li>
<li>在前序遍历中根据左子树的节点个数找到对应的左子树的前序遍历[2,4,7],和对应的右子树的前序遍历【3，5，6，8】。</li>
<li>同样的操作可以继续针对左子树和右子树，从而把整个的二叉树构建出来。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">            return helper(pre,0,pre.size()-1,vin,0,vin.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* helper(vector&lt;int&gt; pre,int pstart,int pend,vector&lt;int&gt; vin,int vstart,int vend)&#123;</span><br><span class="line">        if(vstart &gt; vend) return NULL;</span><br><span class="line">        int root = pre[pstart];</span><br><span class="line">        TreeNode* temp = new TreeNode(root);</span><br><span class="line">        </span><br><span class="line">        auto a = find(vin.begin(),vin.end(),root);</span><br><span class="line">        int index = distance(vin.begin(),a);</span><br><span class="line">        int lnum = index - vstart; //左子树</span><br><span class="line">        temp -&gt; left = helper(pre,pstart+1,pstart+lnum,vin,vstart,index-1);</span><br><span class="line">        temp -&gt; right = helper(pre,pstart+1+lnum,pend,vin,index+1,vend);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
类似的题目还有根据中序和后续进行重建二叉树，道理类似，只是根节点变成了后续遍历的最后一个节点。<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-从尾到头打印链表</title>
    <url>/2020/01/17/%E5%89%91%E6%8C%87offer-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五篇。<br>
题目要求就是打印链表，属于很常见的问题，但是因为题目要求从尾到头打印链表，所以又生出了一些波折。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList.</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>从头到尾遍历这个链表，然后将得到的值插入用于保存结果的vector的初始位置。<br>
这个方法很容易能够想到，但是性能其实不是很好，就是因为在vector开头插入元素的时候，需要将这个vector中的所有元素向后移动一位，所以复杂度就会比较高，更多详细的解释可以看之后的关于字符串替换的那个题目。</p>
<h3 id="思路2">思路2</h3>
<p>从头到尾遍历这个链表，将遍历得到的值依次插入到用于保存结果的vector的后面，最后再反转整个vector。</p>
<h3 id="思路3">思路3</h3>
<p>从头到尾遍历这个链表，将数据压入到对应的栈中，然后利用栈的先进后出的特性，将所有结果出栈，以后插入用于保存结果的vector后面即可。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        // 思路1: 遍历的时候前面插入结果</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            res.insert(res.begin(),p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        // 思路2: 遍历的时候后插，然后返回reverse的结果。 4ms 480k</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路3代码">思路3代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        // 思路3: 通过栈先进后出的特性来实现链表的从尾到头遍历 3ms 460k</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        stack&lt;int&gt; mstack;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            mstack.push(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(mstack.size() != 0)&#123;</span><br><span class="line">            res.push_back(mstack.top());</span><br><span class="line">            mstack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>链表</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-最小的K个数</title>
    <url>/2020/01/17/%E5%89%91%E6%8C%87offer-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四篇。<br>
本题比较常见，而且思路也非常清晰，一个是排序，一个用最小堆。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1</h3>
<p>直接从小到大将所有所有数字进行排序，然后取前K个即可。</p>
<h3 id="思路2">思路2</h3>
<p>把所有的数据进行处理构造最小堆，然后取出前K个返回即可。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        if(k&gt;input.size()) return &#123;&#125;;</span><br><span class="line">        sort(input.begin(),input.end());</span><br><span class="line">        return vector&lt;int&gt;(input.begin(),input.begin()+k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlogn),空间复杂度为O(n)</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        if(k&gt;input.size()) return &#123;&#125;;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</span><br><span class="line">        for(auto a:input)&#123;</span><br><span class="line">            q.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        while(k&gt;0)&#123;</span><br><span class="line">           res.push_back(q.top());</span><br><span class="line">           q.pop();</span><br><span class="line">           k--;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>最小堆</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-整数中1出现的次数</title>
    <url>/2020/01/17/%E5%89%91%E6%8C%87offer-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三篇。<br>
核心能力是基于数学知识来找数字存在的规律。<br>
这个问题给我的重要启示是将问题普遍化与自动化，是我们作为一个计算机行业从业者应该要做的事，也是让我们所有人受益无穷的事。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&amp;tqId=11184&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>求出1到13的整数中1出现的次数,并算出100到1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路1">思路1:</h3>
<p>将1-n的每个数通过取余数来计算每一位是否为1，然后找个计数器来进行统计</p>
<h3 id="思路2">思路2:</h3>
<p>通过分析每个位置上1出现的规律来进行规律性的查找。下面以数字32456然后计算百位上1的个数来进行演示。</p>
<ol>
<li>首先将原来的数据分为2部分，a= 32456/100 = 324, b=32456%100 = 56.</li>
<li>这里百位上为4，所以他有完整的33个100位1，也就是(a/10+1)个100，推广一下，我们发现其实任何大于等于2的数字都会有这个规律。</li>
<li>如果这里百位上为0.即32056，则它有完整的32个100，也就是（a/10)个100。</li>
<li>如果这里百位上位1，即32156，则他有完整的32个100，同时会有32100-32156中57个百位上的1.也就是(a/10)个100，然后加上(b+1)个1.<br>
其他位可以同理得到计算结果。从而问题得到了解决。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        // 方法1: 暴力求解。计算每一个数中每一位是不是1进行求和。</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 1;  i &lt;= n; i++)&#123;</span><br><span class="line">           int temp = i;</span><br><span class="line">            while(temp)&#123;</span><br><span class="line">                if(temp%10 == 1)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp/10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlgn),空间复杂度为O(1);</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(long i = 1; i&lt;= n; i*=10)&#123;</span><br><span class="line">            int a = n/i, b = n%i;</span><br><span class="line">            if(a%10 == 0)&#123;</span><br><span class="line">                res += (a/10)*i;</span><br><span class="line">            &#125;else if( a%10 == 1)&#123;</span><br><span class="line">                res += (a/10)*i + (b+1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res += (a/10+1)*i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(lgn),空间复杂度为O(1);<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-求1+2+……+n</title>
    <url>/2020/01/16/%E5%89%91%E6%8C%87offer-%E6%B1%821-2-%E2%80%A6%E2%80%A6-n/</url>
    <content><![CDATA[<p>本文为剑指offer系列第二篇。<br>
个人感觉属于奇淫巧技，但是是真的很巧妙，有利于打破思维定势。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&amp;tqId=11200&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）</p>
<h2 id="解题思路">解题思路</h2>
<p>思路1: 其实可以调用库函数<br>
思路2: 可以使用 &amp;&amp; 和 || 的熔断机制。<br>
思路3：使用sizeof函数和右移操作。</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="朴素思想代码">朴素思想代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        return (1+n)*n/2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路1代码">思路1代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        return fma(fma(n,n+1,0),0.5,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma" target="_blank" rel="noopener">fma</a>(x,y,z)函数作用是返回x*y+z. 我们让z为0,就变成了单纯的加法。</p>
<h3 id="思路2代码">思路2代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        int sum  = n;</span><br><span class="line">        bool b = (n&gt;0) &amp;&amp; (sum += Sum_Solution(n-1))&gt;0;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路3代码">思路3代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        char a[n][n+1];</span><br><span class="line">        return sizeof(a)&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为sizeof()函数可以用来计算对象空间大小，每个char是1个字节，所以对于大小为n*(n+1)的二维数组而言，空间就是n*(n+1). 结果右移一位等同于除以2.<br>
由此我们可以推广到其他的数据类型上，比如int,每个int是4个字节，所以要在原来的基础上右移3位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">       int a[n][n+1];</span><br><span class="line">       return sizeof(a)&gt;&gt;3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>智力题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二维数组中的查找</title>
    <url>/2020/01/16/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>本文属于剑指offer系列第一题。<br>
本题目的关键点在于找到一个非常棒的问题入手点，然后这个题目就已经解决了一半。</p>
<a id="more"></a>
<h2 id="题目描述">题目描述</h2>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="解题思路">解题思路</h2>
<p>思路1: 双层for循环，肯定能解决，但是复杂度为O(n^2),而且没有充分利用行列有序这个条件。<br>
思路2: 我们从右上角开始查找，往左下角找。<br>
如果当前位置的元素大于目标元素，那么肯定在下一行。<br>
如果当前位置的元素小于目标元素，肯定在本元素的左侧。<br>
如果当前位置的元素等于目标元素，那么返回即可。</p>
<h2 id="巧妙之处">巧妙之处</h2>
<p>题目从右上角入手开始查找元素非常有效且巧妙。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">       int i = 0;</span><br><span class="line">       int j = array[0].size()-1;</span><br><span class="line">       while(i &lt; array.size() &amp;&amp; j&gt;= 0)&#123;</span><br><span class="line">           if(array[i][j] == target)&#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;else if(array[i][j] &lt; target)&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是O(m+n)，空间复杂度O(m*n) m为行数，n为列数。<br>
以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>common-commands</title>
    <url>/2020/01/07/common-commands/</url>
    <content><![CDATA[<p>本篇文章用于记录平时常用的、可以大幅度提高效率的一些命令和快捷键，方便之后查看与使用，不定期更新。</p>
<a id="more"></a>
<h2 id="mac相关">mac相关</h2>
<h3 id="mac命令行下打开图片">mac命令行下打开图片</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open a.jpg</span><br></pre></td></tr></table></figure>
<p>打开文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open foldname</span><br></pre></td></tr></table></figure>
<p>打开当前文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open .</span><br></pre></td></tr></table></figure>
<h2 id="Chrome相关（important！！）">Chrome相关（important！！）</h2>
<h3 id="新开一个标签页">新开一个标签页</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command + T</span><br></pre></td></tr></table></figure>
<h3 id="新开一个搜索窗口">新开一个搜索窗口</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command + N //正常窗口</span><br><span class="line">command + shift + N //无痕搜索窗口</span><br></pre></td></tr></table></figure>
<h3 id="切换标签页">切换标签页</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl + tab //下一个标签页</span><br><span class="line">ctrl + shift + tab //上一个标签页</span><br></pre></td></tr></table></figure>
<h3 id="打开刚关掉的标签页">打开刚关掉的标签页</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command + shift + T</span><br></pre></td></tr></table></figure>
<h2 id="Linux相关">Linux相关</h2>
<h3 id="查看电脑核数">查看电脑核数</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo |grep &quot;processor&quot;| wc -l</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么c++比java运行的速度快</title>
    <url>/2019/12/10/%E4%B8%BA%E4%BB%80%E4%B9%88c-%E6%AF%94java%E8%BF%90%E8%A1%8C%E7%9A%84%E9%80%9F%E5%BA%A6%E5%BF%AB/</url>
    <content><![CDATA[<p>最近和同学讨论算法题目的时候，突然讲到为什么java的速度比c++慢，当时一知半解，雾里看花。<br>
于是回来之后查了一下资料，整理一下放在这里，方便以后查看。<br>
暂时理解到这个程度，如果以后有新的理解再做补充。</p>
<a id="more"></a>
<h2 id="明确原则">明确原则</h2>
<p>首先，我们要明确一个放之世界皆准的原则:</p>
<blockquote>
<p>在资源一定的情况下，鱼与熊掌不可得兼。</p>
</blockquote>
<p>在程序运行方面，也就是说效率和便捷性往往不能同时满足。</p>
<p>c++ 和java的比较就是一个很典型的例子。java的抽象层级要比c++高一点，很多情况下java语言已经替我们做出了选择（可能是考虑了全局的程序性能之后得到的最优解），所以用起来就比较方便，但是这就有可能放弃了对于某些特定问题的更优的选择（可能他们仅仅在某几类问题上性能优秀，但是全局所有问题来看不是那么理想）也就在一定程度上损失了效率。</p>
<p>比如我们在使用java语言的时候可以直接通过obj.method()这种方式进行调用，它默认传递的都是引用。但是我们如果使用的是c++，那么就需要自己来确定我们的方法参数传的是指针还是引用，根据不同的选择在方法内部也有不同的使用方式。</p>
<h2 id="原因浅析">原因浅析</h2>
<h3 id="编译过程不一样">编译过程不一样</h3>
<p>在前面我们已经介绍过c++ 的编译过程，g++编译器可以直接将我们的源码编译成为机器可以执行的二进制代码（机器指令的集合），从而直接执行。</p>
<p>而对于java语言，java编译器会将java源码解析成字节码（独立于CPU架构，cpu不认识），然后字节码会被JVM加载然后再编译成当前cpu架构所对应的二进制代码（机器指令的集合）然后再执行。</p>
<p>简而言之，java在源码与机器指令之间又加了一层字节码的处理，这样可以保证在不同的机器上运行，但是相比于c++直接编译到机器指令来讲就会慢很多。</p>
<h3 id="对象的创建不同">对象的创建不同</h3>
<p>在java中一切皆对象（这里忽略基本数据类型的情况），而对象的创建是通过new来实现的，也就是说对象本身都是保存在堆内存中的，而栈内存中仅仅保存了一个对象的引用。这样在获得对象的时候实际上可以认为是间接寻址，速度就会比较慢。</p>
<p>而在c++ 中，很多局部变量和对象的创建都是保存在栈中的，可以直接访问，所以效率就会很高。</p>
<h3 id="检查机制不同">检查机制不同</h3>
<p>java虚拟机本身在运行时会对程序进行很多的检查，比如说检查数组越界，检查类型是否错误，检查是否空指针，检查对象是否需要回收(JVM)等等，比较充分的保证了java程序的安全性和稳定性，但是也浪费了检查的时间。</p>
<p>但是在c++程序中，这些检查都是需要程序员自己进行检查判断和处理的，如果程序员不写，那就硬着头皮执行，所以效率会很高，但是安全性和稳定性会有一定的损失。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://www.iteye.com/blog/leowzy-819206" target="_blank" rel="noopener">java运行速度比C++慢的原因</a></li>
<li><a href="https://www.zhihu.com/question/22050405" target="_blank" rel="noopener">知乎-为什么说 Java 比 C / C++ 慢？</a></li>
</ol>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Why</tag>
      </tags>
  </entry>
  <entry>
    <title>make命令与MakeFile文件</title>
    <url>/2019/12/05/make%E5%91%BD%E4%BB%A4%E4%B8%8EMakeFile%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>前面三篇文章主要讲述了c++的编译过程，本篇文章主要讲述用Makefile文件来定义编译过程，用make命令来对项目进行构建，从而项目在编译过程中存在的各种依赖等可以程序化生成并保持最新版本，一次编写，永久受益。</p>
<a id="more"></a>
<h2 id="make与Makefile是什么">make与Makefile是什么</h2>
<h3 id="make命令">make命令</h3>
<p>源代码变成可执行文件的过程，叫做编译（compile）；而对一整个项目而言，先编译这个文件还是先编译另外一个文件的过程叫做构建（build），make命令是一个GNU组织提供的一个构建工具，诞生于1977年，起初主要应用于c语言的项目，但是实际上，任何只要有某个文件有变化就要重新构建的项目，就可以用make来进行构建。</p>
<h3 id="Makefile文件">Makefile文件</h3>
<p>make是一个构建的命令，而具体的规则都是写在MakeFile文件中的。</p>
<h2 id="如何编写makefile文件">如何编写makefile文件</h2>
<h3 id="概述">概述</h3>
<p>Makefile文件由一系列的规则（rules）构成，每条规则的形式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class="line">[tab] &lt;commands&gt;</span><br></pre></td></tr></table></figure>
<p>上面第一行冒号前面的部分，叫做&quot;目标&quot;（target），冒号后面的部分叫做&quot;前置条件&quot;（prerequisites）；第二行必须由一个tab键起首，后面跟着&quot;命令&quot;（commands）。</p>
<p>&quot;目标&quot;是必需的，不可省略；&quot;前置条件&quot;和&quot;命令&quot;都是可选的，但是两者之中必须至少存在一个。</p>
<p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。</p>
<h3 id="目标-target">目标(target)</h3>
<ol>
<li>目标指的是具体要生成的文件名字,也可以是文件的列表。</li>
<li>目标也可以是某个操作的名字，这称作“伪目标”（phony target）</li>
</ol>
<h3 id="前置条件-prerequisites">前置条件(prerequisites)</h3>
<ol>
<li>前置条件通常是一组文件名，中间用空格分隔。</li>
<li>前置条件指定了“目标”是否要重新构建的判断标准：只要有一个前置文件不存在，或者有过更新，那么目标就需要重新构建。</li>
</ol>
<h3 id="命令-commands">命令(commands)</h3>
<ol>
<li>命令表示如何构建或者更新目标文件，由一行或者多行的shell命令组成，他是构成“目标”的具体指令，他的运行结果通常就是生成目标文件。</li>
<li>每行命令之前必须有一个tab键。</li>
<li>需要注意，每行命令在一个单独的shell中执行，这些shell没有独立关系，如果需要，可以在换行符前加反斜杠转义。</li>
</ol>
<h2 id="如何使用make命令">如何使用make命令</h2>
<h3 id="有目标无条件">有目标无条件</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    echo &apos;this is the a.txt&apos; &gt; a.txt</span><br></pre></td></tr></table></figure>
<p>解释：目标是创建a.txt, 没有前置条件。具体的执行命令是将“this is the a.txt”这个字符串写入到a.txt中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make t.txt //执行Makefile文件  </span><br><span class="line">cat a.txt //查看a.txt文件内容，发现就是this is the a.txt。</span><br></pre></td></tr></table></figure>
<h3 id="有目标有条件">有目标有条件</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b.txt : a.txt</span><br><span class="line">    cat a.txt &gt; b.txt</span><br></pre></td></tr></table></figure>
<p>解释：目标是创建b.txt，前置条件是要有a.txt文件，具体命令是将a.txt的内容输出到b.txt中去。</p>
<h3 id="伪目标无前置条件">伪目标无前置条件</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br></pre></td></tr></table></figure>
<p>解释：目标是clean，没有前置条件，具体命令是将所有的txt文件删除。<br>
这里要说明一下，如果当前目录下也有一个叫做clean的文件，那么上述命令便不会执行了，所以我们可以声明这个命令是一个“伪目标”,也就是说变成了如下的样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br></pre></td></tr></table></figure>
<h3 id="阶段小结">阶段小结</h3>
<p>按照前面部分的介绍，我们可以得到如下内容的Makefile文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    echo &apos;this is the a.txt&apos; &gt; a.txt</span><br><span class="line"></span><br><span class="line">b.txt : a.txt</span><br><span class="line">    cat a.txt &gt; b.txt</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br></pre></td></tr></table></figure>
<p>其实这个时候我们如果直接执行make命令，那么会默认执行第一条规则，也就是说，对于上面的Makefile文件，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make a.txt</span><br></pre></td></tr></table></figure>
<p>是等价的。</p>
<h3 id="前置条件不符">前置条件不符</h3>
<p>还是在之前的Makefile的基础上继续修改。这个时候我们想创建c.txt,但是我们当前没有d.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.txt : d.txt</span><br><span class="line">    echo &apos;test no prerequists with c.txt&apos; &gt;c.txt</span><br></pre></td></tr></table></figure>
<p>这个时候执行make c.txt命令，肯定会报错，报错信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make: *** No rule to make target `d.txt&apos;, needed by `c.txt&apos;.  Stop.</span><br></pre></td></tr></table></figure>
<h2 id="MakeFile语法">MakeFile语法</h2>
<h3 id="注释">注释</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是注释</span><br><span class="line">.PHONY :print</span><br><span class="line">print :</span><br><span class="line">    # 这也是注释</span><br><span class="line">    echo &apos;hello world&apos;  #这还是注释</span><br></pre></td></tr></table></figure>
<p>通过如下命令执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make print</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  maketest git:(dev) ✗ make print</span><br><span class="line"># 这也是注释</span><br><span class="line">echo &apos;hello world&apos;  #这还是注释</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>大家会发现，print对应的命令也打印出来了，这就涉及了回声这个概念</p>
<h3 id="回声（echoing）">回声（echoing）</h3>
<p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。<br>
所以上面print执行的时候，会将命令的内容也打印出来，然后才是真正的执行结果。<br>
<strong>在命令的前面加上@，就可以关闭回声</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.PHONY :printnoecho</span><br><span class="line">printnoecho :</span><br><span class="line">    @echo &apos;hello world&apos;</span><br></pre></td></tr></table></figure>
<p>输出结果就不会有命令内容，而仅仅剩下执行结果了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  maketest git:(dev) ✗ make printnoecho</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h3 id="自定义赋值">自定义赋值</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt = &apos;hello world&apos;</span><br><span class="line">printxt:</span><br><span class="line">    @echo $(txt)</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make printxt</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h3 id="编译多个文件">编译多个文件</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALL  =  d.txt e.txt \</span><br><span class="line">f.txt</span><br><span class="line"></span><br><span class="line">all : $(ALL)</span><br><span class="line">    echo &apos;all&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d.txt : a.txt</span><br><span class="line">    cat a.txt &gt; d.txt</span><br><span class="line"></span><br><span class="line">e.txt : d.txt</span><br><span class="line">    cat d.txt &gt; e.txt</span><br><span class="line"></span><br><span class="line">f.txt : d.txt e.txt  </span><br><span class="line">    cat d.txt e.txt &gt; f.txt</span><br></pre></td></tr></table></figure>
<p>然后执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make all</span><br></pre></td></tr></table></figure>
<p>会发现d.txt,e.txt,f.txt都会得到创建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  maketest git:(dev) ✗ make all</span><br><span class="line">cat a.txt &gt; d.txt</span><br><span class="line">cat d.txt &gt; e.txt</span><br><span class="line">cat d.txt e.txt &gt; f.txt</span><br><span class="line">echo &apos;all&apos;</span><br><span class="line">all</span><br></pre></td></tr></table></figure>
<h3 id="自动变量">自动变量</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$@ : 当前目标</span><br><span class="line">$&lt; : 指代第一个前置条件</span><br><span class="line">$^ : 指代所有的前置条件</span><br></pre></td></tr></table></figure>
<p>暂时先写这些，以后遇到什么问题再做补充。</p>
<h2 id="本文的代码文件">本文的代码文件</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    echo &apos;this is the a.txt&apos; &gt; a.txt</span><br><span class="line"></span><br><span class="line">b.txt : a.txt</span><br><span class="line">    cat a.txt &gt; b.txt</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br><span class="line"></span><br><span class="line">c.txt : d.txt</span><br><span class="line">    echo &apos;test no prerequists with c.txt&apos; &gt;c.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这是注释</span><br><span class="line">.PHONY :print</span><br><span class="line">print :</span><br><span class="line">    # 这也是注释</span><br><span class="line">    echo &apos;hello world&apos;  #这还是注释</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY :printnoecho</span><br><span class="line">printnoecho :</span><br><span class="line">    @echo &apos;hello world&apos; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">compile : %.cpp</span><br><span class="line">    g++ -o %.cpp %.cpp </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">txt = &apos;hello world&apos;</span><br><span class="line">printxt:</span><br><span class="line">    @echo $(txt)</span><br><span class="line"></span><br><span class="line">printcc:</span><br><span class="line">    $(CC) -o test test.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALL  =  d.txt e.txt \</span><br><span class="line">f.txt</span><br><span class="line"></span><br><span class="line">all : $(ALL)</span><br><span class="line">    echo &apos;all&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d.txt : a.txt</span><br><span class="line">    cat a.txt &gt; d.txt</span><br><span class="line"></span><br><span class="line">e.txt : d.txt</span><br><span class="line">    cat d.txt &gt; e.txt</span><br><span class="line"></span><br><span class="line">f.txt : d.txt e.txt  </span><br><span class="line">    cat d.txt e.txt &gt; f.txt</span><br></pre></td></tr></table></figure>
<h2 id="文章参考">文章参考</h2>
<ol>
<li><a href="https://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">Make 命令教程-阮一峰</a></li>
<li><a href="https://www.cnblogs.com/wujing-hubei/p/5223113.html" target="_blank" rel="noopener">makefile文件编写</a></li>
<li><a href="https://blog.csdn.net/u014066037/article/details/54602273" target="_blank" rel="noopener">Makefile文件编写</a></li>
</ol>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>终探c++编译过程</title>
    <url>/2019/12/03/%E7%BB%88%E6%8E%A2c-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。<br>
本篇文章探究c++编译过程的第三篇，属于本系列暂时的最后一篇，总结了本次对于整个编译过程的探究结果，同时解释了动态链接和静态链接以及g++和gcc的一些区别和联系。</p>
<a id="more"></a>
<p>其实c++编译过程很复杂，一本《编译原理》让无数从业人员感到自己能力有限，我们这里介绍的仅仅是最简单的，比较概括性的内容，如果想继续深入了解可以自行去看《编译原理》书籍。</p>
<h2 id="编译过程总结">编译过程总结</h2>
<p><img src="http://q1tldblw4.bkt.clouddn.com/qiniu_kwimg20191203232929.png" alt=""><br>
我们现在应用的g++编译器其实是一个比较成熟的工具，内部细节我们不做深入探讨。但是从总体上来讲，它将整个编译过程分成了如下的四个步骤：</p>
<h3 id="预编译">预编译</h3>
<h4 id="g-执行编译">g++执行编译</h4>
<p>从源代码文件变成预处理之后的源代码文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -E helloword.cpp helloword.ii</span><br></pre></td></tr></table></figure>
<h4 id="原理解释">原理解释</h4>
<p>简单点说，就是将代码进行整合，包括宏定义，include等都替换进来，没用的东西都删掉，比如注释等。</p>
<p>详细点说<br>
预处理相当于根据预处理指令组装新的C/C++程序。经过预处理，会产生一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件，这个文件的含义同原本的文件无异，只是内容上有所不同。</p>
<ol>
<li>读取C/C++源程序，对其中的伪指令（以#开头的指令）进行处理
<ol>
<li>将所有的“#define”删除，并且展开所有的宏定义</li>
<li>处理所有的条件编译指令，如：“#if”、“#ifdef”、“#elif”、“#else”、“endif”等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。</li>
</ol>
</li>
</ol>
<p>（注意：这个过程可能是递归进行的，也就是说被包含的文件可能还包含其他文件）<br>
2. 删除所有的注释<br>
3. 添加行号和文件名标识<br>
以便于编译时编译器产生调试用的行号信息及用于编译时产生的编译错误或警告时能够显示行号<br>
4. 保留所有的#pragma编译器指令</p>
<h3 id="编译优化">编译优化</h3>
<h4 id="g-执行编译-2">g++执行编译</h4>
<p>从源代码文件变成汇编代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -S helloword.cpp helloword.s</span><br></pre></td></tr></table></figure>
<h4 id="原理解释-2">原理解释</h4>
<p>将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件。</p>
<h3 id="汇编">汇编</h3>
<h4 id="g-执行编译-3">g++执行编译</h4>
<p>从源代码文件变成对象文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -c talk.cpp -o talk.o</span><br><span class="line">g++ -c talktest.cpp -o talktest.o</span><br></pre></td></tr></table></figure>
<h4 id="原理解释-3">原理解释</h4>
<p><strong>将编译完的汇编代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。</strong></p>
<p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可</p>
<h3 id="链接">链接</h3>
<h4 id="gcc执行编译">gcc执行编译</h4>
<p>从对象文件变成可执行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ talk.o talktest.o -o talktest</span><br><span class="line">./talktest</span><br></pre></td></tr></table></figure>
<p>也可以从源代码文件变成可执行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ helloword.cpp -o helloworld</span><br><span class="line">./helloworld</span><br></pre></td></tr></table></figure>
<h4 id="原理解释-4">原理解释</h4>
<p>通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序</p>
<h2 id="关于链接过程">关于链接过程</h2>
<p>在编译器的第四步链接的时候，主要工作是将对象文件和标准库中的文件进行链接，打包成可执行文件，这个大家应该已经很清楚啦。那么怎么链接呢？</p>
<h3 id="静态链接">静态链接</h3>
<p>静态链接是直接将所需要的库都直接嵌入到我们的主程序中，然后直接打包成可执行程序。</p>
<h3 id="动态链接">动态链接</h3>
<p>在主程序中仅仅对这个库进行一次声明，等到程序执行到这个地方的时候，再去引用这个库。</p>
<h3 id="共同存在的必要性">共同存在的必要性</h3>
<p>静态库有容易使用和理解，而且也达到了代码复用的目的，那为什么我们还要有动态库呢？</p>
<ol>
<li>静态库容易造成空间浪费。</li>
<li>静态库对程序的更新、部署和发布页会带来麻烦</li>
</ol>
<p>这两个缺点也就决定了动态库存在的必要性。</p>
<ol>
<li>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。</li>
<li>动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</li>
</ol>
<h2 id="Gcc和G-区别与联系">Gcc和G++区别与联系</h2>
<p>gcc和g++都是<a href="https://en.wikipedia.org/wiki/GNU" target="_blank" rel="noopener">GNU组织</a>的编译器。<br>
1、对于.c后缀的文件，gcc把它当做是C程序；g++ 当做是C++程序；<br>
2、对于.cpp后缀的文件，gcc和g++ 都会当做c++程序。<br>
3、编译阶段，g++ 会调用gcc；<br>
4、连接阶段，通常会用g++ 来完成，这是因为gcc命令不能自动和c++程序使用的库连接</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://blog.csdn.net/wcc27857285/article/details/84945519" target="_blank" rel="noopener">C/C++ 程序编译过程详解</a></li>
<li><a href="https://blog.csdn.net/baidu_33604078/article/details/79091049" target="_blank" rel="noopener">程序编译的四个过程</a><br>
3.<a href="https://www.cnblogs.com/mickole/articles/3659112.html" target="_blank" rel="noopener">C/C++程序编译过程详解</a><br>
4.<a href="https://www.cnblogs.com/skynet/p/3372855.html" target="_blank" rel="noopener">C++静态库与动态库</a></li>
</ol>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>再探c++编译过程</title>
    <url>/2019/12/03/%E5%86%8D%E6%8E%A2c-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。<br>
本篇文章探究c++编译过程的第二篇，主要解释了第一篇中的一些现象，同时尝试编译出预处理文件、汇编文件、对象文件等编译过程中的中间产物。</p>
<a id="more"></a>
<h2 id="编译原理解释">编译原理解释</h2>
<h3 id="编译器的作用">编译器的作用</h3>
<p>编译器 g++ 通过检查命令行中指定的文件的后缀名可识别其为 C++ 源代码文件。</p>
<p>编译器默认的动作：编译源代码文件生成<strong>对象文件(object file)</strong>，将<strong>对象文件</strong>和 <strong>libstdc++ 库中的函数</strong>进行链接得到可执行程序。</p>
<h3 id="c-编程中常见文件后缀">c++编程中常见文件后缀</h3>
<table>
    <tbody>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.a</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">静态库 (archive)</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.C
        <br>.c
        <br>.cc
        <br>.cp
        <br>.cpp
        <br>.cxx
        <br>.c++</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">C++源代码（需要编译预处理）</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.h</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">C或者C++源代码头文件</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.ii</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">C++源代码（不需编译预处理）</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.o</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">对象文件</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.s</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">汇编语言代码</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.so</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">动态库</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>&lt;none&gt;</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">标准C++系统头文件</td></tr>
</tbody>
</table>
<h3 id="初探解疑">初探解疑</h3>
<ol>
<li>初探过程中，当我们直接通过如下命令编译出最后的执行文件的过程中，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure>
<p>其实是存在中间状态文件的，也就是编译过程中所说到的<strong>对象文件</strong>，查表可知应该是以.o为后缀的文件。<br>
2. 初探过程中，当我们将头文件talk.h和实现源文件talk.cpp分开之后，然后只编译测试文件talktest.cpp的时候是报错的，那么现在我们就可以理解为什么报错了，原因在于最终的可执行文件是要链接对象文件和标准库中的文件形成的，而对象文件是必须要通过cpp等c++源代码编译形成的，所以对于我们自己编写的cpp文件是一定要经过自己手动编译才能参与到后续的链接过程中的。</p>
<h2 id="再探c-编译过程">再探c++编译过程</h2>
<h3 id="生成对象文件">生成对象文件</h3>
<p>1.利用初探中写好的talk.h,talk.cpp,talktest.cpp文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.h</span><br><span class="line">*/</span><br><span class="line">class Talk&#123;</span><br><span class="line">    public:</span><br><span class="line">        void say(const char*); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.cpp</span><br><span class="line">*/</span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">void Talk::say(const char* str)&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;talk with&quot;&lt;&lt;&apos;\t&apos;&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talktest.cpp</span><br><span class="line">*/</span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Talk talk;</span><br><span class="line">    talk.say(&quot;kingwen&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>直接编译出对象文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -c talk.cpp</span><br><span class="line">g++ -c talktest.cpp</span><br></pre></td></tr></table></figure>
<p>3.查看当前文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>可以发现多了两个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">talk.o talktest.o</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>编译对象文件生成可执行文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ talk.o talktest.o -o talktest1</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>执行talktest1</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./talktest1</span><br></pre></td></tr></table></figure>
<p>结果和我们执行直接生成编译结果是一样的,结果如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">talk with   kingwen</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>对象文件输出<br>
我们在第二步中是通过<strong>gcc -c talk.cpp</strong>直接编译出了<strong>talk.o</strong>这个对象。<br>
这里会使得编译结果的默认名称和源码名称一致。但是我们其实可以自定义。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -c talk.cpp -o talker.o</span><br><span class="line">g++ -c talktest.cpp -o talkertest.o</span><br></pre></td></tr></table></figure>
<p>然后编译运行方式和前面说明的一致即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ talker.o talkertest.o -o talkertest</span><br><span class="line">./talkertest</span><br></pre></td></tr></table></figure>
<p>最后得到的结果也和之前是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">talk with   kingwen</span><br></pre></td></tr></table></figure>
<p>PS:所以如果以后在编码过程中如果碰见说缺少对象文件，那么就是对应的cpp源代码文件没有编译，我们可以通过g++命令对其进行编译即可解决问题。</p>
<h3 id="生成预处理文件">生成预处理文件</h3>
<ol>
<li>找到初探中的helloworld.cpp代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">  helloworld.cpp </span><br><span class="line">  用于测试g++编译单个源文件生成可执行程序</span><br><span class="line">*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;hello world&quot;&lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过wc命令来查看helloworld.cpp文件的行数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  compilec++ wc -l helloworld.cpp</span><br><span class="line">       8 helloworld.cpp</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>代码预处理<br>
通过如下命令会将预处理的结果在标准输出中进行输出。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -E helloworld.cpp</span><br></pre></td></tr></table></figure>
<p>当然我们也可以将结果进行输出保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -E helloworld.cpp -o helloworld.ii</span><br></pre></td></tr></table></figure>
<p>通过wc命令来查看预处理结果helloworld.ii的行数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compilec++ wc -l helloworld.ii</span><br><span class="line">  41484 helloworld.ii</span><br></pre></td></tr></table></figure>
<p>可以发现文件大小有了翻天覆地的变化，这里主要就是将头文件等引入了我们的文件中。</p>
<h3 id="生成汇编文件">生成汇编文件</h3>
<ol>
<li>同样还是之前的helloworld.cpp代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">  helloworld.cpp </span><br><span class="line">  用于测试g++编译单个源文件生成可执行程序</span><br><span class="line">*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;hello world&quot;&lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>直接编译生成汇编代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -S helloworld.cpp -o helloworld.s</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看生成的汇编代码<br>
其实可以使用cat或者head或者tail进行查看，<br>
这里我用的是sed命令查看了从1360到1372行，因为我觉得这块代码更加符合我对汇编的想象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &apos;1360,1372p&apos; helloworld.s</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compilec++ sed -n &apos;1360,1372p&apos; helloworld.s</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register %rbp</span><br><span class="line">    movl    %edi, -4(%rbp)</span><br><span class="line">    movl    %esi, -8(%rbp)</span><br><span class="line">    movl    -4(%rbp), %esi</span><br><span class="line">    cmpl    -8(%rbp), %esi</span><br><span class="line">    sete    %al</span><br><span class="line">    andb    $1, %al</span><br><span class="line">    movzbl  %al, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    retq</span><br><span class="line">    .cfi_endproc</span><br><span class="line">                                        ## -- End function</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p><a href="https://blog.csdn.net/guoxiaoqian8028/article/details/18915513" target="_blank" rel="noopener">GCC编译C++</a></p>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>初探c++编译过程</title>
    <url>/2019/12/03/%E5%88%9D%E6%8E%A2c-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。<br>
本篇文章探究c++编译过程的第一篇，主要尝试编译单个源文件和多个源文件生成可执行文件。</p>
<a id="more"></a>
<h3 id="单个源文件生成可执行程序">单个源文件生成可执行程序</h3>
<ol>
<li>编写helloworld源代码，文件后缀是cpp</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* helloworld.cpp */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;hello world&quot;&lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过gcc编译器对其进行编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ helloworld.cpp</span><br><span class="line">或者</span><br><span class="line">g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure>
<p>如果是第一条命令，g++会编译helloworld.cpp文件产生a.out文件，a.out是默认文件名；<br>
但是更多情况下我们使用g++编译文件的时候会通过-o参数来指定生成的可执行文件的文件名。比如这里生成的文件名就叫做helloworld</p>
<ol start="3">
<li>查看当前目录文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>因为执行了两次不同的编译，所以当前目录下会有三个文件，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.out  helloworld  helloworld.cpp</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>执行文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./a.out</span><br><span class="line">或者</span><br><span class="line">./helloworld</span><br></pre></td></tr></table></figure>
<p>这里两次结果是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h3 id="两个源文件生成可执行程序">两个源文件生成可执行程序</h3>
<p>这一部分我们自己编写一个头文件speak.h,然后编写一个测试文件speaktest.cpp进行编译测试。</p>
<ol>
<li>编写speak.h代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">speak.h</span><br><span class="line">用于测试g++编译多个文件形成一个可执行文件</span><br><span class="line">*/</span><br><span class="line">#ifndef __SPEAK__</span><br><span class="line">#define __SPEAK__</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Speak&#123;</span><br><span class="line">    public:</span><br><span class="line">        void sayHello(const char* );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Speak::sayHello(const char* str)&#123;</span><br><span class="line">    std::cout&lt;&lt; &quot;hello&quot; &lt;&lt;&apos;\t&apos;&lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编写speaktest.cpp代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">speaktest.cpp</span><br><span class="line">用于测试g++编译多个文件形成一个可执行文件</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &quot;speak.h&quot;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Speak speak;</span><br><span class="line">    speak.sayHello(&quot;kingwen&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>g++编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ speaktest.cpp -o speaktest</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>执行结果</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./speaktest</span><br></pre></td></tr></table></figure>
<p>结果很符合我们的预期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello   kingwen</span><br></pre></td></tr></table></figure>
<p>所以我们可以得出很明显的结论，就是我们的.h其实只要在最终的测试文件中include，不需要自己再手动编译一次，这非常符合编译原理课程中的讲述。</p>
<p>这里我们就发现一个问题，我们的speak.h头文件其实和它的实现都在同一个文件中，但是很多情况下，头文件只负责声明，具体实现是通过其他文件来实现的，如果碰到这种情况我们还可以通过只编译测试文件就能运行嘛？来测试一下。</p>
<h3 id="声明和实现分离生成可执行程序">声明和实现分离生成可执行程序</h3>
<ol>
<li>编写talk.h文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.h</span><br><span class="line">用于测试当talk的声明和实现分离，那么在测试的时候能不能只编译测试文件。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Talk&#123;</span><br><span class="line">    public:</span><br><span class="line">        void say(const char*); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编写talk.cpp文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.cpp</span><br><span class="line">用于测试当talk的声明和实现分离，那么在测试的时候能不能只编译测试文件。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">void Talk::say(const char* str)&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;talk with&quot;&lt;&lt;&apos;\t&apos;&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编写talktest.cpp文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talktest.cpp</span><br><span class="line">用于测试当talk的声明和实现分离，那么在测试的时候能不能只编译测试文件。</span><br><span class="line">*/</span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Talk talk;</span><br><span class="line">    talk.say(&quot;kingwen&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>尝试编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ talktest.cpp -o talktest</span><br></pre></td></tr></table></figure>
<p>注意，这个时候报错了！！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  compilec++ g++ talktest.cpp -o talktest</span><br><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;Talk::say(char const*)&quot;, referenced from:</span><br><span class="line">      _main in talktest-2630f3.o</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>
<p>原因其实是没有找到Talk中say方法的实现。<br>
那么我们尝试连同talk.cpp一起编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ talktest.cpp talk.cpp -o talktest</span><br></pre></td></tr></table></figure>
<p>这个时候就可以编译通过啦，而且经过我的测试中间talktest.cpp和talk.cpp的顺序交换是没有关系的。<br>
5. 执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./talktest</span><br></pre></td></tr></table></figure>
<p>结果非常符合预期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">talk with   kingwen</span><br></pre></td></tr></table></figure>
<p>由此，我们可以解释我们小节提出的疑问了，如果声明和实现不在同一个地方，那么对于实现文件是需要进行编译的，否则就会报错。</p>
<h3 id="参考">参考</h3>
<ol>
<li><a href="https://blog.csdn.net/guoxiaoqian8028/article/details/18915513" target="_blank" rel="noopener">GCC编译C++</a></li>
</ol>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>Make-MacOs-Support-NTFS</title>
    <url>/2019/12/01/Make-MacOs-Support-NTFS/</url>
    <content><![CDATA[<p>我有一个2T的硬盘，文件格式是NTFS格式的，在MAC系统上一直能读不能写，让我很苦恼，这次从网上找了一个方法而且亲测有效，所以特地记录一下。</p>
<a id="more"></a>
<h2 id="什么是NTFS">什么是<a href="https://zh.wikipedia.org/wiki/NTFS" target="_blank" rel="noopener">NTFS</a></h2>
<p>简单来讲，NTFS是微软开发的专用文件系统，Mac OS X内核能对NTFS进行有限的读操作。Linux和BSD提供自由及开放源代码的软件，可用于读写NTFS文件。</p>
<pre><code>NTFS（英语：New Technology File System），是Microsoft公司开发的专用文件系统，
从Windows NT 3.1开始成为Windows NT家族的标准文件系统。[4]
NTFS取代FAT（文件分配表）和HPFS（高性能文件系统）并进行一系列改进，例如增强对元数据的支持，
使用更高级的数据结构以提升性能、可靠性和磁盘空间利用率，并附带一系列增强功能，
如访问控制列表（ACL）和文件系统日志等。
——维基百科
</code></pre>
<h2 id="解决措施">解决措施</h2>
<h3 id="流程简介">流程简介</h3>
<ol>
<li>挂载上你的NTFS硬盘，查看硬盘名称</li>
<li>编辑/etc/fstab文件，使其支持NTFS写入</li>
<li>将/Volumes中的NTFS磁盘快捷方式到Finder</li>
</ol>
<h3 id="详细流程">详细流程</h3>
<ol>
<li>
<p>插上硬盘后，查看你的硬盘名称，这里假设名称是AngleDisk，牢记之（你的可不是这个呀！！）</p>
</li>
<li>
<p>打开Applications的Terminal, 你也可以直接spotlight输入terminal打开</p>
</li>
<li>
<p>在终端输入sudo nano /etc/fstab 敲击回车</p>
</li>
<li>
<p>现在你看到了一个编辑界面，输入LABEL=AngleDisk none ntfs rw,auto,nobrowse后，敲击回车，再Ctrl+X，再敲击Y，再敲击回车</p>
</li>
<li>
<p>此时，退出你的移动硬盘，再重新插入，你会发现磁盘没有显示再桌面或是Finder之前出现的地方，别慌</p>
</li>
<li>
<p>打开Finder，Command+Shift+G，输入框中输入/Volumes，回车，你就可以看到你的磁盘啦！是可以读写的哟，Enjoy</p>
</li>
<li>
<p>方便起见，你可以直接把磁盘拖到Finder侧边栏中，这样下次使用就不用进入到/Volumes目录打开了</p>
</li>
</ol>
<h2 id="原文地址">原文地址</h2>
<p><a href="https://blog.csdn.net/u013247765/article/details/77932144" target="_blank" rel="noopener">无需第三方软件实现Mac支持ntfs读写的最简单操作</a></p>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>MacOs</tag>
        <tag>NTFS</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-207-CourseSchedule</title>
    <url>/2019/12/01/leetcode-207-CourseSchedule/</url>
    <content><![CDATA[<p>这个是leetcode中为数不多的关于Graph的题目，判断图中是否有环，可以用BFS或者DFS两种思路进行求解。</p>
<a id="more"></a>
<h2 id="题目描述">题目描述</h2>
<p>There are a total of n courses you have to take, labeled from 0 to n-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<h2 id="Example">Example</h2>
<h3 id="Example-1">Example 1</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure>
<h3 id="Example-2">Example 2</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2, [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class="line">             also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure>
<h2 id="解题思路">解题思路</h2>
<p>BFS或者DFS</p>
<h2 id="详细解释">详细解释</h2>
<p>其实这个题目就是说对于每一个课程都有一个前置课程，然后问如果前置课程这样安排能不能成立，其实就可以抽象出查看一个图中是否有环，因为一旦有环路，那肯定是不成立的，反之，肯定成立。</p>
<h3 id="BFS思路">BFS思路</h3>
<p>我们创建一个队列，用于保存目前入度为0的点，然后我们对于每个节点都保存一个入度的值。然后从入度为0的值开始，进行遍历，对于这个点能达到的所有的点将其入度减去1，如果此时这个点入度为0，将其加入到队列中。当队列为空的时候，如果此时所有节点的入读都变成0，那么肯定没有环路，否则有环路。<br>
举例说明,假设输入是如下情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 [[1,0],[2,0],[1,2],[3,1]]</span><br></pre></td></tr></table></figure>
<p>对应的图其实就是<br>
<img src="http://q1tldblw4.bkt.clouddn.com/qiniu_kwimg20191201143417.png" alt=""></p>
<p>1.初始化队列q中元素只有0，入度数组arr=[0,2,1,1]<br>
2. 然后经过0号节点，arr变为[0,1,0,1],此时2号加入队列<br>
3. 然后处理2号节点，arr变成[0,0,0,1],此时1号加入队列<br>
4. 然后处理1号节点，arr变成[0,0,0,0] 此时3号加入队列<br>
5. 然后处理3号节点，arr变成[0,0,0,0] 此时队列为空。<br>
6. 然后判断arr数组中每个节点的入度是否是0，全为0，返回true。</p>
<h3 id="DFS思路">DFS思路</h3>
<p>DFS就是用深度优先搜索，我们对于每个节点记录一个状态，-1表示是当前节点：如果在遍历过程中发现了-1，说明又回到了自身，那就是有环路，返回flase；0是默认值，代表之前还没有访问；1表示已经访问过了。对于每一个节点都进行如此的遍历，即可得到结果。<br>
PS：要记得传引用而不要传对象本身，否则容易Time Limit Exceeded</p>
<h2 id="解题代码">解题代码</h2>
<h3 id="BFS解题代码">BFS解题代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; graph(numCourses,vector&lt;int&gt;());</span><br><span class="line">        vector&lt;int&gt; in(numCourses,0);</span><br><span class="line">        for(auto a:prerequisites)&#123;</span><br><span class="line">            graph[a[1]].push_back(a[0]);</span><br><span class="line">            in[a[0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        for(int i = 0;i&lt;in.size();i++)&#123;</span><br><span class="line">            if(in[i]==0) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            auto a = q.front(); q.pop();</span><br><span class="line">            for(int b:graph[a])&#123;</span><br><span class="line">                --in[b];</span><br><span class="line">                if(in[b]==0) q.push(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i:in)&#123;</span><br><span class="line">            if(i!=0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="DFS解题代码">DFS解题代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; graph(numCourses,vector&lt;int&gt;());</span><br><span class="line">        vector&lt;int&gt; visit(numCourses);</span><br><span class="line">        for(auto a:prerequisites)&#123;</span><br><span class="line">            graph[a[1]].push_back(a[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; numCourses; ++i)&#123;</span><br><span class="line">            if(!findSelf(graph,visit,i)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool findSelf(vector&lt;vector&lt;int&gt;&gt;&amp; graph,vector&lt;int&gt;&amp; visit,int i)&#123;</span><br><span class="line">        if(visit[i] == -1) return false;</span><br><span class="line">        if(visit[i] == 1) return true;</span><br><span class="line">        visit[i] = -1;</span><br><span class="line">        for(auto a:graph[i])&#123;</span><br><span class="line">            if(!findSelf(graph,visit,a)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i] = 1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Class-with-pointer-mString-Houjie-Bilibili</title>
    <url>/2019/11/22/Class-with-pointer-mString-Houjie-Bilibili/</url>
    <content><![CDATA[<p>在Bilibili跟着侯捷老师学C++系列第二篇，带指针的类mString类。<br>
人生得遇良师，实属大幸，侯捷老师就属于这种老师，再夸一遍！！</p>
<a id="more"></a>
<p>因为C++的效率是最高的，所以对于C++自己一定要好好掌握，个人看法，你如果能学会C++，其他语言都将不在话下。然后刚好碰到一个非常好的教程，有一位非常棒的老师-侯捷老师，有一个好的平台-Bilibili，还有非常好的训练场地——leetcode，所以此时不学什么时候学呢？</p>
<h2 id="教程">教程</h2>
<p><a href="https://www.bilibili.com/video/av19038490" target="_blank" rel="noopener">侯捷C++手把手教学(上),适合新手</a></p>
<h2 id="代码文件">代码文件</h2>
<h3 id="mstring-hpp">mstring.hpp</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef mstring_hpp</span><br><span class="line">#define mstring_hpp</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class mstring&#123;</span><br><span class="line">public:</span><br><span class="line">    mstring(const char* a = 0);</span><br><span class="line">    mstring(const mstring&amp; str);</span><br><span class="line">    mstring&amp; operator =(const mstring&amp; str);</span><br><span class="line">    ~mstring();</span><br><span class="line">    char* get_c_str() const &#123;return mdata;&#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    char* mdata;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring::mstring(const char* a)&#123;</span><br><span class="line">    if(a)&#123;</span><br><span class="line">        mdata = new char[strlen(a)+1];</span><br><span class="line">        strcpy(mdata, a);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        mdata = new char[1];</span><br><span class="line">        *mdata = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring::mstring(const mstring&amp; str)&#123;</span><br><span class="line">    mdata = new char[std::strlen(str.mdata)+1];</span><br><span class="line">    strcpy(mdata, str.mdata);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring&amp; mstring::operator=(const mstring&amp; str)&#123;</span><br><span class="line">    if(this == &amp;str)&#123;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    this-&gt;mdata = new char[strlen(str.mdata)+1];</span><br><span class="line">    strcpy(this-&gt;mdata,str.mdata);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring::~mstring()&#123;</span><br><span class="line">    delete[] mdata;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator &lt;&lt; (ostream&amp; os,const mstring&amp; str)&#123;</span><br><span class="line">    return os&lt;&lt;str.get_c_str();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif /* mstring_hpp */</span><br></pre></td></tr></table></figure>
<h3 id="mstring-cpp">mstring.cpp</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;mstring.hpp&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    mstring s1;</span><br><span class="line">    cout&lt;&lt;&quot;s1 = &quot;&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    mstring s2(&quot;hello&quot;);</span><br><span class="line">    cout&lt;&lt;&quot;s2 = &quot;&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">    s1 = s2;</span><br><span class="line">    cout&lt;&lt;&quot;s1 = &quot;&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    mstring s3(s2);</span><br><span class="line">    cout&lt;&lt;&quot;s3 = &quot;&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    mstring *p = new mstring(&quot;world&quot;);</span><br><span class="line">    cout&lt;&lt;&quot;*p = &quot;&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果">运行结果</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 = </span><br><span class="line">s2 = hello</span><br><span class="line">s1 = hello</span><br><span class="line">s3 = hello</span><br><span class="line">*p = world</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="细节剖析">细节剖析</h2>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mstring(const char* a = 0);</span><br></pre></td></tr></table></figure>
<p>构造函数的名称和类名一致，没有返回值，参数可以设置默认参数（实际实现的时候就不需要再说明默认参数了）<br>
2. 拷贝构造</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mstring(const mstring&amp; str);</span><br></pre></td></tr></table></figure>
<p>接收一个同种类型的对象作为自己的参数，然后产生一个新的对象。</p>
<p>这里要注意深复制和浅复制的区别，深复制就是会新创建一个对象，这个对象有属于自己的内存空间，只是值和原来的是一致的。浅复制是说两个对象指向同一个内存空间，所以一旦有一个更改，另一个肯定会被更改，很危险。<br>
3. 拷贝赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mstring&amp; operator =(const mstring&amp; str);</span><br></pre></td></tr></table></figure>
<p>这里首先要注意的是我们重载了运算符=，然后是当前类的方法。其次是我们传入的参数，我们不会修改，所以设置为const，是通过引用传进来的，返回值同样是一个mstring对象，我们通过引用返回。</p>
<p>对于成员函数，其实每个函数都含有一个隐藏的参数this，我们可以通过this和参数引用的地址来确定是否是自我赋值，要进行判断，否则会报错。因为具体赋值的过程是先删除本身的数据，然后创建一个能容纳str的空间的内存，然后将str内容拷贝到内存中。如果this和str指向同一个地址，那么刚开始删除掉就已经没有了，之后的创建空间就会出错。所以一定要注意这个拷贝赋值时自我赋值的问题。<br>
4. 析构函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~mstring();</span><br></pre></td></tr></table></figure>
<p>析构函数是指当对象生命周期结束之后会自动调用当前对象的析构函数，主要负责释放通过new关键字请求得到的内存空间。如果不自行解决，那么new出来的这块空间就会变成无主空间，会造成内存泄露。<br>
5. 对于一个带有指针的类，必须要有拷贝构造和拷贝赋值还有析构函数。<br>
6. 其他成员函数的编写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* get_c_str() const &#123;return mdata;&#125;</span><br></pre></td></tr></table></figure>
<p>首先这个函数可以认为是一个辅助函数，方便之后重载&lt;&lt; 符号的，因为ostream已经被重载过所以可以输出char类型的指针所指向的数据，所以我们这里单独写一个用于输出。<br>
其次要注意这个函数有个const，对于类对象本身没有更改的方法都要写上这个const。<br>
然后要注意这里的返回值类型，是一个char类型的指针。<br>
7. array new 一定要搭配一个array delete</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline</span><br><span class="line">mstring::mstring(const char* a)&#123;</span><br><span class="line">    if(a)&#123;</span><br><span class="line">        mdata = new char[strlen(a)+1];</span><br><span class="line">        strcpy(mdata, a);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        mdata = new char[1];</span><br><span class="line">        *mdata = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline</span><br><span class="line">mstring::~mstring()&#123;</span><br><span class="line">    delete[] mdata;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在构造函数中是创建了一个char类型的数组，那么在析构函数中也要以同样的方式进行释放。<br>
8. 关于栈存储<br>
Stack,是存在于作用域的一块内存空间，例如当你调用函数，函数本身就会形成一个stack来放置它所接收的参数，以及对应的返回地址。在函数本体中声明的任何变量，其所使用的内存块都会在上述stack中。当作用域结束，所有内存都会被回收，内存中的对象也就再也找不到了，所以这就是我们上一节所讲的不能返回一个local对象的引用或者指针而要直接返回他们本身。<br>
9. 关于堆存储<br>
Heap，或者叫做system heap，是指由操作系统提供的一块global的内存空间，程序可以通过new来动态分配获得若干区块。这样就需要自己来动手释放掉。<br>
10. stack object的生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> complex c1(1,2);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个大括号（作用域）中创建的对象也就是所谓的local对象，比如c1,在作用域结束的时候就会被自动清理。<br>
11. static local object的生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    static complex c2(1,2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个局部变量被static关键字修饰的时候,比如c2，它就是一个静态对象，其生命在作用域结束之后仍然存在，直到整个程序结束。<br>
12. global objects的生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">complex c3(1,2);</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局对象，写在{}之外的对象,比如c3，其生命周期是整个程序。这个经常在算法题目中出现。<br>
13. heap objects的生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    complex* p = new Complex(1,2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的p就是一个堆对象，是由动态分配生成的，在其被deleted之际才会结束。<br>
14. new关键字:先分配内存，然后调用构造函数<br>
15. delete关键字：先调用析构函数，然后再释放内存。</p>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Houjie</tag>
        <tag>Bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>Class-without-pointer-Complex-Houjie-Bilibili</title>
    <url>/2019/11/22/Class-without-pointer-Complex-Houjie-Bilibili/</url>
    <content><![CDATA[<p>在Bilibili跟着侯捷老师学C++系列第一篇，不带指针的类Complex类。<br>
人生得遇良师，实属大幸，侯捷老师就属于这种老师！！</p>
<a id="more"></a>
<p>因为C++的效率是最高的，所以对于C++自己一定要好好掌握，个人看法，你如果能学会C++，其他语言都将不在话下。然后刚好碰到一个非常好的教程，有一位非常棒的老师-侯捷老师，有一个好的平台-Bilibili，还有非常好的训练场地——leetcode，所以此时不学什么时候学呢？</p>
<h2 id="教程">教程</h2>
<p><a href="https://www.bilibili.com/video/av19038490" target="_blank" rel="noopener">侯捷C++手把手教学(上),适合新手</a></p>
<h2 id="代码文件">代码文件</h2>
<h3 id="Complex-hpp">Complex.hpp</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef Complex_hpp</span><br><span class="line">#define Complex_hpp</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Complex&#123;</span><br><span class="line">public:</span><br><span class="line">    Complex(double r = 0, double i = 0) : re(r), im(i)&#123;&#125;</span><br><span class="line">    Complex&amp; operator += (const Complex&amp;);</span><br><span class="line">    double real() const &#123;return re;&#125;</span><br><span class="line">    double imag() const &#123;return im;&#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    double re,im;</span><br><span class="line">    </span><br><span class="line">    friend Complex&amp; _doapl(Complex*, const Complex&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif /* Complex_hpp */</span><br><span class="line"></span><br><span class="line">inline Complex&amp; Complex::operator += (const Complex&amp; c)&#123;</span><br><span class="line">    return _doapl(this,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex&amp; _doapl(Complex* ths,const Complex&amp; c)&#123;</span><br><span class="line">    ths-&gt;im += c.im;</span><br><span class="line">    ths-&gt;re += c.re;</span><br><span class="line">    return *ths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double real(const Complex&amp; r)&#123;</span><br><span class="line">    return r.real();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double imag(const Complex&amp; r)&#123;</span><br><span class="line">    return r.imag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator +(const Complex&amp; r1,const Complex r2)&#123;</span><br><span class="line">    return Complex(real(r1)+real(r2), imag(r1)+imag(r2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator + (const Complex&amp; r1, double d)&#123;</span><br><span class="line">    return Complex(real(r1)+d,imag(r1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator + (double d,const Complex&amp; r1)&#123;</span><br><span class="line">    return Complex(real(r1)+d, imag(r1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os,const Complex&amp; c)&#123;</span><br><span class="line">    return os&lt;&lt;&quot;(&quot;&lt;&lt;real(c)&lt;&lt;&quot;,&quot;&lt;&lt;imag(c)&lt;&lt;&quot;)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Complex-cpp">Complex.cpp</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Complex.hpp&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Complex c1(2,3);</span><br><span class="line">    Complex c2;</span><br><span class="line">//   测试输出</span><br><span class="line">    cout&lt;&lt;c1&lt;&lt;endl;</span><br><span class="line">//    测试连续输出</span><br><span class="line">    cout&lt;&lt;c1&lt;&lt;c1&lt;&lt;endl;</span><br><span class="line">//    测试 +=</span><br><span class="line">    c1 += c2;</span><br><span class="line">    cout&lt;&lt; c1&lt;&lt;endl;</span><br><span class="line">//    测试+运算</span><br><span class="line">    cout&lt;&lt; c1+2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="result">result</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(2,3)</span><br><span class="line">(2,3)(2,3)</span><br><span class="line">(2,3)</span><br><span class="line">(4,3)</span><br></pre></td></tr></table></figure>
<h2 id="细节剖析">细节剖析</h2>
<ol>
<li>首先是要有一个防卫式声明。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef Complex_hpp</span><br><span class="line">#define Complex_hpp</span><br><span class="line"></span><br><span class="line">#endif /* Complex_hpp */</span><br></pre></td></tr></table></figure>
<p>它的作用在于当我们写的类被其他人通过导入头文件引用的时候不会重复引用。<br>
2. 类的数据不出意外都要写在private部分,也就是下面的部分。而方法一般都是写在public部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private:</span><br><span class="line">    double re,im;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>函数的要不要加const关键字,如果没有更改类属性的值，都要加上。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double real() const &#123;return re;&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>函数参数要不要加const关键字，如果我们不想这个参数在方法中被修改，那么就加上。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline double real(const Complex&amp; r)&#123;</span><br><span class="line">    return r.real();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>考虑是返回值是传值还是传引用。尽量都传引用，这样可以极大的提高效率。但是当返回的值是一个局部变量的时候，要记得通过值进行返回。</li>
<li>在重载操作符的时候，考虑返回值要考虑到会不会有多重使用，然后再考虑是要无返回还是返回一个引用值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os,const Complex&amp; c)&#123;</span><br><span class="line">    return os&lt;&lt;&quot;(&quot;&lt;&lt;real(c)&lt;&lt;&quot;,&quot;&lt;&lt;imag(c)&lt;&lt;&quot;)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>当重载运算符的时候要声明其为全局函数。</li>
<li>构造函数可以通过initialization list来进行初始化。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Complex(double r = 0, double i = 0) : re(r), im(i)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>传递者无需知道接收者是以什么形式传递数据。传递者只需要传过去即可。但是如果以reference进行传递效率会高一点。</li>
<li>友元函数可以直接访问私有数据。</li>
</ol>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Houjie</tag>
        <tag>Bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>MouseAndPoison</title>
    <url>/2019/11/17/MouseAndPoison/</url>
    <content><![CDATA[<p>最近有和同学在讨论用小老鼠来找出有毒的水瓶的问题，稍微总结一下。</p>
<a id="more"></a>
<h2 id="经典问题-16选1">经典问题. 16选1</h2>
<p>16瓶水其中有一瓶有毒，多少个小老鼠可以确定是哪瓶呢？</p>
<h3 id="1-二进制编码水瓶">1. 二进制编码水瓶</h3>
<p>对16瓶水进行二进制编码，比如第五瓶是1001，那么就给第一只和第四只小老师喝（第n只代表从低位到高位的序号），这样最终死亡的小老鼠就会拼凑出一个数字就是对应的有毒的那一瓶水。比如说第一只和第三只小老鼠死了，那么就是0101，所以也就是第五瓶水有毒。</p>
<h3 id="2-减半查找">2. 减半查找</h3>
<p>如果不考虑时间，我们可以一次一次小鼠进行测试，每次找出奇数位的小鼠，可以通过死亡与否确定是奇数还是偶数，每次都可以将等待判断的量降低为原来的一半。所以总共需要log2(n)向上取整只小鼠。</p>
<h3 id="3-上面两种方式等价。">3. 上面两种方式等价。</h3>
<p>其实上面两种方法等价，最高位是1去掉所有的一半，次高位是1去掉一半，最后就剩两个，然后再来一只小鼠就确定了。</p>
<h3 id="变体问题">变体问题</h3>
<ol>
<li>如果10-17瓶水只有一瓶水有毒，同样可以按照1的方式进行计算。</li>
<li>如果16瓶水，其中有一瓶是有毒的，要找14瓶没毒的，实际上就可以变相的理解为8瓶水中找7瓶，从而只需要三只小老鼠就可以了。</li>
<li>如果允许有两轮，或者变相说明有一个小时时间，然后小鼠喝毒药半个小时就去世，那就可以理解成为需要一轮然后处理一半的水瓶就可以了。</li>
</ol>
<p>如果以后还有再继续补充吧～</p>
]]></content>
      <categories>
        <category>思维风暴</category>
      </categories>
      <tags>
        <tag>mouse</tag>
        <tag>BrainStorm</tag>
      </tags>
  </entry>
  <entry>
    <title>kickstart-2019-H-T1-HIndex</title>
    <url>/2019/11/17/kickstart-2019-H-T1-HIndex/</url>
    <content><![CDATA[<p>2019年kickstart最后一轮，下午1点到4点。<br>
真心感慨，自己要学的东西还有很多啊，<br>
本文是第一题H-index，计算科研人员影响因子的一道题目。</p>
<a id="more"></a>
<h2 id="Problem"><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edd/00000000001a274e" target="_blank" rel="noopener">Problem</a></h2>
<p>It is important for researchers to write many high quality academic papers. Jorge has recently discovered a way to measure how impactful a researcher’s papers are: the H-index.</p>
<p>The H-index score of a researcher is the largest integer h such that the researcher has h papers with at least h citations each.</p>
<p>Jorge has written N papers in his lifetime. The i-th paper has Ai citations. The number of citations that each paper has will never change after it is written. Please help Jorge determine his H-index score after each paper he wrote.</p>
<h2 id="Input">Input</h2>
<p>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing N, the number of papers Jorge wrote.</p>
<p>The second line contains N integers. The i-th integer is Ai, the number of citations the i-th paper has.</p>
<h2 id="Output">Output</h2>
<p>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is a space-separated list of integers. The i-th integer is the H-index score after Jorge wrote his i-th paper.</p>
<h2 id="Limits">Limits</h2>
<p>Time limit: 50 seconds per test set.<br>
Memory limit: 1GB.<br>
1 ≤ T ≤ 100.<br>
1 ≤ Ai ≤ 105.</p>
<h2 id="Test-set">Test set</h2>
<h3 id="Test-set-1-Visible">Test set 1 (Visible)</h3>
<p>1 ≤ N ≤ 1000.</p>
<h3 id="Test-set-2-Hidden">Test set 2 (Hidden)</h3>
<p>1 ≤ N ≤ 105.</p>
<h2 id="Sample">Sample</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Input</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5 1 2</span><br><span class="line">6</span><br><span class="line">1 3 3 2 2 15</span><br><span class="line"></span><br><span class="line">//Output</span><br><span class="line">Case #1: 1 1 2</span><br><span class="line">Case #2: 1 1 2 2 2 3</span><br></pre></td></tr></table></figure>
<p>In Sample Case #1, Jorge wrote N = 3 papers.<br>
After the 1st paper, Jorge’s H-index score is 1, since he has 1 paper with at least 1 citation.<br>
After the 2nd paper, Jorge’s H-index score is still 1.<br>
After the 3rd paper, Jorge’s H-index score is 2, since he has 2 papers with at least 2 citations (the 1st and 3rd papers).</p>
<p>In Sample Case #2, Jorge wrote N = 6 papers.<br>
After the 1st paper, Jorge’s H-index score is 1, since he has 1 paper with at least 1 citation.<br>
After the 2nd paper, Jorge’s H-index score is still 1.<br>
After the 3rd paper, Jorge’s H-index score is 2, since he has 2 papers with at least 2 citations (the 2nd and 3rd papers).<br>
After the 4th paper, Jorge’s H-index score is still 2.<br>
After the 5th paper, Jorge’s H-index score is still 2.<br>
After the 6th paper, Jorge’s H-index score is 3, since he has 3 papers with at least 3 citations (the 2nd, 3rd and 6th papers).</p>
<h2 id="思路">思路</h2>
<h3 id="原始版思路">原始版思路</h3>
<p>因为每次写完一篇文章都要给出一个结果，所以肯定每次有新的文章都要重新计算一次，而H-index的计算方式是说至少有h篇文章，然后每篇文章都至少有h的引用数，所以我就联想到上一轮kickstart的第一题，借鉴到相同思路，我们可以通过建立一个数组，保存对应的引用数目，</p>
<p>比如有N篇文章，那么引用最高为N，方便起见，我们建立一个N+1的数组（全部初始化为0）。0索引位置不再使用。然后每个位置代表有这个引用的文章有多少篇，然后在我寻找h-index的时候，只要当前位置寻找arr[i] &gt;=i的第一个数字即可。</p>
<p>以[5,1,2]为例进行讲解。</p>
<ol>
<li>首先建立一个4(也就是3+1)个元素的数组，[0,0,0,0]</li>
<li>第一个数字为5，那么1到3号索引位置元素都+1，变成[0,1,1,1];<br>
这个时候从1号索引位置往前找第一个符合arr[i]&gt;=i的元素，也就是1；</li>
<li>第二个数字为1，那么1号索引位置元素+1，变成[0,2,1,1];<br>
这个时候从2号索引位置往前找第一个符合arr[i]&gt;=i的元素，还是1；</li>
<li>第三个数字是2，那么1号到2号索引位置元素+1，变成[0,3,2,1];<br>
这个时候从3号索引位置往前找第一个符合arr[i]&gt;=i的元素，此时变成了2；</li>
<li>所以最终的结果也就是[1,1,2]</li>
</ol>
<p>算法复杂度是O(n^2)，可以通过小case。</p>
<h3 id="升级版思路">升级版思路</h3>
<p>这个思路就会比较好，构造了一个multiset来存储元素，这里的一个好处就是他会对插入的元素进行自动排序，默认是从小到大的顺序，底层是用红黑树实现的，插入删除查找的复杂度都是lg(n)级别的。然后我们每次将读入的数字插入到multiset中，然后判断头元素（实际就是所有元素中最小的元素）是否小于容器内元素个数。如果小于，那么删除头元素。最后我们想要的h-index其实就是每一轮之后的容器内元素个数。</p>
<p>还是以[5,1,2]为例进行讲解。</p>
<ol>
<li>开始插入5，此时s={5},然后5大于当前元素个数1，所以s保持不变s={5},所以第一轮结果为1；</li>
<li>然后插入1，此时s={1,5}, 此时1是小于当前元素个数2，所以要删除第一个元素，s变成{5},所以第二轮结果为1；</li>
<li>然后插入2，此时s={2,5},然后2要等于当前元素个数，所以s保持不变，s= {2,5},所以第三轮返回结果为2.</li>
<li>所以最终结果也就是[1,1,2]</li>
</ol>
<p>算法的复杂度为O(nlgn)</p>
<h2 id="代码">代码</h2>
<h3 id="原始版">原始版</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    string res;</span><br><span class="line">    for (int t = 1; t &lt;= T; ++t) &#123;</span><br><span class="line">        int M;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;M);</span><br><span class="line">        vector&lt;int&gt; arr(M+1,0);</span><br><span class="line">  </span><br><span class="line">        int x;</span><br><span class="line">        arr[0] = 0;</span><br><span class="line">        res =&quot;&quot;;</span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">             scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">             for(int j = 1; j &lt;= x &amp;&amp; j&lt;=M ; j++)&#123;</span><br><span class="line">                  arr[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">             int k = i;</span><br><span class="line">             while(k&gt;0)&#123;</span><br><span class="line">                 if(arr[k] &gt;= k)&#123;</span><br><span class="line">                     res  += &quot; &quot;+to_string(k);</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 k--;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Case #%d: %s \n&quot;, t, res.c_str());</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="升级版">升级版</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    string res;</span><br><span class="line">    for (int t = 1; t &lt;= T; ++t) &#123;</span><br><span class="line">        int M;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;M);</span><br><span class="line">        int x;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        multiset&lt;int&gt; aset;</span><br><span class="line">        for(int i = 0;i&lt;M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">            aset.insert(x);</span><br><span class="line">            int b = *aset.begin();</span><br><span class="line">            if(b &lt; aset.size())&#123;</span><br><span class="line">                aset.erase(aset.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            res += &quot; &quot;+to_string(aset.size());</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %s \n&quot;, t, res.c_str());</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反思">反思</h2>
<ol>
<li>想了一下这个题目和之前G轮的第一题<a href="http://kingwen.cn/2019/10/22/kickstart-2019-G-T1-BookReading/" target="_blank" rel="noopener">BookReading</a>有什么不同，结论是对于bookreading来说，首先是把所有的结果都统计一遍之后，然后所有的测试用例都只需要访问之前的结果就可以了（用一个数组来表示每页书的情况，然后读取对应因子的倍数得到相应的结果，其实就是上面链接中的动态规划第一版）从而可以节省大量的时间。但是本题目并不是这样子，本题目对于每次的有一个新的数值输入，都会进行新一轮的结果运算，所以如果我们再依次的去保存每一个位置的结果，尤其是通过对数组中元素依次加1的方式实现，复杂度必然会很高，现在想想的话，其实就比每次都完全的遍历一遍（每一次都从index开始找，看看paper数组中元素个数有没有大于index，找到第一个复合条件的即可,总的时间复杂度为O(n^3)）好那么一点。然后考虑到我们其实想要的结果是数量，所以就可以非常巧妙的利用一些数据结构，上面的测试用例用的是multiset，其实用最小堆，用unordered_map都可以实现，重点是保证内部元素有序，从而可以利用容器中的数量来变相的表示我们想要的结果。</li>
<li>以后要注意很多有用的数据结构的使用方法，比如本次使用的就是multiset这个数据结构，有机会再去看看其内部实现，首先要知道才能在真正要使用的时候想到它。</li>
<li>题目做的还是太少了，见识太少了，以后还是要坚持刷题啊，见多识广才能见怪不怪。</li>
<li>看人家的好的解题思路真的是赏心悦目，倍感舒适啊。</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
        <tag>multiset</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-861-ScoreAfterFlippingMatrix</title>
    <url>/2019/11/13/leetcode-861-ScoreAfterFlippingMatrix/</url>
    <content><![CDATA[<p>本题目和之前的kickstart的G轮的第二题有一点类似。<br>
为了保证最后的数值最大，在保证最高位是1的基础上，保证之后的每一列尽可能有更多的1，非常巧妙也非常实用。</p>
<a id="more"></a>
<h2 id="题目描述">题目描述</h2>
<p>We have a two dimensional matrix A where each value is 0 or 1.</p>
<p>A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.</p>
<p>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.</p>
<p>Return the highest possible score.</p>
<h2 id="Example">Example</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class="line">Output: 39</span><br></pre></td></tr></table></figure>
<p>Explanation:<br>
Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].<br>
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</p>
<p>Note:<br>
1 &lt;= A.length &lt;= 20<br>
1 &lt;= A[0].length &lt;= 20<br>
A[i][j] is 0 or 1.</p>
<h2 id="解题思路">解题思路</h2>
<p>贪心算法</p>
<h2 id="详细解释">详细解释</h2>
<p>我们会发现，在二进制串中，即使从次高位到最低位全部都是1也比最高位是1要小，所以为了保证最后形成的二进制串最大，必然每一行的第一位一定是1，然后对于从第二列开始之后的每一列，要尽可能有更多的1。</p>
<h2 id="巧妙之处">巧妙之处</h2>
<ol>
<li>为了保证最后形成的二进制的数字最大，我们要保证最高位是1，</li>
<li>非常巧妙的用了移位来进行二进制的乘法运算，比如说</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&lt;&lt;2</span><br></pre></td></tr></table></figure>
<p>实际上就变成了0b100(二进制的100)，也就是从1变成了4，相当于乘上了2的2次方。</p>
<ol start="3">
<li>在统计每一列0和1数目的时候也没有真的将数字进行一一遍历进行计算，而是通过是否和第一位数字相同来进行判断，原因是进行行变化之后，其实每个数字和本行的第一个数字的相同与否并没有发生变化，而我们为了让最终数值最大所以保证了每行的第一个数字都必须是1，从而通过与1的相同与否我们判定出每一列的0和1的个数，进而让多的数是1可以保证本列最后的数值也会是最大的。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int matrixScore(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;</span><br><span class="line">        int m = A.size();</span><br><span class="line">        int n = A[0].size();</span><br><span class="line">        int res = m*(1&lt;&lt;(n-1));</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; m;j++)&#123;</span><br><span class="line">                 cnt += (A[j][0]==A[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res += max(cnt,m-cnt)*(1&lt;&lt;(n-1-i));</span><br><span class="line">            cnt = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-765-CouplesHoldingHands</title>
    <url>/2019/11/13/leetcode-765-CouplesHoldingHands/</url>
    <content><![CDATA[<p>情侣换座位手牵手的题目。<br>
思想有点像打气球那个题目：处理好当下的问题，慢慢往后遍历，以后的问题也会变得很顺利，回头还会发现这其实就是最好的方法。</p>
<a id="more"></a>
<h2 id="题目描述">题目描述</h2>
<p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.</p>
<p>The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).</p>
<p>The couples’ initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.</p>
<h2 id="Example">Example</h2>
<h3 id="Example-1">Example 1</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: row = [0, 2, 1, 3]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Explanation: We only need to swap the second (row[1]) and third (row[2]) person.</p>
<h3 id="Example-2">Example 2</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: row = [3, 2, 0, 1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>Explanation: All couples are already seated side by side.</p>
<h2 id="解题思路">解题思路</h2>
<p>贪心算法。</p>
<h2 id="详细解释">详细解释</h2>
<p>如果我们仔细看就会发现，其实我们在判断的时候只要确定了两个数中的一个，那么另外一个数是多少其实就是已经确定好了的，然后我们将这个数本身所在的位置替换掉就可以了。比如说下面的例子，第一个元素是5，那么第二个元素必然是6，我们只要找到6，然后将6本身所在的位置的数字替换成第二个元素本身的元素4就可以了。<br>
以题目中的某个用例来进行说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始数组：[5,6,4,0,2,1,9,3,8,7,10,11]</span><br><span class="line">i= 0: 5 4   6   0   2   1   9   3   8   7   10  11  </span><br><span class="line">i= 2: 5 4   6   7   2   1   9   3   8   0   10  11  </span><br><span class="line">i= 4: 5 4   6   7   2   3   9   1   8   0   10  11  </span><br><span class="line">i= 6: 5 4   6   7   2   3   9   8   1   0   10  11  </span><br><span class="line">i= 8: 5 4   6   7   2   3   9   8   1   0   10  11  </span><br><span class="line">i=10: 5 4   6   7   2   3   9   8   1   0   10  11</span><br></pre></td></tr></table></figure>
<h2 id="巧妙之处">巧妙之处</h2>
<ol>
<li>大道至简，大智若愚。从头开始，每次都做好当前元素的判断，那么后面的元素都会依次的处理好。</li>
<li>对于当前位置要进行奇偶判断，因为不确定配偶的左右情况，所以要自行判断。</li>
<li>要会使用stl中的各种比较巧妙的方法，比如本题目中用到的find和distance。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSwapsCouples(vector&lt;int&gt;&amp; row) &#123;</span><br><span class="line">        if(row.size() &lt;=  2) return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0; i &lt; row.size(); i += 2)&#123;</span><br><span class="line">            if(row[i]%2 == 0)&#123;</span><br><span class="line">                if(row[i+1] == row[i]+1)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    auto a = find(row.begin(),row.end(),row[i]+1);</span><br><span class="line">                    int index = distance(row.begin(),a);</span><br><span class="line">                    row[index] = row[i+1];</span><br><span class="line">                    row[i+1] = row[i]+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(row[i+1] == row[i]-1)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    auto a = find(row.begin(),row.end(),row[i]-1);</span><br><span class="line">                    int index = distance(row.begin(),a);</span><br><span class="line">                    row[index] = row[i+1];</span><br><span class="line">                    row[i+1] = row[i]-1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-452-MinimumNumberOfArrowsToBurstBalloons</title>
    <url>/2019/11/12/leetcode-452-MinimumNumberOfArrowsToBurstBalloons/</url>
    <content><![CDATA[<p>射箭，问射穿所有气球最少射几箭。<br>
抽象出来之后，其实也是区间类型的题目。只是这次的排序方式相比与之前发生了点变化。</p>
<a id="more"></a>
<h2 id="题目描述">题目描述</h2>
<p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.</p>
<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p>
<h2 id="Example">Example</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>Explanation:<br>
One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).</p>
<h2 id="解题思路">解题思路</h2>
<p>贪心算法</p>
<h2 id="详细解释">详细解释</h2>
<p>射气球，总的来看，其实第一支箭一定会射在第一个气球的范围之内，比如说[1,6]，而第二支箭一定是要射在第一个[1,6]覆盖不到的第一个气球的区间之内的。所以当我们按照他们的区间后端进行排序之后，就会很容易找到第一个不重合的气球，每次遇到一个与之前不重合的气球，就射一箭，从而可以实现最优解。</p>
<h2 id="巧妙之处">巧妙之处</h2>
<ol>
<li>之前的排序其实都是按照有序对的第一个元素进行排序，然后本题目是按照第二个元素排序，就可以使得题目变得非常的简单有效。</li>
<li>复习之前的lambda表达式的用法。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        if(points.empty()) return 0;</span><br><span class="line">        sort(points.begin(), points.end(),[](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">            return (a[1] &lt; b[1]);</span><br><span class="line">        &#125;);</span><br><span class="line">        int res = 1;</span><br><span class="line">        int end = points[0][1];</span><br><span class="line">        for(int i = 1; i &lt;  points.size(); i++)&#123;</span><br><span class="line">            if(points[i][0] &gt; end)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                end = points[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-435-Non-overlapping-Intervals</title>
    <url>/2019/11/12/leetcode-435-Non-overlapping-Intervals/</url>
    <content><![CDATA[<p>非重复区间的一个题目，思路比较清晰,感觉和406题有点异曲同工之妙。</p>
<a id="more"></a>
<h2 id="题目描述">题目描述</h2>
<p>Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>
<h2 id="Example">Example</h2>
<h3 id="Example-1">Example 1:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.</p>
<h3 id="Example-2">Example 2:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,2],[1,2],[1,2]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.</p>
<h3 id="Example-3">Example 3:</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,2],[2,3]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>Explanation: You don’t need to remove any of the intervals since they’re already non-overlapping.</p>
<h2 id="解题思路">解题思路</h2>
<p>贪心算法</p>
<h2 id="巧妙之处">巧妙之处</h2>
<p>要记得按照从小到大的顺序进行排序,然后看后一个区间的头是否在前一个区间内，如果没有，那么不用删，如果在，那么肯定要删一个。要么删除前面那个区间，要么删除后面那个区间。比如说[1,3]和[2,4],那么因为2在[1,3]内，所以这个时候肯定要删除[2,4],因为[2,4]在[1,3]更加靠后的位置。但是如果前面是[1,10],然后后面有[2,3]和[4,5]这种情况最好是删除第一个[1,10]，因为[1,10]包含的区间更加靠后。</p>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if(intervals.empty()) return 0;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">       </span><br><span class="line">        int res = 0;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        for(auto p : intervals)&#123;</span><br><span class="line">            if( temp.empty() || p[0] &gt;= temp[1])&#123;</span><br><span class="line">                temp = p; </span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res++;</span><br><span class="line">                temp = p[1] &lt; temp[1]? p:temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-406-QueueReconstructionbyHeight</title>
    <url>/2019/11/11/leetcode-406-QueueReconstructionbyHeight/</url>
    <content><![CDATA[<p>这道题目不是很难，但是思路也很好玩.<br>
通过这道题，我们还可以顺便掌握c++11中刚刚引入的lambda表达式，非常棒！</p>
<a id="more"></a>
<h2 id="题目描述">题目描述</h2>
<p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.</p>
<p>Note:<br>
The number of people is less than 1,100.</p>
<h3 id="sample">sample</h3>
<p>Input:<br>
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</p>
<p>Output:<br>
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p>
<h2 id="解题思路">解题思路</h2>
<p>贪心算法。</p>
<h2 id="详细解释">详细解释</h2>
<p>最开始先排序，按照如下规则进行排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果第一个元素不等，那么大的在前。</span><br><span class="line">如果第一个元素相等，那么第二个元素小的在前。</span><br></pre></td></tr></table></figure>
<p>所以变化如下。</p>
<ol>
<li>初始状态：[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</li>
<li>排序之后：[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</li>
</ol>
<p>接下来从第二个元素开始插入，按照如下规则进行排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将两个数构成的数组插入到数组中第二个数的位置。</span><br><span class="line">如将[6,1]插入到1号位置，将[5,2]插入到2号位置，注意这个地方要从前往后一次的进行插入。</span><br></pre></td></tr></table></figure>
<p>插入之后的变化依次如下,这里可以从第二个元素开始进行判断</p>
<ol start="3">
<li>插入[7,1]元素：[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</li>
<li>插入[6,1]元素：[[7,0], [6,1], [7,1], [5,0], [5,2], [4,4]]</li>
<li>插入[5,0]元素：[[5,0], [7,0], [6,1], [7,1], [5,2], [4,4]]</li>
<li>插入[5,2]元素：[[5,0], [7,0], [5,2], [6,1], [7,1], [4,4]]</li>
<li>插入[4,4]元素：[[5,0], [7,0], [5,2], [6,1], [4,4]，[7,1]]</li>
</ol>
<h2 id="巧妙之处">巧妙之处</h2>
<ol>
<li>要学会使用lambda表达式，也就是如下的代码。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort(people.begin(), people.end(),[](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">                 return ((a[0] &gt; b[0]) ||(a[0] == b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>如果不使用lambda表达式那么就需要写成如下模样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt; b)&#123;</span><br><span class="line">    return ((a[0] &gt; b[0]) ||(a[0] == b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">&#125;</span><br><span class="line"># 然后调用的时候如下</span><br><span class="line">sort(people.begin(),people.end(),cmp);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>发现排序之后整个vector可以插入的位置刚刚好是vector中第二个元素的位置。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<h3 id="原始代码">原始代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(),</span><br><span class="line">             [](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">                 return ((a[0] &gt; b[0]) ||(a[0] == b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">             &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; people.size(); i++ )&#123;</span><br><span class="line">            auto p = people[i]; </span><br><span class="line">            if(p[1] != i)&#123;</span><br><span class="line">                people.erase(people.begin()+i);</span><br><span class="line">                people.insert(people.begin() + p[1],p);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return people;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="升级代码">升级代码</h3>
<p>上面的那种方法速度比较满，原因在于是在原数组上进行插入同时还要进行删除操作，而如果我们直接新建一个vector来保存结果，那么就只需要插入就可以了，然后速度会有很大的提升。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">        return (a[0] &gt; b[0] ||(a[0]==b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(),cmp);</span><br><span class="line">        </span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; ans;</span><br><span class="line">        for(int i = 0; i &lt; people.size(); i++ )&#123;</span><br><span class="line">            auto p = people[i]; </span><br><span class="line">            ans.insert(ans.begin()+p[1],p);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="再次升级代码">再次升级代码</h3>
<p>为了代码好看，可以再次升级代码，使用增强的for循环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">        return (a[0] &gt; b[0] ||(a[0]==b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(),cmp);</span><br><span class="line">        </span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; ans;</span><br><span class="line">        for(auto p:people)&#123;</span><br><span class="line">            ans.insert(ans.begin()+p[1],p);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束。</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>how-to-save-pdf-images</title>
    <url>/2019/11/11/how-to-save-pdf-images/</url>
    <content><![CDATA[<p>本来想查一下如何写程序来提取pdf中的图片来着，然后发现可以用ps来实现，然后就先记录一下。</p>
<a id="more"></a>
<h2 id="通过PhotoShop进行保存">通过PhotoShop进行保存</h2>
<ol>
<li>打开ps</li>
<li>选择ps的菜单选项 <strong>文件</strong>-&gt;<strong>打开</strong>（或者直接快捷键ctrl+o）打开想打开的pdf文件</li>
<li>在打开pdf选项页面的时候，注意选择<strong>图像</strong>，然后选择要打开的图片（可以通过按住shift进行多选），然后点击确定即可。如下图所示。<br>
<img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191111135210.png" alt=""></li>
<li>在图片页面进行保存操作，(也可以使用快捷键ctrl+s)，注意保存格式选择jpeg，重命名，选择保存地址，然后确定即可。</li>
</ol>
<h2 id="截图保存">截图保存</h2>
<ol>
<li>平时的微信和QQ都是有默认的截图功能的，可以直接截图保存，以微信来举例，通过查看设置中的快捷键选项可以查看如何进行快速截图。<br>
<img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191111135655.png" alt=""><br>
啊，这篇文章好水啊，哗哗哗～</li>
</ol>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>PDF</tag>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-330-PatchingArray</title>
    <url>/2019/11/09/leetcode-330-PatchingArray/</url>
    <content><![CDATA[<p>今天周六，好好做个题，明天就可以心安理得的出去玩啦！<br>
然后就碰见了这个解题方法特别让人觉得奇妙的题目，算法这个东西实在是太神奇了。</p>
<a id="more"></a>
<h2 id="题目描述">题目描述</h2>
<p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p>
<h3 id="Example-1">Example 1:</h3>
<p>Input: nums = [1,3], n = 6<br>
Output: 1<br>
Explanation:<br>
Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.<br>
Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].<br>
Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].<br>
So we only need 1 patch.</p>
<h3 id="Example-2">Example 2:</h3>
<p>Input: nums = [1,5,10], n = 20<br>
Output: 2<br>
Explanation: The two patches can be [2, 4].</p>
<h3 id="Example-3">Example 3:</h3>
<p>Input: nums = [1,2,2], n = 5<br>
Output: 0</p>
<h2 id="解题思路">解题思路</h2>
<p>贪心</p>
<h2 id="巧妙之处">巧妙之处</h2>
<p>构造了一个miss缺失值，表示不能覆盖的最小值。最开始表示为1，表示此时不能表示范围为[0,1),然后去依次找数组中的值（要注意数组中的数据是排好序的，所以才可以这么用！），如果缺失值小于数组中的值，那么肯定要添加数，如果缺失值要是大于数组中的值，那么那么最小缺失值可以得到更新。最后如果最小缺失值大于n，那么就说明已经完成要求了。</p>
<h2 id="举个例子">举个例子</h2>
<p>以sample2也就是nums = [1,5,10], n=20举例来讲</p>
<ol>
<li>初始化的时候，数组索引index = 0，最小缺失值miss为1，res为0；</li>
<li>此时miss&lt;=20成立，没有覆盖到[1,n]的范围，所以进入循环判断，此时nums[0] = 1&lt;=miss 而且index没有超出数组范围，所以miss会更新，加上当前数组索引位置，也就是说miss = 2，表示此时可以表示范围为[0,2)啦。</li>
<li>然后miss此时仍然不能表示n，继续往后走，此时nums[1] = 5, 是大于miss的，也就是说此时我们最多表示到1，但是你突然来了个5，那我[2,4]的数据怎么办，就只能自己往里添加啦，所以此时为了尽可能表示的数字变得更大，所以此时加上miss本身这个数，从而就可以表示  [0，miss+miss)的数字了，所以此时添加一个2，res在原来的基础上+1变为1，miss也就变成了4；</li>
<li>[0,4)依然不能表示[0,n],所以还是要继续判断，此时miss仍然小于nums[1],所以我仍然不能用nums中的数字来表示4这个数，所以继续向数组中添加4,然后此时可表示范围变成了[0,8),res+1变成2，添加了4这个数字。</li>
<li>[0,8)仍然表示不了[0,n],所以仍然没有结束，此时的miss大于nums[1],也就是miss&gt;5成立，所以此时nums到索引1然后再加上添加的元素可以表示数的范围就变成了[0,13).</li>
<li>[0.13)仍然表示不了[0,20]，所以继续，此时miss大于nums[2],所以如果nums中从0到索引2的所有数字加上之前添加的数字可以表示的数字范围就变成了[0,23).</li>
<li>[0.23)是可以表示[0,20]的，所以结束，最终结果需要添加两个数，一个2，一个4即可。<br>
太神奇了。</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:    </span><br><span class="line">    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;</span><br><span class="line">        int res  = 0;</span><br><span class="line">        long miss = 1, i = 0;</span><br><span class="line">        while(miss &lt;= n)&#123;</span><br><span class="line">            if(i&lt;nums.size() &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">                miss += nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                miss += miss;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>create-my-leetcode-artical-template</title>
    <url>/2019/11/09/create-my-leetcode-artical-template/</url>
    <content><![CDATA[<p>在我每次写leetcode解题文章的时候，经常需要搞排版信息，一次两次还好，但是次数多了就会比较烦。那么我们能不能自定义一个属于自己的leetcode文章模版呢？当然可以！于是就有了本篇文章。</p>
<a id="more"></a>
<h2 id="原理">原理</h2>
<h3 id="从创建文章说起">从创建文章说起</h3>
<p>我们在使用如下命令创建文章的时候，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new title</span><br></pre></td></tr></table></figure>
<p>实际上我们使用的是如下的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post title</span><br></pre></td></tr></table></figure>
<p>上面的命令是这个命令的缩写形式而已，因为一般搭建都不太会创建草稿（draft）或者页面（page），大家都是创建文章，它太常用了，所以就被设置成了默认选项。</p>
<h3 id="真实的创建命令">真实的创建命令</h3>
<p>那么真实使用的创建命令是什么呢？其实是下面这个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>根据<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">官方文档</a>显示，hexo默认的layout有三种，分别是post，draft，page，他们都有自己的默认样式，他们文件本身都在scaffolds目录下面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog ls -l scaffolds </span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 liqingwen  staff  33 10 18 21:52 draft.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  44 10 18 21:52 page.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  76 10 21 16:48 post.md</span><br></pre></td></tr></table></figure>
<p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，所以我们要想创建自己的模版，只要在这里面创建一个leetcode模板即可，然后以后就可以通过如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new leetcode leetcode-number-nanme</span><br></pre></td></tr></table></figure>
<p>来创建符合对应布局的文章啦。</p>
<h2 id="动手">动手</h2>
<ol>
<li>先查看模版中的文件有哪些</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog ls -l scaffolds </span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 liqingwen  staff  33 10 18 21:52 draft.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  44 10 18 21:52 page.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  76 10 21 16:48 post.md</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看我们常用的post模板中的内容，然后我们照着这个改写就可以啦。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 查看模版中内容</span><br><span class="line">➜  blog cat scaffolds/post.md </span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- tag1</span><br><span class="line">categories:</span><br><span class="line">- cat1</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>复制一份post，重命名为leetcode，然后将我们想要的东西都加进去，然后保存即可。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog cd scaffolds </span><br><span class="line">➜  scaffolds cp post.md leetcode.md</span><br><span class="line">➜  scaffolds ls</span><br><span class="line">draft.md    leetcode.md page.md     post.md</span><br><span class="line"></span><br><span class="line"># 注意这里我使用的是sublime编辑器，然后在文档中添加的内容已经通过后面的cat输出了，大家可以直接赋值。</span><br><span class="line">➜  scaffolds subl leetcode.md </span><br><span class="line"></span><br><span class="line">➜  scaffolds ls</span><br><span class="line">draft.md    leetcode.md page.md     post.md</span><br><span class="line">➜  scaffolds cat leetcode.md </span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- leetcode</span><br><span class="line">- hard,medium,easy</span><br><span class="line">- Greedy, DP, String </span><br><span class="line">categories:</span><br><span class="line">- 算法训练</span><br><span class="line">---</span><br><span class="line">摘要内容</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line">### sample1</span><br><span class="line">## 解题思路</span><br><span class="line">## 巧妙之处</span><br><span class="line">## 解题代码</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>尝试使用leetcode模版</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  scaffolds cd ..</span><br><span class="line">➜  blog hexo new leetcode &quot;leetcode-406-QueueReconstructionbyHeight&quot;   </span><br><span class="line">INFO  Created: ~/workplace/blog/source/_posts/leetcode-406-QueueReconstructionbyHeight.md</span><br><span class="line">➜  blog subl  source/_posts/leetcode-406-QueueReconstructionbyHeight.md</span><br></pre></td></tr></table></figure>
<p>大功告成，于是就可以可以很开心的写文章啦。</p>
<ol start="5">
<li>2019-11-12更新
<ol>
<li>为了更加的解释算法过程，特地添加了详细解释部分。</li>
<li>为了更好的体现算法的演进，特地添加了算法升级部分。<br>
升级之后结果如下。</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- leetcode</span><br><span class="line">- hard</span><br><span class="line">- medium</span><br><span class="line">- easy</span><br><span class="line">- Greedy;</span><br><span class="line">- DP</span><br><span class="line">- String </span><br><span class="line">categories:</span><br><span class="line">- 算法训练</span><br><span class="line">---</span><br><span class="line">摘要内容</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line">### Sample</span><br><span class="line">## 解题思路</span><br><span class="line">## 详细解释</span><br><span class="line">## 巧妙之处</span><br><span class="line">## 解题代码</span><br><span class="line">### 原始代码</span><br><span class="line">### 升级代码</span><br><span class="line">以上，本题结束！</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-67-AddBinary</title>
    <url>/2019/11/08/leetcode-67-AddBinary/</url>
    <content><![CDATA[<p>今天晚上总结了一下c++中string的常用的属性和方法，一时手痒，所以就找了个题目练练手，记录一下。</p>
<a id="more"></a>
<h2 id="题目描述">题目描述</h2>
<p>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both non-empty and contains only characters 1 or 0.</p>
<h3 id="Example-1">Example 1</h3>
<p>Input: a = “11”, b = “1”<br>
Output: “100”</p>
<h3 id="Example-2">Example 2</h3>
<p>Input: a = “1010”, b = “1011”<br>
Output: “10101”</p>
<h2 id="题目思路">题目思路</h2>
<p>第一反应其实和两个数相加的那个题目类似，只是这里需要反向遍历即可。<br>
这里的一个比较好的技巧就是学会补零。比如说1和1001进行相加，很明显，结果是1010。计算结果可以将1补充为0001，这样就可以数据对齐，然后就可以方便计算而不容易出现空指针了。</p>
<h2 id="题目代码">题目代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addBinary(string a, string b) &#123;</span><br><span class="line">        int alen = a.size();</span><br><span class="line">        int blen = b.size();</span><br><span class="line">        int mlen = max(alen, blen);</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        for(int i = 0; i &lt; mlen; i++)&#123;</span><br><span class="line">            int tempa = alen&gt;i?a[alen-i-1]-&apos;0&apos;:0;</span><br><span class="line">            int tempb = blen&gt;i?b[blen-i-1]-&apos;0&apos;:0;</span><br><span class="line">            int tres = tempa+tempb+carry;</span><br><span class="line">            if(tres == 0)&#123;</span><br><span class="line">                res.insert(0,1,&apos;0&apos;);</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else if(tres == 1)&#123;</span><br><span class="line">                res.insert(0,1,&apos;1&apos;);</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else if(tres == 2)&#123;</span><br><span class="line">                res.insert(0,1,&apos;0&apos;);</span><br><span class="line">                carry = 1;</span><br><span class="line">            &#125;else if(tres == 3)&#123;</span><br><span class="line">                res.insert(0,1,&apos;1&apos;);</span><br><span class="line">                carry = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry == 1)&#123;</span><br><span class="line">            res.insert(0,1,&apos;1&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-72-EditDistance</title>
    <url>/2019/10/24/leetcode-72-EditDistance/</url>
    <content><![CDATA[<p>编辑距离是一个非常经典的动态规划的题目，之前搞懂过，但是总是会忘，所以又搞了一遍，顺便做个笔记。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">题目描述</a></h2>
<p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following 3 operations permitted on a word:</p>
<ol>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>
<h2 id="题目解读">题目解读</h2>
<p>就是求两个字符串的最小编辑距离，也就是计算word1最少可以经过多少次变化(插入，删除，替换)可以变成word2。</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="动态规划的具体思路">动态规划的具体思路</h3>
<ol>
<li>dp[i][j]表示word1的[0,i)变成word2的[0,j)位需要多少次变化。</li>
<li>对于第0行，dp[0][i] = i for 0&lt;= i &lt;= len2; (len2是word2的字符串长度)</li>
<li>对于第0列，dp[i][0] = i for 0=&lt; i &lt;= len1; (len1是word1的字符串长度)</li>
<li>如果最后一位相同，则arr[i][j] = arr[i-1][j-1]</li>
<li>若是判断的最后一位不同，则arr[i][j] = min(arr[i-1][j]+1, arr[i][j-1]+1 ,arr[i-1][j-1]+1)</li>
<li>最后返回arr[len1][len2]</li>
</ol>
<h3 id="细节剖析">细节剖析</h3>
<p>这里解释一下第4步，也是看了好久才明白的。</p>
<p>下面以word1=“abb”,word2=&quot;ac&quot;为例。</p>
<ol>
<li>首先明确一下问题：我们现在要求的是abb需要多少步会变到ac，而假设我们已经知道了ab变ac，abb变a，ab变a三种情况，我们只需要现在的情况变到之前已知的情况就解决了。</li>
<li>假设abb-&gt;ac是从ab-&gt;ac变过来的，那么我们只要将abb去掉最后一个b就可以，剩下的就是要考虑ab如何变成ac了。也就是arr[i][j]=arr[i-1][j]+1;</li>
<li>假设abb-&gt;ac是从abb-&gt;a变过来的，那么我们只要在abb后面插入一个c就可以实现最后一位的匹配，剩下的就是考虑abb如何变成a了。也就是arr[i][j] = arr[i][j-1]+1;</li>
<li>假设abb-&gt;ac是从ab-&gt;a变过来的，那么我们只要将abb的最后一位变成c，剩下的就是考虑如何将ab变成a了。也就是arr[i][j]=arr[i-1][j-1]+1;</li>
<li>最后我们选一个从三种方式中修改次数最小的一个就可以了</li>
</ol>
<h2 id="解题代码">解题代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        int len1 = word1.length();</span><br><span class="line">        int len2 = word2.length();</span><br><span class="line">        </span><br><span class="line">        int arr[len1+1][len2+1];</span><br><span class="line">        memset(arr,0,sizeof arr);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;= len1; i++)&#123;</span><br><span class="line">            arr[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;= len2; i++)&#123;</span><br><span class="line">            arr[0][i] = i;</span><br><span class="line">        &#125;      </span><br><span class="line">         for(int i = 1; i &lt;= len1; i++)&#123;</span><br><span class="line">             for(int j = 1;j &lt;= len2; j++)&#123;</span><br><span class="line">                 if(word1[i-1]==word2[j-1])&#123;</span><br><span class="line">                     arr[i][j] = arr[i-1][j-1];</span><br><span class="line">                 &#125;else&#123;</span><br><span class="line">                     arr[i][j] = min(min(arr[i-1][j],arr[i][j-1]),arr[i-1][j-1])+1;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        // for(int i = 0; i &lt;= len1; i++)&#123;</span><br><span class="line">        //      for(int j = 0;j &lt;= len2; j++)&#123;</span><br><span class="line">        //         cout&lt;&lt;arr[i][j]&lt;&lt;&apos;\t&apos;;         </span><br><span class="line">        //      &#125;</span><br><span class="line">        //     cout&lt;&lt;endl;</span><br><span class="line">        // &#125;</span><br><span class="line">        </span><br><span class="line">        return arr[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>build-image-hosting-service-with-github-and-PicGo</title>
    <url>/2019/10/23/build-image-hosting-service-with-github-and-PicGo/</url>
    <content><![CDATA[<p>图床，就是用来存放图片的地方。</p>
<p>目前各个网站为了保证自己的图片不会被其他人盗用，几乎都设置了访问条件验证（比如通过网站登录所保存的cookie等），这样的话其他人可能就访问不到你的图片了，而我写博客就是想给别人看的呀，所以搭建一个自己的图床就迫在眉睫。</p>
<a id="more"></a>
<h2 id="前期准备">前期准备</h2>
<ol>
<li>github账号</li>
<li>良好的网络条件</li>
<li>耐心</li>
</ol>
<h2 id="具体做法参考">具体做法参考</h2>
<ol>
<li><a href="https://juejin.im/entry/5c4ec5aaf265da614420689f" target="_blank" rel="noopener">掘金-PicGo+GitHub图床，让Markdown飞</a></li>
</ol>
<p>按照这个流程就可以完美搭建起来了，我就是照着这个做的。</p>
<ol start="2">
<li><a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo github下载地址</a></li>
</ol>
<p>这个是PicGo的下载地址，选择最新版本的进行下载即可。mac下载dmg格式，win下载exe格式即可。</p>
<ol start="3">
<li><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E9%A2%84%E8%A7%88" target="_blank" rel="noopener">PicGo 官方文档</a></li>
</ol>
<p>之所以把这个放上，是因为这个PicGo其实有很多扩展或者其他的功能，包括设置各种快捷键，各种图床的支持（包括七牛，阿里，github，腾讯云，又拍云等等。话说微博图床现在放盗链了，不建议使用），各种代理等的支持，大家可以进行私人定制，将这个软件做成自己喜欢的样子。</p>
<h2 id="本文感受">本文感受</h2>
<ol>
<li>github是个好地方，开源的力量极其伟大。</li>
</ol>
<p>本来享用iPic来进行图片上传来着，但是它默认只给你微博图床，而现在不能用了。然后如果要开启其他图床支持，是要花钱的，难过的是我都要准备花钱了，网络问题，付费一直不成功，所以就找到了PicGo，完美。</p>
<ol start="2">
<li>有机会还是要花钱买服务</li>
</ol>
<p>github尽管免费，但是说实话，访问是有延迟的，七牛云我也注册了，但是实名认证需要时间，所以我就先直接用github来搭建图床了。等到博客访问量大了的时候到时候再付费买七牛云存储吧，嘿嘿。</p>
<ol start="3">
<li>好的教程感觉一份就够了</li>
</ol>
<p>所以对于自己感觉比较好的教程我就直接放链接了，如果有补充的话我再专门写文章来介绍一下。</p>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>FigureBed</tag>
        <tag>Github</tag>
        <tag>PicGo</tag>
      </tags>
  </entry>
  <entry>
    <title>kickstart-2019-G-T2-TheEquation</title>
    <url>/2019/10/22/kickstart-2019-G-T2-TheEquation/</url>
    <content><![CDATA[<p>还是上周和同学一起尝试的kickstart第G轮比赛，这个是第二题的思路和解法。<br>
在经历各种报错，各种思路修正之后终于搞定了！快写下来！</p>
<a id="more"></a>
<h1><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e02/000000000018fe36" target="_blank" rel="noopener">题目描述</a></h1>
<p><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/kickstart-2019-g-t2-description.jpg" alt=""><br>
<img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/kickstart-2019-g-t2-sample.jpg" alt=""></p>
<h1>题目理解</h1>
<p>就是找一个最大的K，使得K和每个元素进行亦或运算的和小于某个值。</p>
<h1>题目解答</h1>
<h2 id="Test-set1-暴力求解">Test set1 暴力求解</h2>
<p>下面的代码仅仅适应于小测试集。而之所以设置从127开始找，是因为看到了他给的测试集的范围。<br>
对于Test set1中的每个元素而言，0&lt;=Ai&lt;=100,所以可以用6位表示。M也是可以用6位来表示，如果K的最高位不是第6位，而是第7位甚至更高，那么取亦或之后必然会大于128也就大于M，所以对于这个测试集来说，只要从127往下找到第一个符合条件的数字即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">// typedef long long ll;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">void solve(int case_num)&#123;</span><br><span class="line">    int N,M;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    int res = 0;</span><br><span class="line">    int temp = 0 ;</span><br><span class="line">    vector&lt;int&gt; arr;</span><br><span class="line">    bool find = false;</span><br><span class="line">    for(int i =0;i&lt;N;i++)&#123;</span><br><span class="line">        int mi;</span><br><span class="line">        cin &gt;&gt; mi;</span><br><span class="line">        arr.emplace_back(mi);</span><br><span class="line">    &#125;</span><br><span class="line">      for(int i = 127;i&gt;=0;i--)&#123;</span><br><span class="line">          for(int j=0;j&lt;N;j++)&#123;</span><br><span class="line">              temp += arr[j]^i;</span><br><span class="line">          &#125;</span><br><span class="line">          if(temp &lt;= M)&#123;</span><br><span class="line">              find = true;</span><br><span class="line">              res = i;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">          temp = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      res = find?res:-1;</span><br><span class="line">     cout &lt;&lt; &quot;Case #&quot; &lt;&lt; case_num &lt;&lt; &quot;: &quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">    solve(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贪心-位运算巧妙运用">贪心+位运算巧妙运用</h2>
<p>按照上面的方法，我们可以发现这个大样例的0&lt;=Ai&lt;=pow(10,15),对应M也是这个范围。我们可以发现要用49位来表示，也就是说从pow(2,50)开始往下找到第一个符合条件的即可。但是这个数太大了。<br>
然后我们发现原来式子的值可以这么改。<br>
<img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191023095812.png" alt=""><br>
这样我们就通过位运算来找最大的K值了。<br>
怎么找呢。我们找K的时候也是按照比特位从高位开始找，尽可能让高位取1，注意这里要保证当我这个位置取1之后加上后面的所有值的最小值不会超过M，那么才可以取。如果取不了1，那就试一下可不可以取0，同理如果这个位置取0，也要看加上后面所有位所形成的最小值会不会超过K，若是没有超过，则可以取，如果超过，那么说明这个数不存在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int maxn = 50;</span><br><span class="line">LL pre[maxn], zeros[maxn], ones[maxn], minc[maxn], vis[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    for (int t = 1; t &lt;= T; ++t) &#123;</span><br><span class="line">        LL N, M;</span><br><span class="line">        </span><br><span class="line">        scanf(&quot;%lld %lld&quot;,&amp;N, &amp;M);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0;i&lt;maxn;i++)&#123;</span><br><span class="line">              vis[i] = 0;</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;N; i++)&#123;</span><br><span class="line">            LL temp;</span><br><span class="line">            scanf(&quot;%lld&quot;, &amp;temp);</span><br><span class="line">            for(int j = maxn - 1; j &gt;= 0; j--)&#123;</span><br><span class="line">                if((temp&gt;&gt;j)&amp;1)&#123;</span><br><span class="line">                    vis[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = maxn-1; i &gt;= 0; i--)&#123;</span><br><span class="line">            LL a = vis[i] * (1LL&lt;&lt;i);</span><br><span class="line">            LL b = (N-vis[i]) * (1LL&lt;&lt;i);</span><br><span class="line">            ones[i] = a;</span><br><span class="line">            zeros[i] = b;</span><br><span class="line">            minc[i] = min(a,b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre[0] = 0;</span><br><span class="line">        for(int i = 1;i &lt; maxn; i++)&#123;</span><br><span class="line">            pre[i] = pre[i-1]+minc[i-1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL res = 0;</span><br><span class="line">        LL temp = 0;</span><br><span class="line">        for(LL i = maxn - 1; i &gt;=0; i--)&#123;</span><br><span class="line">            if((zeros[i]+temp+pre[i])&lt;=M)&#123;</span><br><span class="line">                temp += zeros[i];</span><br><span class="line">                res += (1LL&lt;&lt;i);</span><br><span class="line">            &#125;else if(temp+ones[i]+pre[i]&lt;=M)&#123;</span><br><span class="line">                temp += ones[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res = -1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld \n&quot;, t, res);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方一定需要搞清楚的是，从最高位开始找的时候，并不是取1就可以，因为后面所有的位的0和1的情况会形成一个数字的范围，而不是0.一定要注意。</p>
<h1>本题收获</h1>
<ol>
<li>要注意看测试集的测试用例的条件，尤其是大小，直接会决定我们的数据类型是int或者long long或者其他。</li>
<li>要注意题目隐含的条件，这个条件并不是单纯的从最高位到最低位的贪心，而是有后续隐含条件的贪心，所以一定要注意。</li>
<li>对于位运算，一定要学会使用移位运算符以及对应的位运算操作，有时候可能会有巧妙的作用。</li>
<li>因为c++的灵活性，可以通过地址进行操作，所以在使用数组的时候一定要注意不要越界，在进行相关条件判断的时候一定要小心。当报错说运行时错误的时候，多半就是for循环的条件写错了或者数组越界了。还有当你发现在本地跑的和在kickstart上跑同一份代码，但是结果不一样的时候，多半也是地址错了，以后要注意！</li>
<li>做出来这个题目的感觉很爽啊，继续加油～</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title>kickstart-2019-G-T1-BookReading</title>
    <url>/2019/10/22/kickstart-2019-G-T1-BookReading/</url>
    <content><![CDATA[<p>上周六和同学一起尝试了一下Google Kickstart的题目，开了开眼，涨了涨见识！<br>
本文是G轮第一题BookReading的思路以及代码，留个纪念。</p>
<a id="more"></a>
<h2 id="题目详情"><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e02/000000000018fd0d" target="_blank" rel="noopener">题目详情</a></h2>
<h3 id="Problem">Problem</h3>
<p>Supervin is a librarian handling an ancient book with N pages, numbered from 1 to N. Since the book is too old, unfortunately M pages are torn out: page number P1, P2, …, PM.</p>
<p>Today, there are Q lazy readers who are interested in reading the ancient book. Since they are lazy, each reader will not necessarily read all the pages. Instead, the i-th reader will only read the pages that are numbered multiples of Ri and not torn out. Supervin would like to know the sum of the number of pages read by each reader.</p>
<h3 id="Input">Input</h3>
<p>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, M, and Q, the number of pages in the book, the number of torn out pages in the book, and the number of readers, respectively. The second line contains M integers, the i-th of which is Pi. The third line contains Q integers, the i-th of which is Ri.</p>
<h3 id="Limits">Limits</h3>
<p>Time limit: 40 seconds per test set.<br>
Memory limit: 1GB.<br>
1 ≤ T ≤ 100.<br>
1 ≤ P1 &lt; P2 &lt; … &lt; PM ≤ N.<br>
1 ≤ Ri ≤ N, for all i.</p>
<p>Test set 1 (Visible)<br>
1 ≤ M ≤ N ≤ 1000.<br>
1 ≤ Q ≤ 1000.</p>
<p>Test set 2 (Hidden)<br>
1 ≤ M ≤ N ≤ 105.<br>
1 ≤ Q ≤ 105.</p>
<h3 id="Sample">Sample</h3>
<p><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191023100352.png" alt=""></p>
<h2 id="题意理解">题意理解</h2>
<p>图书管理员想知道大家一共读了多少页书，需要我们统计。<br>
已知情况是书的总页数N，坏了的页数M，有Q个读者。<br>
然后知道坏的M分别是那些页，知道读者每个人都要读那些页（实际上知道的是基数，这个读者会读这个基数的整数倍）。</p>
<h2 id="解题思路">解题思路</h2>
<p>如果大家想看最终结果，可以直接翻到最后，然后前面的代码写的比较乱，后来经过王博指点，有了很大的改善。好的代码习惯还是要保持的。</p>
<h3 id="暴力求解">暴力求解</h3>
<p>一看题目很简单，对于每个人来说，如果书籍不坏，那么他可以读页数/基数页，然后看看坏了的页数中有几个是基数的倍数，减去就可以。然后我们最终的结果就是每个人的结果加和。<br>
代码如下，写的很乱，而且第二个样例不出意外的超时了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solve(int case_num)&#123;</span><br><span class="line">    int N,M,Q;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;Q;</span><br><span class="line">    vector&lt;int&gt; torn;</span><br><span class="line">    int res =0;</span><br><span class="line">    //vector&lt;int&gt; reader;</span><br><span class="line">    for(int i = 0;i&lt;M;i++)&#123;</span><br><span class="line">        int mi;</span><br><span class="line">        cin &gt;&gt; mi;</span><br><span class="line">        torn.emplace_back(mi);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i =0;i&lt;Q;i++)&#123;</span><br><span class="line">        int ri;</span><br><span class="line">        cin &gt;&gt; ri;</span><br><span class="line">        int num = N/ri;</span><br><span class="line">        int sortnum =0;</span><br><span class="line">        for(int j = 0;j&lt;M;j++)&#123;</span><br><span class="line">            if(torn[j]%ri==0)&#123;</span><br><span class="line">                sortnum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += (num - sortnum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Case #&quot; &lt;&lt; case_num &lt;&lt; &quot;: &quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">    solve(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划求解">动态规划求解</h3>
<p>仔细想想，其实我们上面暴力的时间复杂度是O（M<em>Q），当破坏的页数很多的时候，很多判断是无效的，没有意义的，比如某位读者只读2的倍数，那么我其实只要判断2，4，6，2</em>n&lt;=N这些页就可以。其他的页数完全可以不用判断，所以这个地方可以简化。于是是不是可以把每个基数对应的结果都算出来，然后当读读者的基数的时候，直接将其求和就可以呢？当然可以！于是就有了下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int a[MAXN],ans[MAXN];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t,x;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">        int N,M,Q;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;Q);</span><br><span class="line"></span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            a[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            a[x] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i&lt;=N; i++)&#123;</span><br><span class="line">            for(int j =i; j &lt;= N; j+=i)&#123;</span><br><span class="line">                 ans[i] += a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LL res =0;</span><br><span class="line">        for( int i = 1; i &lt;= Q; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            res += ans[x];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,res);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0;i&lt;=N;i++)&#123;</span><br><span class="line">            ans[i] = 0;</span><br><span class="line">            a[i] =0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进一步动态规划">进一步动态规划</h3>
<p>上面的方法把所有的基数对应的结果都算出来了，但是其实中间的很多结果我们是用不到的，比如我们就两个读者，分别读2的倍数和3的倍数，而上面那个方法将1-N的所有结果都算出来了，最后只用了2和3对应的结果而已，这样就造成了浪费。所以我们是不是可以将结果进行保存，下次来了一个读者，看看之前有没有算过，如果算过，就直接用之前保存的结果，如果没有算过，那么就计算一下，然后保存起来呢？当然可以！于是就有了下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int getPage(int N,int i,int arr[])&#123;</span><br><span class="line">    int res =0;</span><br><span class="line">    for(int j = i; j&lt;=N; j+=i)&#123;</span><br><span class="line">        res += arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a[MAXN],ans[MAXN];</span><br><span class="line">int N,M,Q;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t,x;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;Q);</span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            a[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            a[x] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(ans, 0, sizeof ans);</span><br><span class="line">      </span><br><span class="line">        LL res =0;</span><br><span class="line">        for( int i = 1; i &lt;= Q; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            if(ans[x]==0)&#123;</span><br><span class="line">                ans[x] = getPage(N, x,a);</span><br><span class="line">            &#125;</span><br><span class="line">            res += ans[x];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,res);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本题收获">本题收获</h2>
<ol>
<li>了解到了比较好的编码规范，以后会应用到实践中。</li>
<li>锻炼了自己分析问题的能力，提高算法的效率很重要，而其中的意识要逐渐培养。</li>
<li>认识到了c++灵活但是有时候太灵活，以后需要好好注意如何使用。</li>
<li>知道了kickstart的难度以及自己的水平。刷题路漫漫，以后请加油。</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>终端工具tmux资料分享</title>
    <url>/2019/10/21/tmux-reference/</url>
    <content><![CDATA[<ol>
<li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html" target="_blank" rel="noopener">阮一峰-Tmux 使用教程</a><br>
从浅入深，娓娓道来，非常棒。</li>
<li><a href="https://louiszhai.github.io/2017/09/30/tmux/#Tmux%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener">路易斯-Tmux使用手册</a><br>
大牛无疑，介绍的非常干练，私人定制部分写的特别好。</li>
<li><a href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7#file-tmux-cheatsheet-markdown" target="_blank" rel="noopener">GitHub-Tmux 快捷键 &amp; 速查表 &amp; 简明教程</a><br>
方便大家使用。</li>
</ol>
]]></content>
      <categories>
        <category>工具推荐</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>喜大普奔，庆文又搭博客了。</title>
    <url>/2019/10/18/hello-world-1/</url>
    <content><![CDATA[<p>最近看到一句话，</p>
<pre><code>有了自己的博客，就仿佛自己在互联网中留下了自己的脚印.
</code></pre>
<p>还挺有诗意的，所以我就把这个博客搭建起来了。</p>
<a id="more"></a>
<h1>博客写点啥呢</h1>
<h2 id="可能会帮到别人的东西">可能会帮到别人的东西</h2>
<p>本部分包含但不限于代码的bug解决办法，代码规范，leetcode题解。</p>
<h2 id="自己觉得需要整理的东西">自己觉得需要整理的东西</h2>
<p>本部分包含但不限于对于某个问题的求解过程。</p>
<h2 id="也许写点乱七八糟的推荐">也许写点乱七八糟的推荐</h2>
<p>本部分包含但是不限于对于书籍电影动漫等的推荐。</p>
<p>目标就是等我回忆青春的时候，再来这个博客瞅瞅，让我能够感慨一句，我当年也干了很多事情呀。</p>
<h1>博客搭建参考</h1>
<ol>
<li><a href="https://cuiqingcai.com/7625.html" target="_blank" rel="noopener">崔庆才-利用 GitHub + Hexo + Next 从零搭建一个博客</a></li>
<li><a href="https://juejin.im/post/5a308ae551882540f363879a" target="_blank" rel="noopener">为你的hexo博客配置个性域名</a></li>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo-中文文档</a></li>
<li><a href="https://guanqr.com/study/blog/hexo-theme-next-customization/" target="_blank" rel="noopener">Hexo-NexT 主题个性优化</a></li>
</ol>
]]></content>
      <categories>
        <category>文言文语</category>
      </categories>
      <tags>
        <tag>杂事</tag>
      </tags>
  </entry>
</search>
