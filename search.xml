<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>kickstart-2019-G-T1-BookReading</title>
    <url>/2019/10/22/kickstart-2019-G-T1-BookReading/</url>
    <content><![CDATA[<p>上周六和同学一起尝试了一下Google Kickstart的题目，开了开眼，涨了涨见识！<br>本文是G轮第一题BookReading的思路以及代码，留个纪念。</p>
<a id="more"></a>

<h2 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e02/000000000018fd0d" target="_blank" rel="noopener">题目详情</a></h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>Supervin is a librarian handling an ancient book with N pages, numbered from 1 to N. Since the book is too old, unfortunately M pages are torn out: page number P1, P2, …, PM.</p>
<p>Today, there are Q lazy readers who are interested in reading the ancient book. Since they are lazy, each reader will not necessarily read all the pages. Instead, the i-th reader will only read the pages that are numbered multiples of Ri and not torn out. Supervin would like to know the sum of the number of pages read by each reader.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, M, and Q, the number of pages in the book, the number of torn out pages in the book, and the number of readers, respectively. The second line contains M integers, the i-th of which is Pi. The third line contains Q integers, the i-th of which is Ri.</p>
<h3 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h3><p>Time limit: 40 seconds per test set.<br>Memory limit: 1GB.<br>1 ≤ T ≤ 100.<br>1 ≤ P1 &lt; P2 &lt; … &lt; PM ≤ N.<br>1 ≤ Ri ≤ N, for all i.</p>
<p>Test set 1 (Visible)<br>1 ≤ M ≤ N ≤ 1000.<br>1 ≤ Q ≤ 1000.</p>
<p>Test set 2 (Hidden)<br>1 ≤ M ≤ N ≤ 105.<br>1 ≤ Q ≤ 105.</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p><img src="http://note.youdao.com/yws/res/9843/C751CB16D4404C2EACEB633D10C29621" alt="image"></p>
<h2 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h2><p>图书管理员想知道大家一共读了多少页书，需要我们统计。<br>已知情况是书的总页数N，坏了的页数M，有Q个读者。<br>然后知道坏的M分别是那些页，知道读者每个人都要读那些页（实际上知道的是基数，这个读者会读这个基数的整数倍）。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果大家想看最终结果，可以直接翻到最后，然后前面的代码写的比较乱，后来经过王博指点，有了很大的改善。好的代码习惯还是要保持的。</p>
<h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>一看题目很简单，对于每个人来说，如果书籍不坏，那么他可以读页数/基数页，然后看看坏了的页数中有几个是基数的倍数，减去就可以。然后我们最终的结果就是每个人的结果加和。<br>代码如下，写的很乱，而且第二个样例不出意外的超时了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solve(int case_num)&#123;</span><br><span class="line">    int N,M,Q;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;Q;</span><br><span class="line">    vector&lt;int&gt; torn;</span><br><span class="line">    int res =0;</span><br><span class="line">    //vector&lt;int&gt; reader;</span><br><span class="line">    for(int i = 0;i&lt;M;i++)&#123;</span><br><span class="line">        int mi;</span><br><span class="line">        cin &gt;&gt; mi;</span><br><span class="line">        torn.emplace_back(mi);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i =0;i&lt;Q;i++)&#123;</span><br><span class="line">        int ri;</span><br><span class="line">        cin &gt;&gt; ri;</span><br><span class="line">        int num = N/ri;</span><br><span class="line">        int sortnum =0;</span><br><span class="line">        for(int j = 0;j&lt;M;j++)&#123;</span><br><span class="line">            if(torn[j]%ri==0)&#123;</span><br><span class="line">                sortnum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += (num - sortnum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Case #&quot; &lt;&lt; case_num &lt;&lt; &quot;: &quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">    solve(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划求解"><a href="#动态规划求解" class="headerlink" title="动态规划求解"></a>动态规划求解</h3><p>仔细想想，其实我们上面暴力的时间复杂度是O（M<em>Q），当破坏的页数很多的时候，很多判断是无效的，没有意义的，比如某位读者只读2的倍数，那么我其实只要判断2，4，6，2</em>n&lt;=N这些页就可以。其他的页数完全可以不用判断，所以这个地方可以简化。于是是不是可以把每个基数对应的结果都算出来，然后当读读者的基数的时候，直接将其求和就可以呢？当然可以！于是就有了下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int a[MAXN],ans[MAXN];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t,x;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">        int N,M,Q;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;Q);</span><br><span class="line"></span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            a[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            a[x] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i&lt;=N; i++)&#123;</span><br><span class="line">            for(int j =i; j &lt;= N; j+=i)&#123;</span><br><span class="line">                 ans[i] += a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LL res =0;</span><br><span class="line">        for( int i = 1; i &lt;= Q; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            res += ans[x];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,res);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0;i&lt;=N;i++)&#123;</span><br><span class="line">            ans[i] = 0;</span><br><span class="line">            a[i] =0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进一步动态规划"><a href="#进一步动态规划" class="headerlink" title="进一步动态规划"></a>进一步动态规划</h3><p>上面的方法把所有的基数对应的结果都算出来了，但是其实中间的很多结果我们是用不到的，比如我们就两个读者，分别读2的倍数和3的倍数，而上面那个方法将1-N的所有结果都算出来了，最后只用了2和3对应的结果而已，这样就造成了浪费。所以我们是不是可以将结果进行保存，下次来了一个读者，看看之前有没有算过，如果算过，就直接用之前保存的结果，如果没有算过，那么就计算一下，然后保存起来呢？当然可以！于是就有了下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int getPage(int N,int i,int arr[])&#123;</span><br><span class="line">    int res =0;</span><br><span class="line">    for(int j = i; j&lt;=N; j+=i)&#123;</span><br><span class="line">        res += arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a[MAXN],ans[MAXN];</span><br><span class="line">int N,M,Q;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t,x;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;Q);</span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            a[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            a[x] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(ans, 0, sizeof ans);</span><br><span class="line">      </span><br><span class="line">        LL res =0;</span><br><span class="line">        for( int i = 1; i &lt;= Q; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            if(ans[x]==0)&#123;</span><br><span class="line">                ans[x] = getPage(N, x,a);</span><br><span class="line">            &#125;</span><br><span class="line">            res += ans[x];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,res);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本题收获"><a href="#本题收获" class="headerlink" title="本题收获"></a>本题收获</h2><ol>
<li>了解到了比较好的编码规范，以后会应用到实践中。</li>
<li>锻炼了自己分析问题的能力，提高算法的效率很重要，而其中的意识要逐渐培养。</li>
<li>认识到了c++灵活但是有时候太灵活，以后需要好好注意如何使用。</li>
<li>知道了kickstart的难度以及自己的水平。刷题路漫漫，以后请加油。</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>终端工具tmux资料分享</title>
    <url>/2019/10/21/tmux-reference/</url>
    <content><![CDATA[<ol>
<li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html" target="_blank" rel="noopener">阮一峰-Tmux 使用教程</a><br>从浅入深，娓娓道来，非常棒。</li>
<li><a href="https://louiszhai.github.io/2017/09/30/tmux/#Tmux%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener">路易斯-Tmux使用手册</a><br>大牛无疑，介绍的非常干练，私人定制部分写的特别好。</li>
<li><a href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7#file-tmux-cheatsheet-markdown" target="_blank" rel="noopener">GitHub-Tmux 快捷键 &amp; 速查表 &amp; 简明教程</a><br>方便大家使用。</li>
</ol>
]]></content>
      <categories>
        <category>工具推荐</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>喜大普奔，庆文又搭博客了。</title>
    <url>/2019/10/18/hello-world-1/</url>
    <content><![CDATA[<p>最近看到一句话，</p>
<pre><code>有了自己的博客，就仿佛自己在互联网中留下了自己的脚印.</code></pre><p>还挺有诗意的，所以我就把这个博客搭建起来了。</p>
<a id="more"></a>

<h1 id="博客写点啥呢"><a href="#博客写点啥呢" class="headerlink" title="博客写点啥呢"></a>博客写点啥呢</h1><h2 id="可能会帮到别人的东西"><a href="#可能会帮到别人的东西" class="headerlink" title="可能会帮到别人的东西"></a>可能会帮到别人的东西</h2><p>本部分包含但不限于代码的bug解决办法，代码规范，leetcode题解。</p>
<h2 id="自己觉得需要整理的东西"><a href="#自己觉得需要整理的东西" class="headerlink" title="自己觉得需要整理的东西"></a>自己觉得需要整理的东西</h2><p>本部分包含但不限于对于某个问题的求解过程。</p>
<h2 id="也许写点乱七八糟的推荐"><a href="#也许写点乱七八糟的推荐" class="headerlink" title="也许写点乱七八糟的推荐"></a>也许写点乱七八糟的推荐</h2><p>本部分包含但是不限于对于书籍电影动漫等的推荐。</p>
<p>目标就是等我回忆青春的时候，再来这个博客瞅瞅，让我能够感慨一句，我当年也干了很多事情呀。</p>
<h1 id="博客搭建参考"><a href="#博客搭建参考" class="headerlink" title="博客搭建参考"></a>博客搭建参考</h1><ol>
<li><a href="https://cuiqingcai.com/7625.html" target="_blank" rel="noopener">崔庆才-利用 GitHub + Hexo + Next 从零搭建一个博客</a></li>
<li><a href="https://juejin.im/post/5a308ae551882540f363879a" target="_blank" rel="noopener">为你的hexo博客配置个性域名</a></li>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo-中文文档</a></li>
</ol>
]]></content>
      <categories>
        <category>文言文语</category>
      </categories>
      <tags>
        <tag>杂事</tag>
      </tags>
  </entry>
</search>
