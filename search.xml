<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>剑指offer-二进制中1的个数</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十三篇。<br>主要知识点为进制转化和位运算以及数据在计算机中的存储方式，解题方式比较巧妙。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>我们知道在计算机中数据是以二进制0和1进行存储的，所以我们可以通过1和这个数据的每一位进行&amp;运算来计算原来数据中1的个数。</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>通过n = n&amp;(n-1)这个运算会消掉n的二进制表示中最右侧的1，只要判断多少次之后n变成0即可计算出原来n中有多少位1.</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int res = 0;</span><br><span class="line">         int flag = 1;</span><br><span class="line">         while( flag != 0)&#123;</span><br><span class="line">             if(n &amp; flag) res++;</span><br><span class="line">             flag = flag &lt;&lt;1;</span><br><span class="line">         &#125;</span><br><span class="line">         return res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int res = 0;</span><br><span class="line">         while(n != 0)&#123;</span><br><span class="line">             res++;</span><br><span class="line">             n = n &amp;(n-1);</span><br><span class="line">         &#125;</span><br><span class="line">         return res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)<br>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-矩形覆盖</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十二篇。<br>主要知识点为斐波那契数列，只是需要先对问题进行分析，同样还是用三种方式来解决这个问题。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">题目描述</a></h2><p>我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2<em>1的小矩形无重叠地覆盖一个2</em>n的大矩形，总共有多少种方法？</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>方便解释起见，我们假设整个横着的就是一个宽为2，长为n的大矩形，下面分情况讨论。</p>
<ol>
<li>n = 0 : 结果为0</li>
<li>n = 1 : 结果为1，竖着一个。</li>
<li>n = 2 : 结果为2 竖着两个或者横着两个。</li>
<li>n = 3 : 结果为3，在n=1的基础上横排两个，或者在n=2的基础上竖着加一个。</li>
<li>……<br>综上，我们就得到结论：f(n) = f(n-1)+f(n-2) 初始项为{0,1,2}  </li>
</ol>
<h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接用递归。</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>用数组保存</p>
<h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>保存两个关键数字。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int n) &#123;</span><br><span class="line">        // 方法1 直接用递归。</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(n == 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else if(n == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return rectCover(n-1)+rectCover(n-2);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(n)</p>
<h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int n) &#123;</span><br><span class="line">        //方法2: 数组保存</span><br><span class="line">        vector&lt;int&gt; res = &#123;0,1,2&#125;;</span><br><span class="line">        for(int i = 2;i &lt; n; i++)&#123;</span><br><span class="line">            res.push_back(res[i]+res[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int n) &#123;</span><br><span class="line">        // 方法3. 用两个关键变量进行保存。</span><br><span class="line">        if(n==0) return 0;</span><br><span class="line">        if(n == 1) return 1;</span><br><span class="line">        if(n == 2) return 2;</span><br><span class="line">        int first = 1,second = 2;</span><br><span class="line">        for(int i = 2; i &lt; n; i++)&#123;</span><br><span class="line">            int temp = first+second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-变态跳台阶</title>
    <url>/2020/01/19/%E5%89%91%E6%8C%87offer-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十一篇。<br>主要知识点为找规律，可以作为上一篇跳台阶的升级版,依旧比较简单。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接找规律。</p>
<ol>
<li>第一级台阶：1种方式。</li>
<li>第二级台阶：2种方式。1+1 ：直接跳到2级或者从1级上跳上来。</li>
<li>第三级台阶：4种方式。1+1+2 ：直接跳到3级或者从1级跳上来或者从2级跳上来。</li>
<li>……</li>
<li>第n级台阶：2^(n-1)种方式。 1+1+2+4+……+2^(n-2) = 2^(n-1)。直接跳到n级或者从前面的每一级跳到当前n级。    </li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        return pow(2,number-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-跳台阶</title>
    <url>/2020/01/18/%E5%89%91%E6%8C%87offer-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第十篇。<br>主要内容其实还是斐波那契数列，依旧是上一篇斐波那契的思路，再复习一遍。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一级台阶： 1种跳法<br>第二级台阶： 2种跳法<br>第三级台阶： 3种跳法：要么从第一级跳2级跳上来，要么从第二级跳1级跳上来。<br>……<br>第n级台阶：f(n-2)+f(n-1): 要么从n-2级一次跳两级跳上来，那么从n-1级跳一级跳上来。<br>所以就是一个非常典型的斐波那契数列，最开始两项分别是1和2.</p>
<h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接用递归</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>用数组保存</p>
<h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>保存两个关键数字</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int num) &#123;</span><br><span class="line">        //方法1.递归解决</span><br><span class="line">         if(num == 1)&#123;</span><br><span class="line">           return 1;</span><br><span class="line">         &#125;else if( num == 2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">            return jumpFloor(num-1) + jumpFloor(num-2);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int num) &#123;</span><br><span class="line">        // 方法2: 数组保存</span><br><span class="line">         vector&lt;int&gt; a=&#123;0,1,2&#125;;</span><br><span class="line">         for(int i = 3; i&lt;=num; i++)&#123;</span><br><span class="line">             a.push_back(a[i-1]+a[i-2]);</span><br><span class="line">         &#125;</span><br><span class="line">         return a[num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int num) &#123;</span><br><span class="line">        // 方法3:</span><br><span class="line">        int first = 1, second = 2;</span><br><span class="line">        if(num == 1) return 1;</span><br><span class="line">        if(num == 2) return 2;</span><br><span class="line">        for(int i = 2; i &lt; num; i++)&#123;</span><br><span class="line">            int temp = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)<br>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-斐波那契数列</title>
    <url>/2020/01/18/%E5%89%91%E6%8C%87offer-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第九篇。<br>主要知识点就是斐波那契数列，非常常见，非常经典。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接通过斐波那契的概念来进行计算，递归调用。</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>我们知道递归调用的时候，很多部分都是重复计算的，所以我们可以建立一个数组进行保存。</p>
<h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>仔细想想，每次计算的时候，对我们真正有用的数据其实只有两个，所以我们只要能够保存好两个必要的数据即可依次的计算后面的数据，直到算出我们想要的数据。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        //方法1: 递归</span><br><span class="line">        if(n == 0)return 0;</span><br><span class="line">        if(n == 1) return 1;</span><br><span class="line">        return Fibonacci(n-1)+Fibonacci(n-2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        // 方法2: 数据保存在一个数组中</span><br><span class="line">        vector&lt;int&gt; a=&#123;0,1&#125;;</span><br><span class="line">        for(int i = 2;i&lt;=39;i++)&#123;</span><br><span class="line">            a.push_back(a[i-1]+a[i-2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return a[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        // 方法3. 通过2个常量来进行数据的保存。</span><br><span class="line">        int first = 0,second = 1;</span><br><span class="line">        if(n == 0) return first;</span><br><span class="line">        if(n == 1) return second;</span><br><span class="line">        for(int i = 1; i&lt;n; i++)&#123;</span><br><span class="line">            int temp = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(1)</p>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-旋转数组的最小数字</title>
    <url>/2020/01/18/%E5%89%91%E6%8C%87offer-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第八篇。<br>其实就是找有序数组的最小元素，只是这个有序数组进行了一次旋转而已。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接使用stl中的min_element方法。一行代码就可以搞定。</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>思路2是可以使用类似于二分的方法进行查找，我们在看这个数字经过旋转之后的变化，其实如果一旦二分，我们会发现那个最小元素其实会存在于某个区间内，而这个区间并不满足左边的元素要小于右边的元素。而另一个区间是满足的，因为本身的数组就是非递减排序的，所以只会有一个区间是出现降序排列。这样我们只要找到导致降序的点即可。<br>还有一个要注意的点，就是这个里面可能会有重复数据，所以可能出现中间元素和尾元素相等的情况，这个时候其实不能确定那个降序点在什么地方，所以这个时候就尾节点区间减少一个即可。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        return *min_element(rotateArray.begin(),rotateArray.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(rotateArray.size() == 0) return 0;</span><br><span class="line">        if(rotateArray.size() == 1) return rotateArray[0];</span><br><span class="line">        int l = 0,r = rotateArray.size()-1;</span><br><span class="line">        while(l&lt;r)&#123;</span><br><span class="line">            int mid = l + (r-l)/2;</span><br><span class="line">            if(rotateArray[mid]&lt;rotateArray[r])&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;else if(rotateArray[mid]&gt;rotateArray[r])&#123;</span><br><span class="line">                l = mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rotateArray[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度好的情况为O(logn),不好的情况为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-用两个栈实现队列</title>
    <url>/2020/01/18/%E5%89%91%E6%8C%87offer-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第七篇。<br>目的就是用两个后进先出的栈来实现一个先进先出的队列，思路比较巧妙。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>思路1比较朴素，我们用一个栈来作为数据存储的栈A，然后另一个作为中转的栈B，当我们存数据的时候，我们将数据压入到栈A中，然后取数据的时候，我们将A的所有数据都压入到B中，这个时候B的出栈顺序也就是队列应该的出队列顺序了，所以此时将B的栈顶元素取出即可，然后再将B中的所有的数据重新压回A中，后续操作皆是如此。</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>思路2其实是思路1的改进版，我们发现思路1在将数据取出之后，又把所有数据压回A栈，这样就会有很大的浪费，这里其实只要加一层判断，当往外取数据的时候，只要B栈不为空，就直接从B栈出栈栈顶元素即可，如果B栈为空，那么将A栈的数据全部压入到B栈中。从而省去中间多余的数据的来回压入操作。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">      while(!stack1.empty())&#123;</span><br><span class="line">           stack2.push(stack1.top());</span><br><span class="line">           stack1.pop();</span><br><span class="line">       &#125;</span><br><span class="line">      int res =  stack2.top();</span><br><span class="line">      stack2.pop();</span><br><span class="line">      while(!stack2.empty())&#123;</span><br><span class="line">           stack1.push(stack2.top());</span><br><span class="line">           stack2.pop();</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(n)</p>
<h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">      if(stack2.empty())&#123;</span><br><span class="line">          while(!stack1.empty())&#123;</span><br><span class="line">              stack2.push(stack1.top());</span><br><span class="line">              stack1.pop();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      int res = stack2.top(); stack2.pop();</span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-重建二叉树</title>
    <url>/2020/01/18/%E5%89%91%E6%8C%87offer-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第六篇。<br>主要就是根据二叉树遍历的前序遍历和中序遍历重新构造出原始的二叉树。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>前序遍历的顺序是 根节点，左子树，右子树。<br>中序遍历的顺序是 左子树，根节点，右子树。<br>所以我们可以发现，前序遍历的第一个节点就是根节点，然后我们在中序遍历中找到这个根节点，那么这个根节点之前的就是左子树的中序，根节点之后的就是右子树的中序，然后可以根据左子树的个数，在前序遍历中将左子树和右子树进行分离，而分离的结果可以用来构建左子树和右子树。</p>
<p>下面以题目中的数据为例进行详细说明</p>
<ol>
<li>首先根据前序遍历，可以知道当前的根节点为1。</li>
<li>在中序遍历中寻找节点1， 然后1之前的节点[4,7,2]就是当前树的左子树的中序遍历，1之后的节点[5,3,8,6]就是当前树的右子树的中序遍历。</li>
<li>在前序遍历中根据左子树的节点个数找到对应的左子树的前序遍历[2,4,7],和对应的右子树的前序遍历【3，5，6，8】。</li>
<li>同样的操作可以继续针对左子树和右子树，从而把整个的二叉树构建出来。</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">            return helper(pre,0,pre.size()-1,vin,0,vin.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* helper(vector&lt;int&gt; pre,int pstart,int pend,vector&lt;int&gt; vin,int vstart,int vend)&#123;</span><br><span class="line">        if(vstart &gt; vend) return NULL;</span><br><span class="line">        int root = pre[pstart];</span><br><span class="line">        TreeNode* temp = new TreeNode(root);</span><br><span class="line">        </span><br><span class="line">        auto a = find(vin.begin(),vin.end(),root);</span><br><span class="line">        int index = distance(vin.begin(),a);</span><br><span class="line">        int lnum = index - vstart; //左子树</span><br><span class="line">        temp -&gt; left = helper(pre,pstart+1,pstart+lnum,vin,vstart,index-1);</span><br><span class="line">        temp -&gt; right = helper(pre,pstart+1+lnum,pend,vin,index+1,vend);</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>类似的题目还有根据中序和后续进行重建二叉树，道理类似，只是根节点变成了后续遍历的最后一个节点。<br>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>BinaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-从尾到头打印链表</title>
    <url>/2020/01/17/%E5%89%91%E6%8C%87offer-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第五篇。<br>题目要求就是打印链表，属于很常见的问题，但是因为题目要求从尾到头打印链表，所以又生出了一些波折。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>从头到尾遍历这个链表，然后将得到的值插入用于保存结果的vector的初始位置。<br>这个方法很容易能够想到，但是性能其实不是很好，就是因为在vector开头插入元素的时候，需要将这个vector中的所有元素向后移动一位，所以复杂度就会比较高，更多详细的解释可以看之后的关于字符串替换的那个题目。</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>从头到尾遍历这个链表，将遍历得到的值依次插入到用于保存结果的vector的后面，最后再反转整个vector。</p>
<h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>从头到尾遍历这个链表，将数据压入到对应的栈中，然后利用栈的先进后出的特性，将所有结果出栈，以后插入用于保存结果的vector后面即可。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        // 思路1: 遍历的时候前面插入结果</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            res.insert(res.begin(),p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n^2),空间复杂度为O(n)</p>
<h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        // 思路2: 遍历的时候后插，然后返回reverse的结果。 4ms 480k</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)</p>
<h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        // 思路3: 通过栈先进后出的特性来实现链表的从尾到头遍历 3ms 460k</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        stack&lt;int&gt; mstack;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            mstack.push(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(mstack.size() != 0)&#123;</span><br><span class="line">            res.push_back(mstack.top());</span><br><span class="line">            mstack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>链表</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-最小的K个数</title>
    <url>/2020/01/17/%E5%89%91%E6%8C%87offer-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第四篇。<br>本题比较常见，而且思路也非常清晰，一个是排序，一个用最小堆。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接从小到大将所有所有数字进行排序，然后取前K个即可。</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>把所有的数据进行处理构造最小堆，然后取出前K个返回即可。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        if(k&gt;input.size()) return &#123;&#125;;</span><br><span class="line">        sort(input.begin(),input.end());</span><br><span class="line">        return vector&lt;int&gt;(input.begin(),input.begin()+k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlogn),空间复杂度为O(n)</p>
<h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        if(k&gt;input.size()) return &#123;&#125;;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</span><br><span class="line">        for(auto a:input)&#123;</span><br><span class="line">            q.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        while(k&gt;0)&#123;</span><br><span class="line">           res.push_back(q.top());</span><br><span class="line">           q.pop();</span><br><span class="line">           k--;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(n),空间复杂度为O(n)<br>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>最小堆</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-整数中1出现的次数</title>
    <url>/2020/01/17/%E5%89%91%E6%8C%87offer-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<p>本文为剑指 offer 系列第三篇。<br>核心能力是基于数学知识来找数字存在的规律。<br>这个问题给我的重要启示是将问题普遍化与自动化，是我们作为一个计算机行业从业者应该要做的事，也是让我们所有人受益无穷的事。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>求出1到13的整数中1出现的次数,并算出100到1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1:"></a>思路1:</h3><p>将1-n的每个数通过取余数来计算每一位是否为1，然后找个计数器来进行统计</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2:"></a>思路2:</h3><p>通过分析每个位置上1出现的规律来进行规律性的查找。下面以数字32456然后计算百位上1的个数来进行演示。</p>
<ol>
<li>首先将原来的数据分为2部分，a= 32456/100 = 324, b=32456%100 = 56. </li>
<li>这里百位上为4，所以他有完整的33个100位1，也就是(a/10+1)个100，推广一下，我们发现其实任何大于等于2的数字都会有这个规律。</li>
<li>如果这里百位上为0.即32056，则它有完整的32个100，也就是（a/10)个100。</li>
<li>如果这里百位上位1，即32156，则他有完整的32个100，同时会有32100-32156中57个百位上的1.也就是(a/10)个100，然后加上(b+1)个1.<br>其他位可以同理得到计算结果。从而问题得到了解决。</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        // 方法1: 暴力求解。计算每一个数中每一位是不是1进行求和。</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 1;  i &lt;= n; i++)&#123;</span><br><span class="line">           int temp = i;</span><br><span class="line">            while(temp)&#123;</span><br><span class="line">                if(temp%10 == 1)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp/10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nlgn),空间复杂度为O(1);</p>
<h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(long i = 1; i&lt;= n; i*=10)&#123;</span><br><span class="line">            int a = n/i, b = n%i;</span><br><span class="line">            if(a%10 == 0)&#123;</span><br><span class="line">                res += (a/10)*i;</span><br><span class="line">            &#125;else if( a%10 == 1)&#123;</span><br><span class="line">                res += (a/10)*i + (b+1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res += (a/10+1)*i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(lgn),空间复杂度为O(1);<br>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-求1+2+……+n</title>
    <url>/2020/01/16/%E5%89%91%E6%8C%87offer-%E6%B1%821-2-%E2%80%A6%E2%80%A6-n/</url>
    <content><![CDATA[<p>本文为剑指offer系列第二篇。<br>个人感觉属于奇淫巧技，但是是真的很巧妙，有利于打破思维定势。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=11200&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目描述</a></h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路1: 其实可以调用库函数<br>思路2: 可以使用 &amp;&amp; 和 || 的熔断机制。<br>思路3：使用sizeof函数和右移操作。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="朴素思想代码"><a href="#朴素思想代码" class="headerlink" title="朴素思想代码"></a>朴素思想代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        return (1+n)*n/2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        return fma(fma(n,n+1,0),0.5,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma" target="_blank" rel="noopener">fma</a>(x,y,z)函数作用是返回x*y+z. 我们让z为0,就变成了单纯的加法。</p>
<h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        int sum  = n;</span><br><span class="line">        bool b = (n&gt;0) &amp;&amp; (sum += Sum_Solution(n-1))&gt;0;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        char a[n][n+1];</span><br><span class="line">        return sizeof(a)&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为sizeof()函数可以用来计算对象空间大小，每个char是1个字节，所以对于大小为n<em>(n+1)的二维数组而言，空间就是n</em>(n+1). 结果右移一位等同于除以2.<br>由此我们可以推广到其他的数据类型上，比如int,每个int是4个字节，所以要在原来的基础上右移3位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">       int a[n][n+1];</span><br><span class="line">       return sizeof(a)&gt;&gt;3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>智力题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-二维数组中的查找</title>
    <url>/2020/01/16/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>本文属于剑指offer系列第一题。<br>本题目的关键点在于找到一个非常棒的问题入手点，然后这个题目就已经解决了一半。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路1: 双层for循环，肯定能解决，但是复杂度为O(n^2),而且没有充分利用行列有序这个条件。<br>思路2: 我们从右上角开始查找，往左下角找。<br>    如果当前位置的元素大于目标元素，那么肯定在下一行。<br>    如果当前位置的元素小于目标元素，肯定在本元素的左侧。<br>    如果当前位置的元素等于目标元素，那么返回即可。</p>
<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><p>题目从右上角入手开始查找元素非常有效且巧妙。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">       int i = 0;</span><br><span class="line">       int j = array[0].size()-1;</span><br><span class="line">       while(i &lt; array.size() &amp;&amp; j&gt;= 0)&#123;</span><br><span class="line">           if(array[i][j] == target)&#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;else if(array[i][j] &lt; target)&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是O(m+n)，空间复杂度O(m*n) m为行数，n为列数。<br>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>Codinginterviews</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>common-commands</title>
    <url>/2020/01/07/common-commands/</url>
    <content><![CDATA[<p>本篇文章用于记录平时常用的、可以大幅度提高效率的一些命令和快捷键，方便之后查看与使用，不定期更新。</p>
<a id="more"></a>
<h2 id="mac相关"><a href="#mac相关" class="headerlink" title="mac相关"></a>mac相关</h2><h3 id="mac命令行下打开图片"><a href="#mac命令行下打开图片" class="headerlink" title="mac命令行下打开图片"></a>mac命令行下打开图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open a.jpg</span><br></pre></td></tr></table></figure>
<p>打开文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open foldname</span><br></pre></td></tr></table></figure>
<p>打开当前文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open .</span><br></pre></td></tr></table></figure>

<h2 id="Chrome相关（important！！）"><a href="#Chrome相关（important！！）" class="headerlink" title="Chrome相关（important！！）"></a>Chrome相关（important！！）</h2><h3 id="新开一个标签页"><a href="#新开一个标签页" class="headerlink" title="新开一个标签页"></a>新开一个标签页</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command + T</span><br></pre></td></tr></table></figure>
<h3 id="新开一个搜索窗口"><a href="#新开一个搜索窗口" class="headerlink" title="新开一个搜索窗口"></a>新开一个搜索窗口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command + N //正常窗口</span><br><span class="line">command + shift + N //无痕搜索窗口</span><br></pre></td></tr></table></figure>
<h3 id="切换标签页"><a href="#切换标签页" class="headerlink" title="切换标签页"></a>切换标签页</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl + tab //下一个标签页</span><br><span class="line">ctrl + shift + tab //上一个标签页</span><br></pre></td></tr></table></figure>
<h3 id="打开刚关掉的标签页"><a href="#打开刚关掉的标签页" class="headerlink" title="打开刚关掉的标签页"></a>打开刚关掉的标签页</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command + shift + T</span><br></pre></td></tr></table></figure>

<h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><h3 id="查看电脑核数"><a href="#查看电脑核数" class="headerlink" title="查看电脑核数"></a>查看电脑核数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo |grep &quot;processor&quot;| wc -l</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么c++比java运行的速度快</title>
    <url>/2019/12/10/%E4%B8%BA%E4%BB%80%E4%B9%88c-%E6%AF%94java%E8%BF%90%E8%A1%8C%E7%9A%84%E9%80%9F%E5%BA%A6%E5%BF%AB/</url>
    <content><![CDATA[<p>最近和同学讨论算法题目的时候，突然讲到为什么java的速度比c++慢，当时一知半解，雾里看花。<br>于是回来之后查了一下资料，整理一下放在这里，方便以后查看。<br>暂时理解到这个程度，如果以后有新的理解再做补充。</p>
<a id="more"></a>
<h2 id="明确原则"><a href="#明确原则" class="headerlink" title="明确原则"></a>明确原则</h2><p>首先，我们要明确一个放之世界皆准的原则:</p>
<blockquote>
<p>在资源一定的情况下，鱼与熊掌不可得兼。</p>
</blockquote>
<p>在程序运行方面，也就是说效率和便捷性往往不能同时满足。</p>
<p>c++ 和java的比较就是一个很典型的例子。java的抽象层级要比c++高一点，很多情况下java语言已经替我们做出了选择（可能是考虑了全局的程序性能之后得到的最优解），所以用起来就比较方便，但是这就有可能放弃了对于某些特定问题的更优的选择（可能他们仅仅在某几类问题上性能优秀，但是全局所有问题来看不是那么理想）也就在一定程度上损失了效率。</p>
<p>比如我们在使用java语言的时候可以直接通过obj.method()这种方式进行调用，它默认传递的都是引用。但是我们如果使用的是c++，那么就需要自己来确定我们的方法参数传的是指针还是引用，根据不同的选择在方法内部也有不同的使用方式。</p>
<h2 id="原因浅析"><a href="#原因浅析" class="headerlink" title="原因浅析"></a>原因浅析</h2><h3 id="编译过程不一样"><a href="#编译过程不一样" class="headerlink" title="编译过程不一样"></a>编译过程不一样</h3><p>在前面我们已经介绍过c++ 的编译过程，g++编译器可以直接将我们的源码编译成为机器可以执行的二进制代码（机器指令的集合），从而直接执行。</p>
<p>而对于java语言，java编译器会将java源码解析成字节码（独立于CPU架构，cpu不认识），然后字节码会被JVM加载然后再编译成当前cpu架构所对应的二进制代码（机器指令的集合）然后再执行。</p>
<p>简而言之，java在源码与机器指令之间又加了一层字节码的处理，这样可以保证在不同的机器上运行，但是相比于c++直接编译到机器指令来讲就会慢很多。</p>
<h3 id="对象的创建不同"><a href="#对象的创建不同" class="headerlink" title="对象的创建不同"></a>对象的创建不同</h3><p>在java中一切皆对象（这里忽略基本数据类型的情况），而对象的创建是通过new来实现的，也就是说对象本身都是保存在堆内存中的，而栈内存中仅仅保存了一个对象的引用。这样在获得对象的时候实际上可以认为是间接寻址，速度就会比较慢。</p>
<p>而在c++ 中，很多局部变量和对象的创建都是保存在栈中的，可以直接访问，所以效率就会很高。</p>
<h3 id="检查机制不同"><a href="#检查机制不同" class="headerlink" title="检查机制不同"></a>检查机制不同</h3><p>java虚拟机本身在运行时会对程序进行很多的检查，比如说检查数组越界，检查类型是否错误，检查是否空指针，检查对象是否需要回收(JVM)等等，比较充分的保证了java程序的安全性和稳定性，但是也浪费了检查的时间。</p>
<p>但是在c++程序中，这些检查都是需要程序员自己进行检查判断和处理的，如果程序员不写，那就硬着头皮执行，所以效率会很高，但是安全性和稳定性会有一定的损失。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.iteye.com/blog/leowzy-819206" target="_blank" rel="noopener">java运行速度比C++慢的原因</a></li>
<li><a href="https://www.zhihu.com/question/22050405" target="_blank" rel="noopener">知乎-为什么说 Java 比 C / C++ 慢？</a></li>
</ol>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Why</tag>
      </tags>
  </entry>
  <entry>
    <title>make命令与MakeFile文件</title>
    <url>/2019/12/05/make%E5%91%BD%E4%BB%A4%E4%B8%8EMakeFile%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>前面三篇文章主要讲述了c++的编译过程，本篇文章主要讲述用Makefile文件来定义编译过程，用make命令来对项目进行构建，从而项目在编译过程中存在的各种依赖等可以程序化生成并保持最新版本，一次编写，永久受益。</p>
<a id="more"></a>

<h2 id="make与Makefile是什么"><a href="#make与Makefile是什么" class="headerlink" title="make与Makefile是什么"></a>make与Makefile是什么</h2><h3 id="make命令"><a href="#make命令" class="headerlink" title="make命令"></a>make命令</h3><p>源代码变成可执行文件的过程，叫做编译（compile）；而对一整个项目而言，先编译这个文件还是先编译另外一个文件的过程叫做构建（build），make命令是一个GNU组织提供的一个构建工具，诞生于1977年，起初主要应用于c语言的项目，但是实际上，任何只要有某个文件有变化就要重新构建的项目，就可以用make来进行构建。</p>
<h3 id="Makefile文件"><a href="#Makefile文件" class="headerlink" title="Makefile文件"></a>Makefile文件</h3><p>make是一个构建的命令，而具体的规则都是写在MakeFile文件中的。</p>
<h2 id="如何编写makefile文件"><a href="#如何编写makefile文件" class="headerlink" title="如何编写makefile文件"></a>如何编写makefile文件</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Makefile文件由一系列的规则（rules）构成，每条规则的形式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt;</span><br><span class="line">[tab] &lt;commands&gt;</span><br></pre></td></tr></table></figure>
<p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p>
<p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。</p>
<p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。</p>
<h3 id="目标-target"><a href="#目标-target" class="headerlink" title="目标(target)"></a>目标(target)</h3><ol>
<li>目标指的是具体要生成的文件名字,也可以是文件的列表。</li>
<li>目标也可以是某个操作的名字，这称作“伪目标”（phony target）</li>
</ol>
<h3 id="前置条件-prerequisites"><a href="#前置条件-prerequisites" class="headerlink" title="前置条件(prerequisites)"></a>前置条件(prerequisites)</h3><ol>
<li>前置条件通常是一组文件名，中间用空格分隔。</li>
<li>前置条件指定了“目标”是否要重新构建的判断标准：只要有一个前置文件不存在，或者有过更新，那么目标就需要重新构建。</li>
</ol>
<h3 id="命令-commands"><a href="#命令-commands" class="headerlink" title="命令(commands)"></a>命令(commands)</h3><ol>
<li>命令表示如何构建或者更新目标文件，由一行或者多行的shell命令组成，他是构成“目标”的具体指令，他的运行结果通常就是生成目标文件。</li>
<li>每行命令之前必须有一个tab键。</li>
<li>需要注意，每行命令在一个单独的shell中执行，这些shell没有独立关系，如果需要，可以在换行符前加反斜杠转义。</li>
</ol>
<h2 id="如何使用make命令"><a href="#如何使用make命令" class="headerlink" title="如何使用make命令"></a>如何使用make命令</h2><h3 id="有目标无条件"><a href="#有目标无条件" class="headerlink" title="有目标无条件"></a>有目标无条件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    echo &apos;this is the a.txt&apos; &gt; a.txt</span><br></pre></td></tr></table></figure>
<p>解释：目标是创建a.txt, 没有前置条件。具体的执行命令是将“this is the a.txt”这个字符串写入到a.txt中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make t.txt //执行Makefile文件  </span><br><span class="line">cat a.txt //查看a.txt文件内容，发现就是this is the a.txt。</span><br></pre></td></tr></table></figure>
<h3 id="有目标有条件"><a href="#有目标有条件" class="headerlink" title="有目标有条件"></a>有目标有条件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b.txt : a.txt</span><br><span class="line">    cat a.txt &gt; b.txt</span><br></pre></td></tr></table></figure>
<p>解释：目标是创建b.txt，前置条件是要有a.txt文件，具体命令是将a.txt的内容输出到b.txt中去。</p>
<h3 id="伪目标无前置条件"><a href="#伪目标无前置条件" class="headerlink" title="伪目标无前置条件"></a>伪目标无前置条件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br></pre></td></tr></table></figure>
<p>解释：目标是clean，没有前置条件，具体命令是将所有的txt文件删除。<br>这里要说明一下，如果当前目录下也有一个叫做clean的文件，那么上述命令便不会执行了，所以我们可以声明这个命令是一个“伪目标”,也就是说变成了如下的样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br></pre></td></tr></table></figure>
<h3 id="阶段小结"><a href="#阶段小结" class="headerlink" title="阶段小结"></a>阶段小结</h3><p>按照前面部分的介绍，我们可以得到如下内容的Makefile文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    echo &apos;this is the a.txt&apos; &gt; a.txt</span><br><span class="line"></span><br><span class="line">b.txt : a.txt</span><br><span class="line">    cat a.txt &gt; b.txt</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br></pre></td></tr></table></figure>
<p>其实这个时候我们如果直接执行make命令，那么会默认执行第一条规则，也就是说，对于上面的Makefile文件，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make a.txt</span><br></pre></td></tr></table></figure>
<p>是等价的。</p>
<h3 id="前置条件不符"><a href="#前置条件不符" class="headerlink" title="前置条件不符"></a>前置条件不符</h3><p>还是在之前的Makefile的基础上继续修改。这个时候我们想创建c.txt,但是我们当前没有d.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.txt : d.txt</span><br><span class="line">    echo &apos;test no prerequists with c.txt&apos; &gt;c.txt</span><br></pre></td></tr></table></figure>
<p>这个时候执行make c.txt命令，肯定会报错，报错信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make: *** No rule to make target `d.txt&apos;, needed by `c.txt&apos;.  Stop.</span><br></pre></td></tr></table></figure>
<h2 id="MakeFile语法"><a href="#MakeFile语法" class="headerlink" title="MakeFile语法"></a>MakeFile语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是注释</span><br><span class="line">.PHONY :print</span><br><span class="line">print :</span><br><span class="line">    # 这也是注释</span><br><span class="line">    echo &apos;hello world&apos;  #这还是注释</span><br></pre></td></tr></table></figure>
<p>通过如下命令执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make print</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  maketest git:(dev) ✗ make print</span><br><span class="line"># 这也是注释</span><br><span class="line">echo &apos;hello world&apos;  #这还是注释</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>大家会发现，print对应的命令也打印出来了，这就涉及了回声这个概念</p>
<h3 id="回声（echoing）"><a href="#回声（echoing）" class="headerlink" title="回声（echoing）"></a>回声（echoing）</h3><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。<br>所以上面print执行的时候，会将命令的内容也打印出来，然后才是真正的执行结果。<br><strong>在命令的前面加上@，就可以关闭回声</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.PHONY :printnoecho</span><br><span class="line">printnoecho :</span><br><span class="line">    @echo &apos;hello world&apos;</span><br></pre></td></tr></table></figure>
<p>输出结果就不会有命令内容，而仅仅剩下执行结果了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  maketest git:(dev) ✗ make printnoecho</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h3 id="自定义赋值"><a href="#自定义赋值" class="headerlink" title="自定义赋值"></a>自定义赋值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt = &apos;hello world&apos;</span><br><span class="line">printxt:</span><br><span class="line">    @echo $(txt)</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make printxt</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h3 id="编译多个文件"><a href="#编译多个文件" class="headerlink" title="编译多个文件"></a>编译多个文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALL  =  d.txt e.txt \</span><br><span class="line">f.txt</span><br><span class="line"></span><br><span class="line">all : $(ALL)</span><br><span class="line">    echo &apos;all&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d.txt : a.txt</span><br><span class="line">    cat a.txt &gt; d.txt</span><br><span class="line"></span><br><span class="line">e.txt : d.txt</span><br><span class="line">    cat d.txt &gt; e.txt</span><br><span class="line"></span><br><span class="line">f.txt : d.txt e.txt  </span><br><span class="line">    cat d.txt e.txt &gt; f.txt</span><br></pre></td></tr></table></figure>
<p>然后执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make all</span><br></pre></td></tr></table></figure>
<p>会发现d.txt,e.txt,f.txt都会得到创建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  maketest git:(dev) ✗ make all</span><br><span class="line">cat a.txt &gt; d.txt</span><br><span class="line">cat d.txt &gt; e.txt</span><br><span class="line">cat d.txt e.txt &gt; f.txt</span><br><span class="line">echo &apos;all&apos;</span><br><span class="line">all</span><br></pre></td></tr></table></figure>
<h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$@ : 当前目标</span><br><span class="line">$&lt; : 指代第一个前置条件</span><br><span class="line">$^ : 指代所有的前置条件</span><br></pre></td></tr></table></figure>
<p>暂时先写这些，以后遇到什么问题再做补充。</p>
<h2 id="本文的代码文件"><a href="#本文的代码文件" class="headerlink" title="本文的代码文件"></a>本文的代码文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    echo &apos;this is the a.txt&apos; &gt; a.txt</span><br><span class="line"></span><br><span class="line">b.txt : a.txt</span><br><span class="line">    cat a.txt &gt; b.txt</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    rm  *.txt</span><br><span class="line"></span><br><span class="line">c.txt : d.txt</span><br><span class="line">    echo &apos;test no prerequists with c.txt&apos; &gt;c.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这是注释</span><br><span class="line">.PHONY :print</span><br><span class="line">print :</span><br><span class="line">    # 这也是注释</span><br><span class="line">    echo &apos;hello world&apos;  #这还是注释</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY :printnoecho</span><br><span class="line">printnoecho :</span><br><span class="line">    @echo &apos;hello world&apos; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">compile : %.cpp</span><br><span class="line">    g++ -o %.cpp %.cpp </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">txt = &apos;hello world&apos;</span><br><span class="line">printxt:</span><br><span class="line">    @echo $(txt)</span><br><span class="line"></span><br><span class="line">printcc:</span><br><span class="line">    $(CC) -o test test.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALL  =  d.txt e.txt \</span><br><span class="line">f.txt</span><br><span class="line"></span><br><span class="line">all : $(ALL)</span><br><span class="line">    echo &apos;all&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d.txt : a.txt</span><br><span class="line">    cat a.txt &gt; d.txt</span><br><span class="line"></span><br><span class="line">e.txt : d.txt</span><br><span class="line">    cat d.txt &gt; e.txt</span><br><span class="line"></span><br><span class="line">f.txt : d.txt e.txt  </span><br><span class="line">    cat d.txt e.txt &gt; f.txt</span><br></pre></td></tr></table></figure>

<h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><ol>
<li><a href="https://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">Make 命令教程-阮一峰</a> </li>
<li><a href="https://www.cnblogs.com/wujing-hubei/p/5223113.html" target="_blank" rel="noopener">makefile文件编写</a></li>
<li><a href="https://blog.csdn.net/u014066037/article/details/54602273" target="_blank" rel="noopener">Makefile文件编写</a></li>
</ol>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>终探c++编译过程</title>
    <url>/2019/12/03/%E7%BB%88%E6%8E%A2c-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。<br>本篇文章探究c++编译过程的第三篇，属于本系列暂时的最后一篇，总结了本次对于整个编译过程的探究结果，同时解释了动态链接和静态链接以及g++和gcc的一些区别和联系。</p>
<a id="more"></a>
<p>其实c++编译过程很复杂，一本《编译原理》让无数从业人员感到自己能力有限，我们这里介绍的仅仅是最简单的，比较概括性的内容，如果想继续深入了解可以自行去看《编译原理》书籍。</p>
<h2 id="编译过程总结"><a href="#编译过程总结" class="headerlink" title="编译过程总结"></a>编译过程总结</h2><p><img src="http://q1tldblw4.bkt.clouddn.com/qiniu_kwimg20191203232929.png" alt=""><br>我们现在应用的g++编译器其实是一个比较成熟的工具，内部细节我们不做深入探讨。但是从总体上来讲，它将整个编译过程分成了如下的四个步骤：</p>
<h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><h4 id="g-执行编译"><a href="#g-执行编译" class="headerlink" title="g++执行编译"></a>g++执行编译</h4><p>从源代码文件变成预处理之后的源代码文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -E helloword.cpp helloword.ii</span><br></pre></td></tr></table></figure>
<h4 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h4><p>简单点说，就是将代码进行整合，包括宏定义，include等都替换进来，没用的东西都删掉，比如注释等。</p>
<p>详细点说<br>预处理相当于根据预处理指令组装新的C/C++程序。经过预处理，会产生一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件，这个文件的含义同原本的文件无异，只是内容上有所不同。</p>
<ol>
<li>读取C/C++源程序，对其中的伪指令（以#开头的指令）进行处理<ol>
<li>将所有的“#define”删除，并且展开所有的宏定义</li>
<li>处理所有的条件编译指令，如：“#if”、“#ifdef”、“#elif”、“#else”、“endif”等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。</li>
</ol>
</li>
</ol>
<p>（注意：这个过程可能是递归进行的，也就是说被包含的文件可能还包含其他文件）<br>2. 删除所有的注释<br>3. 添加行号和文件名标识<br>以便于编译时编译器产生调试用的行号信息及用于编译时产生的编译错误或警告时能够显示行号<br>4. 保留所有的#pragma编译器指令</p>
<h3 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h3><h4 id="g-执行编译-1"><a href="#g-执行编译-1" class="headerlink" title="g++执行编译"></a>g++执行编译</h4><p>从源代码文件变成汇编代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -S helloword.cpp helloword.s</span><br></pre></td></tr></table></figure>
<h4 id="原理解释-1"><a href="#原理解释-1" class="headerlink" title="原理解释"></a>原理解释</h4><p>将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件。</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><h4 id="g-执行编译-2"><a href="#g-执行编译-2" class="headerlink" title="g++执行编译"></a>g++执行编译</h4><p>从源代码文件变成对象文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -c talk.cpp -o talk.o</span><br><span class="line">g++ -c talktest.cpp -o talktest.o</span><br></pre></td></tr></table></figure>
<h4 id="原理解释-2"><a href="#原理解释-2" class="headerlink" title="原理解释"></a>原理解释</h4><p><strong>将编译完的汇编代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。</strong></p>
<p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="gcc执行编译"><a href="#gcc执行编译" class="headerlink" title="gcc执行编译"></a>gcc执行编译</h4><p>从对象文件变成可执行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ talk.o talktest.o -o talktest</span><br><span class="line">./talktest</span><br></pre></td></tr></table></figure>
<p>也可以从源代码文件变成可执行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ helloword.cpp -o helloworld</span><br><span class="line">./helloworld</span><br></pre></td></tr></table></figure>
<h4 id="原理解释-3"><a href="#原理解释-3" class="headerlink" title="原理解释"></a>原理解释</h4><p>通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序</p>
<h2 id="关于链接过程"><a href="#关于链接过程" class="headerlink" title="关于链接过程"></a>关于链接过程</h2><p>在编译器的第四步链接的时候，主要工作是将对象文件和标准库中的文件进行链接，打包成可执行文件，这个大家应该已经很清楚啦。那么怎么链接呢？</p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>静态链接是直接将所需要的库都直接嵌入到我们的主程序中，然后直接打包成可执行程序。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>在主程序中仅仅对这个库进行一次声明，等到程序执行到这个地方的时候，再去引用这个库。</p>
<h3 id="共同存在的必要性"><a href="#共同存在的必要性" class="headerlink" title="共同存在的必要性"></a>共同存在的必要性</h3><p>静态库有容易使用和理解，而且也达到了代码复用的目的，那为什么我们还要有动态库呢？</p>
<ol>
<li>静态库容易造成空间浪费。</li>
<li>静态库对程序的更新、部署和发布页会带来麻烦</li>
</ol>
<p>这两个缺点也就决定了动态库存在的必要性。</p>
<ol>
<li>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。</li>
<li>动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</li>
</ol>
<h2 id="Gcc和G-区别与联系"><a href="#Gcc和G-区别与联系" class="headerlink" title="Gcc和G++区别与联系"></a>Gcc和G++区别与联系</h2><p>gcc和g++都是<a href="https://en.wikipedia.org/wiki/GNU" target="_blank" rel="noopener">GNU组织</a>的编译器。<br>1、对于.c后缀的文件，gcc把它当做是C程序；g++ 当做是C++程序；<br>2、对于.cpp后缀的文件，gcc和g++ 都会当做c++程序。<br>3、编译阶段，g++ 会调用gcc；<br>4、连接阶段，通常会用g++ 来完成，这是因为gcc命令不能自动和c++程序使用的库连接</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/wcc27857285/article/details/84945519" target="_blank" rel="noopener">C/C++ 程序编译过程详解</a></li>
<li><a href="https://blog.csdn.net/baidu_33604078/article/details/79091049" target="_blank" rel="noopener">程序编译的四个过程</a></li>
<li><a href="https://www.cnblogs.com/mickole/articles/3659112.html" target="_blank" rel="noopener">C/C++程序编译过程详解</a></li>
<li><a href="https://www.cnblogs.com/skynet/p/3372855.html" target="_blank" rel="noopener">C++静态库与动态库</a></li>
</ol>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>再探c++编译过程</title>
    <url>/2019/12/03/%E5%86%8D%E6%8E%A2c-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。<br>本篇文章探究c++编译过程的第二篇，主要解释了第一篇中的一些现象，同时尝试编译出预处理文件、汇编文件、对象文件等编译过程中的中间产物。</p>
<a id="more"></a>
<h2 id="编译原理解释"><a href="#编译原理解释" class="headerlink" title="编译原理解释"></a>编译原理解释</h2><h3 id="编译器的作用"><a href="#编译器的作用" class="headerlink" title="编译器的作用"></a>编译器的作用</h3><p>编译器 g++ 通过检查命令行中指定的文件的后缀名可识别其为 C++ 源代码文件。</p>
<p>编译器默认的动作：编译源代码文件生成<strong>对象文件(object file)</strong>，将<strong>对象文件</strong>和 <strong>libstdc++ 库中的函数</strong>进行链接得到可执行程序。</p>
<h3 id="c-编程中常见文件后缀"><a href="#c-编程中常见文件后缀" class="headerlink" title="c++编程中常见文件后缀"></a>c++编程中常见文件后缀</h3><table>
    <tbody>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.a</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">静态库 (archive)</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.C
        <br>.c
        <br>.cc
        <br>.cp
        <br>.cpp
        <br>.cxx
        <br>.c++</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">C++源代码（需要编译预处理）</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.h</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">C或者C++源代码头文件</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.ii</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">C++源代码（不需编译预处理）</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.o</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">对象文件</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.s</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">汇编语言代码</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>.so</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">动态库</td></tr>
  <tr>
    <td style="font-family:verdana, sans-serif;font-size:12px;">
      <strong>&lt;none&gt;</strong></td>
    <td style="font-family:verdana, sans-serif;font-size:12px;">标准C++系统头文件</td></tr>
</tbody>
</table>

<h3 id="初探解疑"><a href="#初探解疑" class="headerlink" title="初探解疑"></a>初探解疑</h3><ol>
<li>初探过程中，当我们直接通过如下命令编译出最后的执行文件的过程中，<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure>
其实是存在中间状态文件的，也就是编译过程中所说到的<strong>对象文件</strong>，查表可知应该是以.o为后缀的文件。</li>
<li>初探过程中，当我们将头文件talk.h和实现源文件talk.cpp分开之后，然后只编译测试文件talktest.cpp的时候是报错的，那么现在我们就可以理解为什么报错了，原因在于最终的可执行文件是要链接对象文件和标准库中的文件形成的，而对象文件是必须要通过cpp等c++源代码编译形成的，所以对于我们自己编写的cpp文件是一定要经过自己手动编译才能参与到后续的链接过程中的。</li>
</ol>
<h2 id="再探c-编译过程"><a href="#再探c-编译过程" class="headerlink" title="再探c++编译过程"></a>再探c++编译过程</h2><h3 id="生成对象文件"><a href="#生成对象文件" class="headerlink" title="生成对象文件"></a>生成对象文件</h3><p>1.利用初探中写好的talk.h,talk.cpp,talktest.cpp文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.h</span><br><span class="line">*/</span><br><span class="line">class Talk&#123;</span><br><span class="line">    public:</span><br><span class="line">        void say(const char*); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.cpp</span><br><span class="line">*/</span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">void Talk::say(const char* str)&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;talk with&quot;&lt;&lt;&apos;\t&apos;&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talktest.cpp</span><br><span class="line">*/</span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Talk talk;</span><br><span class="line">    talk.say(&quot;kingwen&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>直接编译出对象文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -c talk.cpp</span><br><span class="line">g++ -c talktest.cpp</span><br></pre></td></tr></table></figure></li>
<li><p>查看当前文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>可以发现多了两个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">talk.o talktest.o</span><br></pre></td></tr></table></figure></li>
<li><p>编译对象文件生成可执行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ talk.o talktest.o -o talktest1</span><br></pre></td></tr></table></figure></li>
<li><p>执行talktest1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./talktest1</span><br></pre></td></tr></table></figure>
<p>结果和我们执行直接生成编译结果是一样的,结果如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">talk with   kingwen</span><br></pre></td></tr></table></figure></li>
<li><p>对象文件输出<br>我们在第二步中是通过<strong>gcc -c talk.cpp</strong>直接编译出了<strong>talk.o</strong>这个对象。<br>这里会使得编译结果的默认名称和源码名称一致。但是我们其实可以自定义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -c talk.cpp -o talker.o</span><br><span class="line">g++ -c talktest.cpp -o talkertest.o</span><br></pre></td></tr></table></figure>
<p>然后编译运行方式和前面说明的一致即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ talker.o talkertest.o -o talkertest</span><br><span class="line">./talkertest</span><br></pre></td></tr></table></figure>
<p>最后得到的结果也和之前是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">talk with   kingwen</span><br></pre></td></tr></table></figure>
<p>PS:所以如果以后在编码过程中如果碰见说缺少对象文件，那么就是对应的cpp源代码文件没有编译，我们可以通过g++命令对其进行编译即可解决问题。</p>
<h3 id="生成预处理文件"><a href="#生成预处理文件" class="headerlink" title="生成预处理文件"></a>生成预处理文件</h3></li>
<li><p>找到初探中的helloworld.cpp代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">  helloworld.cpp </span><br><span class="line">  用于测试g++编译单个源文件生成可执行程序</span><br><span class="line">*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;hello world&quot;&lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过wc命令来查看helloworld.cpp文件的行数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  compilec++ wc -l helloworld.cpp</span><br><span class="line">       8 helloworld.cpp</span><br></pre></td></tr></table></figure></li>
<li><p>代码预处理<br>通过如下命令会将预处理的结果在标准输出中进行输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -E helloworld.cpp</span><br></pre></td></tr></table></figure>
<p>当然我们也可以将结果进行输出保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -E helloworld.cpp -o helloworld.ii</span><br></pre></td></tr></table></figure>
<p>通过wc命令来查看预处理结果helloworld.ii的行数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compilec++ wc -l helloworld.ii</span><br><span class="line">  41484 helloworld.ii</span><br></pre></td></tr></table></figure>
<p>可以发现文件大小有了翻天覆地的变化，这里主要就是将头文件等引入了我们的文件中。</p>
</li>
</ol>
<h3 id="生成汇编文件"><a href="#生成汇编文件" class="headerlink" title="生成汇编文件"></a>生成汇编文件</h3><ol>
<li>同样还是之前的helloworld.cpp代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">  helloworld.cpp </span><br><span class="line">  用于测试g++编译单个源文件生成可执行程序</span><br><span class="line">*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;hello world&quot;&lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>直接编译生成汇编代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -S helloworld.cpp -o helloworld.s</span><br></pre></td></tr></table></figure></li>
<li>查看生成的汇编代码<br>其实可以使用cat或者head或者tail进行查看，<br>这里我用的是sed命令查看了从1360到1372行，因为我觉得这块代码更加符合我对汇编的想象。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &apos;1360,1372p&apos; helloworld.s</span><br></pre></td></tr></table></figure>
结果如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compilec++ sed -n &apos;1360,1372p&apos; helloworld.s</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register %rbp</span><br><span class="line">    movl    %edi, -4(%rbp)</span><br><span class="line">    movl    %esi, -8(%rbp)</span><br><span class="line">    movl    -4(%rbp), %esi</span><br><span class="line">    cmpl    -8(%rbp), %esi</span><br><span class="line">    sete    %al</span><br><span class="line">    andb    $1, %al</span><br><span class="line">    movzbl  %al, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    retq</span><br><span class="line">    .cfi_endproc</span><br><span class="line">                                        ## -- End function</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><a href="https://blog.csdn.net/guoxiaoqian8028/article/details/18915513" target="_blank" rel="noopener">GCC编译C++</a></li>
</ol>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>初探c++编译过程</title>
    <url>/2019/12/03/%E5%88%9D%E6%8E%A2c-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>在科研项目中碰到了一个c++的程序，需要自己进行编译，所以就顺带着复习了一波c++的编译过程。<br>本篇文章探究c++编译过程的第一篇，主要尝试编译单个源文件和多个源文件生成可执行文件。</p>
<a id="more"></a>
<h3 id="单个源文件生成可执行程序"><a href="#单个源文件生成可执行程序" class="headerlink" title="单个源文件生成可执行程序"></a>单个源文件生成可执行程序</h3><ol>
<li><p>编写helloworld源代码，文件后缀是cpp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* helloworld.cpp */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;hello world&quot;&lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过gcc编译器对其进行编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ helloworld.cpp</span><br><span class="line">或者</span><br><span class="line">g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure>
<p>如果是第一条命令，g++会编译helloworld.cpp文件产生a.out文件，a.out是默认文件名；<br>但是更多情况下我们使用g++编译文件的时候会通过-o参数来指定生成的可执行文件的文件名。比如这里生成的文件名就叫做helloworld</p>
</li>
<li><p>查看当前目录文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>因为执行了两次不同的编译，所以当前目录下会有三个文件，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.out  helloworld  helloworld.cpp</span><br></pre></td></tr></table></figure></li>
<li><p>执行文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./a.out</span><br><span class="line">或者</span><br><span class="line">./helloworld</span><br></pre></td></tr></table></figure>
<p>这里两次结果是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h3 id="两个源文件生成可执行程序"><a href="#两个源文件生成可执行程序" class="headerlink" title="两个源文件生成可执行程序"></a>两个源文件生成可执行程序</h3><p>这一部分我们自己编写一个头文件speak.h,然后编写一个测试文件speaktest.cpp进行编译测试。</p>
</li>
<li><p>编写speak.h代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">speak.h</span><br><span class="line">用于测试g++编译多个文件形成一个可执行文件</span><br><span class="line">*/</span><br><span class="line">#ifndef __SPEAK__</span><br><span class="line">#define __SPEAK__</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Speak&#123;</span><br><span class="line">    public:</span><br><span class="line">        void sayHello(const char* );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Speak::sayHello(const char* str)&#123;</span><br><span class="line">    std::cout&lt;&lt; &quot;hello&quot; &lt;&lt;&apos;\t&apos;&lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li>
<li><p>编写speaktest.cpp代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">speaktest.cpp</span><br><span class="line">用于测试g++编译多个文件形成一个可执行文件</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &quot;speak.h&quot;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Speak speak;</span><br><span class="line">    speak.sayHello(&quot;kingwen&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>g++编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ speaktest.cpp -o speaktest</span><br></pre></td></tr></table></figure></li>
<li><p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./speaktest</span><br></pre></td></tr></table></figure>
<p>结果很符合我们的预期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello   kingwen</span><br></pre></td></tr></table></figure>
<p>所以我们可以得出很明显的结论，就是我们的.h其实只要在最终的测试文件中include，不需要自己再手动编译一次，这非常符合编译原理课程中的讲述。</p>
</li>
</ol>
<p>这里我们就发现一个问题，我们的speak.h头文件其实和它的实现都在同一个文件中，但是很多情况下，头文件只负责声明，具体实现是通过其他文件来实现的，如果碰到这种情况我们还可以通过只编译测试文件就能运行嘛？来测试一下。</p>
<h3 id="声明和实现分离生成可执行程序"><a href="#声明和实现分离生成可执行程序" class="headerlink" title="声明和实现分离生成可执行程序"></a>声明和实现分离生成可执行程序</h3><ol>
<li>编写talk.h文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.h</span><br><span class="line">用于测试当talk的声明和实现分离，那么在测试的时候能不能只编译测试文件。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Talk&#123;</span><br><span class="line">    public:</span><br><span class="line">        void say(const char*); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>编写talk.cpp文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talk.cpp</span><br><span class="line">用于测试当talk的声明和实现分离，那么在测试的时候能不能只编译测试文件。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">void Talk::say(const char* str)&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;talk with&quot;&lt;&lt;&apos;\t&apos;&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写talktest.cpp文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">talktest.cpp</span><br><span class="line">用于测试当talk的声明和实现分离，那么在测试的时候能不能只编译测试文件。</span><br><span class="line">*/</span><br><span class="line">#include &quot;talk.h&quot;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Talk talk;</span><br><span class="line">    talk.say(&quot;kingwen&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>尝试编译<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ talktest.cpp -o talktest</span><br></pre></td></tr></table></figure>
注意，这个时候报错了！！！<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  compilec++ g++ talktest.cpp -o talktest</span><br><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;Talk::say(char const*)&quot;, referenced from:</span><br><span class="line">      _main in talktest-2630f3.o</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>
原因其实是没有找到Talk中say方法的实现。<br>那么我们尝试连同talk.cpp一起编译<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ talktest.cpp talk.cpp -o talktest</span><br></pre></td></tr></table></figure>
这个时候就可以编译通过啦，而且经过我的测试中间talktest.cpp和talk.cpp的顺序交换是没有关系的。</li>
<li>执行结果<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./talktest</span><br></pre></td></tr></table></figure>
结果非常符合预期<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">talk with   kingwen</span><br></pre></td></tr></table></figure>
由此，我们可以解释我们小节提出的疑问了，如果声明和实现不在同一个地方，那么对于实现文件是需要进行编译的，否则就会报错。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://blog.csdn.net/guoxiaoqian8028/article/details/18915513" target="_blank" rel="noopener">GCC编译C++</a></li>
</ol>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>Make-MacOs-Support-NTFS</title>
    <url>/2019/12/01/Make-MacOs-Support-NTFS/</url>
    <content><![CDATA[<p>我有一个2T的硬盘，文件格式是NTFS格式的，在MAC系统上一直能读不能写，让我很苦恼，这次从网上找了一个方法而且亲测有效，所以特地记录一下。</p>
<a id="more"></a>
<h2 id="什么是NTFS"><a href="#什么是NTFS" class="headerlink" title="什么是NTFS"></a>什么是<a href="https://zh.wikipedia.org/wiki/NTFS" target="_blank" rel="noopener">NTFS</a></h2><p>简单来讲，NTFS是微软开发的专用文件系统，Mac OS X内核能对NTFS进行有限的读操作。Linux和BSD提供自由及开放源代码的软件，可用于读写NTFS文件。</p>
<pre><code>NTFS（英语：New Technology File System），是Microsoft公司开发的专用文件系统，
从Windows NT 3.1开始成为Windows NT家族的标准文件系统。[4]
NTFS取代FAT（文件分配表）和HPFS（高性能文件系统）并进行一系列改进，例如增强对元数据的支持，
使用更高级的数据结构以提升性能、可靠性和磁盘空间利用率，并附带一系列增强功能，
如访问控制列表（ACL）和文件系统日志等。
——维基百科</code></pre><h2 id="解决措施"><a href="#解决措施" class="headerlink" title="解决措施"></a>解决措施</h2><h3 id="流程简介"><a href="#流程简介" class="headerlink" title="流程简介"></a>流程简介</h3><ol>
<li>挂载上你的NTFS硬盘，查看硬盘名称</li>
<li>编辑/etc/fstab文件，使其支持NTFS写入</li>
<li>将/Volumes中的NTFS磁盘快捷方式到Finder</li>
</ol>
<h3 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h3><ol>
<li><p>插上硬盘后，查看你的硬盘名称，这里假设名称是AngleDisk，牢记之（你的可不是这个呀！！）</p>
</li>
<li><p>打开Applications的Terminal, 你也可以直接spotlight输入terminal打开</p>
</li>
<li><p>在终端输入sudo nano /etc/fstab 敲击回车</p>
</li>
<li><p>现在你看到了一个编辑界面，输入LABEL=AngleDisk none ntfs rw,auto,nobrowse后，敲击回车，再Ctrl+X，再敲击Y，再敲击回车</p>
</li>
<li><p>此时，退出你的移动硬盘，再重新插入，你会发现磁盘没有显示再桌面或是Finder之前出现的地方，别慌</p>
</li>
<li><p>打开Finder，Command+Shift+G，输入框中输入/Volumes，回车，你就可以看到你的磁盘啦！是可以读写的哟，Enjoy</p>
</li>
<li><p>方便起见，你可以直接把磁盘拖到Finder侧边栏中，这样下次使用就不用进入到/Volumes目录打开了</p>
</li>
</ol>
<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://blog.csdn.net/u013247765/article/details/77932144" target="_blank" rel="noopener">无需第三方软件实现Mac支持ntfs读写的最简单操作</a></p>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>MacOs</tag>
        <tag>NTFS</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-207-CourseSchedule</title>
    <url>/2019/12/01/leetcode-207-CourseSchedule/</url>
    <content><![CDATA[<p>这个是leetcode中为数不多的关于Graph的题目，判断图中是否有环，可以用BFS或者DFS两种思路进行求解。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 2, [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class="line">             also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>BFS或者DFS</p>
<h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><p>其实这个题目就是说对于每一个课程都有一个前置课程，然后问如果前置课程这样安排能不能成立，其实就可以抽象出查看一个图中是否有环，因为一旦有环路，那肯定是不成立的，反之，肯定成立。</p>
<h3 id="BFS思路"><a href="#BFS思路" class="headerlink" title="BFS思路"></a>BFS思路</h3><p>我们创建一个队列，用于保存目前入度为0的点，然后我们对于每个节点都保存一个入度的值。然后从入度为0的值开始，进行遍历，对于这个点能达到的所有的点将其入度减去1，如果此时这个点入度为0，将其加入到队列中。当队列为空的时候，如果此时所有节点的入读都变成0，那么肯定没有环路，否则有环路。<br>举例说明,假设输入是如下情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 [[1,0],[2,0],[1,2],[3,1]]</span><br></pre></td></tr></table></figure>
<p>对应的图其实就是<br><img src="http://q1tldblw4.bkt.clouddn.com/qiniu_kwimg20191201143417.png" alt=""></p>
<p>1.初始化队列q中元素只有0，入度数组arr=[0,2,1,1]<br>2. 然后经过0号节点，arr变为[0,1,0,1],此时2号加入队列<br>3. 然后处理2号节点，arr变成[0,0,0,1],此时1号加入队列<br>4. 然后处理1号节点，arr变成[0,0,0,0] 此时3号加入队列<br>5. 然后处理3号节点，arr变成[0,0,0,0] 此时队列为空。<br>6. 然后判断arr数组中每个节点的入度是否是0，全为0，返回true。</p>
<h3 id="DFS思路"><a href="#DFS思路" class="headerlink" title="DFS思路"></a>DFS思路</h3><p>DFS就是用深度优先搜索，我们对于每个节点记录一个状态，-1表示是当前节点：如果在遍历过程中发现了-1，说明又回到了自身，那就是有环路，返回flase；0是默认值，代表之前还没有访问；1表示已经访问过了。对于每一个节点都进行如此的遍历，即可得到结果。<br>PS：要记得传引用而不要传对象本身，否则容易Time Limit Exceeded</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="BFS解题代码"><a href="#BFS解题代码" class="headerlink" title="BFS解题代码"></a>BFS解题代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; graph(numCourses,vector&lt;int&gt;());</span><br><span class="line">        vector&lt;int&gt; in(numCourses,0);</span><br><span class="line">        for(auto a:prerequisites)&#123;</span><br><span class="line">            graph[a[1]].push_back(a[0]);</span><br><span class="line">            in[a[0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        for(int i = 0;i&lt;in.size();i++)&#123;</span><br><span class="line">            if(in[i]==0) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            auto a = q.front(); q.pop();</span><br><span class="line">            for(int b:graph[a])&#123;</span><br><span class="line">                --in[b];</span><br><span class="line">                if(in[b]==0) q.push(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i:in)&#123;</span><br><span class="line">            if(i!=0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="DFS解题代码"><a href="#DFS解题代码" class="headerlink" title="DFS解题代码"></a>DFS解题代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; graph(numCourses,vector&lt;int&gt;());</span><br><span class="line">        vector&lt;int&gt; visit(numCourses);</span><br><span class="line">        for(auto a:prerequisites)&#123;</span><br><span class="line">            graph[a[1]].push_back(a[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; numCourses; ++i)&#123;</span><br><span class="line">            if(!findSelf(graph,visit,i)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    bool findSelf(vector&lt;vector&lt;int&gt;&gt;&amp; graph,vector&lt;int&gt;&amp; visit,int i)&#123;</span><br><span class="line">        if(visit[i] == -1) return false;</span><br><span class="line">        if(visit[i] == 1) return true;</span><br><span class="line">        visit[i] = -1;</span><br><span class="line">        for(auto a:graph[i])&#123;</span><br><span class="line">            if(!findSelf(graph,visit,a)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i] = 1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Class-with-pointer-mString-Houjie-Bilibili</title>
    <url>/2019/11/22/Class-with-pointer-mString-Houjie-Bilibili/</url>
    <content><![CDATA[<p>在Bilibili跟着侯捷老师学C++系列第二篇，带指针的类mString类。<br>人生得遇良师，实属大幸，侯捷老师就属于这种老师，再夸一遍！！</p>
<a id="more"></a>
<p>因为C++的效率是最高的，所以对于C++自己一定要好好掌握，个人看法，你如果能学会C++，其他语言都将不在话下。然后刚好碰到一个非常好的教程，有一位非常棒的老师-侯捷老师，有一个好的平台-Bilibili，还有非常好的训练场地——leetcode，所以此时不学什么时候学呢？</p>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p><a href="https://www.bilibili.com/video/av19038490" target="_blank" rel="noopener">侯捷C++手把手教学(上),适合新手</a> </p>
<h2 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h2><h3 id="mstring-hpp"><a href="#mstring-hpp" class="headerlink" title="mstring.hpp"></a>mstring.hpp</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef mstring_hpp</span><br><span class="line">#define mstring_hpp</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class mstring&#123;</span><br><span class="line">public:</span><br><span class="line">    mstring(const char* a = 0);</span><br><span class="line">    mstring(const mstring&amp; str);</span><br><span class="line">    mstring&amp; operator =(const mstring&amp; str);</span><br><span class="line">    ~mstring();</span><br><span class="line">    char* get_c_str() const &#123;return mdata;&#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    char* mdata;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring::mstring(const char* a)&#123;</span><br><span class="line">    if(a)&#123;</span><br><span class="line">        mdata = new char[strlen(a)+1];</span><br><span class="line">        strcpy(mdata, a);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        mdata = new char[1];</span><br><span class="line">        *mdata = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring::mstring(const mstring&amp; str)&#123;</span><br><span class="line">    mdata = new char[std::strlen(str.mdata)+1];</span><br><span class="line">    strcpy(mdata, str.mdata);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring&amp; mstring::operator=(const mstring&amp; str)&#123;</span><br><span class="line">    if(this == &amp;str)&#123;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    this-&gt;mdata = new char[strlen(str.mdata)+1];</span><br><span class="line">    strcpy(this-&gt;mdata,str.mdata);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">mstring::~mstring()&#123;</span><br><span class="line">    delete[] mdata;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator &lt;&lt; (ostream&amp; os,const mstring&amp; str)&#123;</span><br><span class="line">    return os&lt;&lt;str.get_c_str();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif /* mstring_hpp */</span><br></pre></td></tr></table></figure>
<h3 id="mstring-cpp"><a href="#mstring-cpp" class="headerlink" title="mstring.cpp"></a>mstring.cpp</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;mstring.hpp&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    mstring s1;</span><br><span class="line">    cout&lt;&lt;&quot;s1 = &quot;&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    mstring s2(&quot;hello&quot;);</span><br><span class="line">    cout&lt;&lt;&quot;s2 = &quot;&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">    s1 = s2;</span><br><span class="line">    cout&lt;&lt;&quot;s1 = &quot;&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    mstring s3(s2);</span><br><span class="line">    cout&lt;&lt;&quot;s3 = &quot;&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    mstring *p = new mstring(&quot;world&quot;);</span><br><span class="line">    cout&lt;&lt;&quot;*p = &quot;&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 = </span><br><span class="line">s2 = hello</span><br><span class="line">s1 = hello</span><br><span class="line">s3 = hello</span><br><span class="line">*p = world</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h2><ol>
<li>构造函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mstring(const char* a = 0);</span><br></pre></td></tr></table></figure>
构造函数的名称和类名一致，没有返回值，参数可以设置默认参数（实际实现的时候就不需要再说明默认参数了）</li>
<li>拷贝构造<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mstring(const mstring&amp; str);</span><br></pre></td></tr></table></figure>
接收一个同种类型的对象作为自己的参数，然后产生一个新的对象。</li>
</ol>
<p>这里要注意深复制和浅复制的区别，深复制就是会新创建一个对象，这个对象有属于自己的内存空间，只是值和原来的是一致的。浅复制是说两个对象指向同一个内存空间，所以一旦有一个更改，另一个肯定会被更改，很危险。<br>3. 拷贝赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mstring&amp; operator =(const mstring&amp; str);</span><br></pre></td></tr></table></figure>
<p>这里首先要注意的是我们重载了运算符=，然后是当前类的方法。其次是我们传入的参数，我们不会修改，所以设置为const，是通过引用传进来的，返回值同样是一个mstring对象，我们通过引用返回。</p>
<p>对于成员函数，其实每个函数都含有一个隐藏的参数this，我们可以通过this和参数引用的地址来确定是否是自我赋值，要进行判断，否则会报错。因为具体赋值的过程是先删除本身的数据，然后创建一个能容纳str的空间的内存，然后将str内容拷贝到内存中。如果this和str指向同一个地址，那么刚开始删除掉就已经没有了，之后的创建空间就会出错。所以一定要注意这个拷贝赋值时自我赋值的问题。<br>4. 析构函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~mstring();</span><br></pre></td></tr></table></figure>
<p>析构函数是指当对象生命周期结束之后会自动调用当前对象的析构函数，主要负责释放通过new关键字请求得到的内存空间。如果不自行解决，那么new出来的这块空间就会变成无主空间，会造成内存泄露。<br>5. 对于一个带有指针的类，必须要有拷贝构造和拷贝赋值还有析构函数。<br>6. 其他成员函数的编写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* get_c_str() const &#123;return mdata;&#125;</span><br></pre></td></tr></table></figure>
<p>首先这个函数可以认为是一个辅助函数，方便之后重载&lt;&lt; 符号的，因为ostream已经被重载过所以可以输出char类型的指针所指向的数据，所以我们这里单独写一个用于输出。<br>其次要注意这个函数有个const，对于类对象本身没有更改的方法都要写上这个const。<br>然后要注意这里的返回值类型，是一个char类型的指针。<br>7. array new 一定要搭配一个array delete</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline</span><br><span class="line">mstring::mstring(const char* a)&#123;</span><br><span class="line">    if(a)&#123;</span><br><span class="line">        mdata = new char[strlen(a)+1];</span><br><span class="line">        strcpy(mdata, a);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        mdata = new char[1];</span><br><span class="line">        *mdata = &apos;\0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline</span><br><span class="line">mstring::~mstring()&#123;</span><br><span class="line">    delete[] mdata;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在构造函数中是创建了一个char类型的数组，那么在析构函数中也要以同样的方式进行释放。<br>8. 关于栈存储<br>Stack,是存在于作用域的一块内存空间，例如当你调用函数，函数本身就会形成一个stack来放置它所接收的参数，以及对应的返回地址。在函数本体中声明的任何变量，其所使用的内存块都会在上述stack中。当作用域结束，所有内存都会被回收，内存中的对象也就再也找不到了，所以这就是我们上一节所讲的不能返回一个local对象的引用或者指针而要直接返回他们本身。<br>9. 关于堆存储<br>Heap，或者叫做system heap，是指由操作系统提供的一块global的内存空间，程序可以通过new来动态分配获得若干区块。这样就需要自己来动手释放掉。<br>10. stack object的生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> complex c1(1,2);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个大括号（作用域）中创建的对象也就是所谓的local对象，比如c1,在作用域结束的时候就会被自动清理。<br>11. static local object的生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    static complex c2(1,2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个局部变量被static关键字修饰的时候,比如c2，它就是一个静态对象，其生命在作用域结束之后仍然存在，直到整个程序结束。<br>12. global objects的生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">complex c3(1,2);</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局对象，写在{}之外的对象,比如c3，其生命周期是整个程序。这个经常在算法题目中出现。<br>13. heap objects的生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    complex* p = new Complex(1,2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的p就是一个堆对象，是由动态分配生成的，在其被deleted之际才会结束。<br>14. new关键字:先分配内存，然后调用构造函数<br>15. delete关键字：先调用析构函数，然后再释放内存。</p>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Houjie</tag>
        <tag>Bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>Class-without-pointer-Complex-Houjie-Bilibili</title>
    <url>/2019/11/22/Class-without-pointer-Complex-Houjie-Bilibili/</url>
    <content><![CDATA[<p>在Bilibili跟着侯捷老师学C++系列第一篇，不带指针的类Complex类。<br>人生得遇良师，实属大幸，侯捷老师就属于这种老师！！</p>
<a id="more"></a>
<p>因为C++的效率是最高的，所以对于C++自己一定要好好掌握，个人看法，你如果能学会C++，其他语言都将不在话下。然后刚好碰到一个非常好的教程，有一位非常棒的老师-侯捷老师，有一个好的平台-Bilibili，还有非常好的训练场地——leetcode，所以此时不学什么时候学呢？</p>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p><a href="https://www.bilibili.com/video/av19038490" target="_blank" rel="noopener">侯捷C++手把手教学(上),适合新手</a> </p>
<h2 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h2><h3 id="Complex-hpp"><a href="#Complex-hpp" class="headerlink" title="Complex.hpp"></a>Complex.hpp</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef Complex_hpp</span><br><span class="line">#define Complex_hpp</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Complex&#123;</span><br><span class="line">public:</span><br><span class="line">    Complex(double r = 0, double i = 0) : re(r), im(i)&#123;&#125;</span><br><span class="line">    Complex&amp; operator += (const Complex&amp;);</span><br><span class="line">    double real() const &#123;return re;&#125;</span><br><span class="line">    double imag() const &#123;return im;&#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    double re,im;</span><br><span class="line">    </span><br><span class="line">    friend Complex&amp; _doapl(Complex*, const Complex&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif /* Complex_hpp */</span><br><span class="line"></span><br><span class="line">inline Complex&amp; Complex::operator += (const Complex&amp; c)&#123;</span><br><span class="line">    return _doapl(this,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex&amp; _doapl(Complex* ths,const Complex&amp; c)&#123;</span><br><span class="line">    ths-&gt;im += c.im;</span><br><span class="line">    ths-&gt;re += c.re;</span><br><span class="line">    return *ths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double real(const Complex&amp; r)&#123;</span><br><span class="line">    return r.real();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double imag(const Complex&amp; r)&#123;</span><br><span class="line">    return r.imag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator +(const Complex&amp; r1,const Complex r2)&#123;</span><br><span class="line">    return Complex(real(r1)+real(r2), imag(r1)+imag(r2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator + (const Complex&amp; r1, double d)&#123;</span><br><span class="line">    return Complex(real(r1)+d,imag(r1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Complex operator + (double d,const Complex&amp; r1)&#123;</span><br><span class="line">    return Complex(real(r1)+d, imag(r1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os,const Complex&amp; c)&#123;</span><br><span class="line">    return os&lt;&lt;&quot;(&quot;&lt;&lt;real(c)&lt;&lt;&quot;,&quot;&lt;&lt;imag(c)&lt;&lt;&quot;)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Complex-cpp"><a href="#Complex-cpp" class="headerlink" title="Complex.cpp"></a>Complex.cpp</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Complex.hpp&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Complex c1(2,3);</span><br><span class="line">    Complex c2;</span><br><span class="line">//   测试输出</span><br><span class="line">    cout&lt;&lt;c1&lt;&lt;endl;</span><br><span class="line">//    测试连续输出</span><br><span class="line">    cout&lt;&lt;c1&lt;&lt;c1&lt;&lt;endl;</span><br><span class="line">//    测试 +=</span><br><span class="line">    c1 += c2;</span><br><span class="line">    cout&lt;&lt; c1&lt;&lt;endl;</span><br><span class="line">//    测试+运算</span><br><span class="line">    cout&lt;&lt; c1+2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="result"><a href="#result" class="headerlink" title="result"></a>result</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(2,3)</span><br><span class="line">(2,3)(2,3)</span><br><span class="line">(2,3)</span><br><span class="line">(4,3)</span><br></pre></td></tr></table></figure>
<h2 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h2><ol>
<li>首先是要有一个防卫式声明。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef Complex_hpp</span><br><span class="line">#define Complex_hpp</span><br><span class="line"></span><br><span class="line">#endif /* Complex_hpp */</span><br></pre></td></tr></table></figure>
它的作用在于当我们写的类被其他人通过导入头文件引用的时候不会重复引用。</li>
<li>类的数据不出意外都要写在private部分,也就是下面的部分。而方法一般都是写在public部分。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private:</span><br><span class="line">    double re,im;</span><br></pre></td></tr></table></figure></li>
<li>函数的要不要加const关键字,如果没有更改类属性的值，都要加上。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double real() const &#123;return re;&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数参数要不要加const关键字，如果我们不想这个参数在方法中被修改，那么就加上。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline double real(const Complex&amp; r)&#123;</span><br><span class="line">    return r.real();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>考虑是返回值是传值还是传引用。尽量都传引用，这样可以极大的提高效率。但是当返回的值是一个局部变量的时候，要记得通过值进行返回。</li>
<li>在重载操作符的时候，考虑返回值要考虑到会不会有多重使用，然后再考虑是要无返回还是返回一个引用值。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os,const Complex&amp; c)&#123;</span><br><span class="line">    return os&lt;&lt;&quot;(&quot;&lt;&lt;real(c)&lt;&lt;&quot;,&quot;&lt;&lt;imag(c)&lt;&lt;&quot;)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当重载运算符的时候要声明其为全局函数。</li>
<li>构造函数可以通过initialization list来进行初始化。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Complex(double r = 0, double i = 0) : re(r), im(i)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>传递者无需知道接收者是以什么形式传递数据。传递者只需要传过去即可。但是如果以reference进行传递效率会高一点。</li>
<li>友元函数可以直接访问私有数据。</li>
</ol>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Houjie</tag>
        <tag>Bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>MouseAndPoison</title>
    <url>/2019/11/17/MouseAndPoison/</url>
    <content><![CDATA[<p>最近有和同学在讨论用小老鼠来找出有毒的水瓶的问题，稍微总结一下。</p>
<a id="more"></a>

<h2 id="经典问题-16选1"><a href="#经典问题-16选1" class="headerlink" title="经典问题. 16选1"></a>经典问题. 16选1</h2><p>16瓶水其中有一瓶有毒，多少个小老鼠可以确定是哪瓶呢？</p>
<h3 id="1-二进制编码水瓶"><a href="#1-二进制编码水瓶" class="headerlink" title="1. 二进制编码水瓶"></a>1. 二进制编码水瓶</h3><p>对16瓶水进行二进制编码，比如第五瓶是1001，那么就给第一只和第四只小老师喝（第n只代表从低位到高位的序号），这样最终死亡的小老鼠就会拼凑出一个数字就是对应的有毒的那一瓶水。比如说第一只和第三只小老鼠死了，那么就是0101，所以也就是第五瓶水有毒。</p>
<h3 id="2-减半查找"><a href="#2-减半查找" class="headerlink" title="2. 减半查找"></a>2. 减半查找</h3><p>如果不考虑时间，我们可以一次一次小鼠进行测试，每次找出奇数位的小鼠，可以通过死亡与否确定是奇数还是偶数，每次都可以将等待判断的量降低为原来的一半。所以总共需要log2(n)向上取整只小鼠。</p>
<h3 id="3-上面两种方式等价。"><a href="#3-上面两种方式等价。" class="headerlink" title="3. 上面两种方式等价。"></a>3. 上面两种方式等价。</h3><p>其实上面两种方法等价，最高位是1去掉所有的一半，次高位是1去掉一半，最后就剩两个，然后再来一只小鼠就确定了。</p>
<h3 id="变体问题"><a href="#变体问题" class="headerlink" title="变体问题"></a>变体问题</h3><ol>
<li>如果10-17瓶水只有一瓶水有毒，同样可以按照1的方式进行计算。</li>
<li>如果16瓶水，其中有一瓶是有毒的，要找14瓶没毒的，实际上就可以变相的理解为8瓶水中找7瓶，从而只需要三只小老鼠就可以了。</li>
<li>如果允许有两轮，或者变相说明有一个小时时间，然后小鼠喝毒药半个小时就去世，那就可以理解成为需要一轮然后处理一半的水瓶就可以了。 </li>
</ol>
<p>如果以后还有再继续补充吧～</p>
]]></content>
      <categories>
        <category>思维风暴</category>
      </categories>
      <tags>
        <tag>mouse</tag>
        <tag>BrainStorm</tag>
      </tags>
  </entry>
  <entry>
    <title>kickstart-2019-H-T1-HIndex</title>
    <url>/2019/11/17/kickstart-2019-H-T1-HIndex/</url>
    <content><![CDATA[<p>2019年kickstart最后一轮，下午1点到4点。<br>真心感慨，自己要学的东西还有很多啊，<br>本文是第一题H-index，计算科研人员影响因子的一道题目。</p>
<a id="more"></a>

<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edd/00000000001a274e" target="_blank" rel="noopener">Problem</a></h2><p>It is important for researchers to write many high quality academic papers. Jorge has recently discovered a way to measure how impactful a researcher’s papers are: the H-index.</p>
<p>The H-index score of a researcher is the largest integer h such that the researcher has h papers with at least h citations each.</p>
<p>Jorge has written N papers in his lifetime. The i-th paper has Ai citations. The number of citations that each paper has will never change after it is written. Please help Jorge determine his H-index score after each paper he wrote.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing N, the number of papers Jorge wrote.</p>
<p>The second line contains N integers. The i-th integer is Ai, the number of citations the i-th paper has.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is a space-separated list of integers. The i-th integer is the H-index score after Jorge wrote his i-th paper.</p>
<h2 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h2><p>Time limit: 50 seconds per test set.<br>Memory limit: 1GB.<br>1 ≤ T ≤ 100.<br>1 ≤ Ai ≤ 105.</p>
<h2 id="Test-set"><a href="#Test-set" class="headerlink" title="Test set"></a>Test set</h2><h3 id="Test-set-1-Visible"><a href="#Test-set-1-Visible" class="headerlink" title="Test set 1 (Visible)"></a>Test set 1 (Visible)</h3><p>1 ≤ N ≤ 1000.</p>
<h3 id="Test-set-2-Hidden"><a href="#Test-set-2-Hidden" class="headerlink" title="Test set 2 (Hidden)"></a>Test set 2 (Hidden)</h3><p>1 ≤ N ≤ 105.</p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Input</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5 1 2</span><br><span class="line">6</span><br><span class="line">1 3 3 2 2 15</span><br><span class="line"></span><br><span class="line">//Output</span><br><span class="line">Case #1: 1 1 2</span><br><span class="line">Case #2: 1 1 2 2 2 3</span><br></pre></td></tr></table></figure>

<p>In Sample Case #1, Jorge wrote N = 3 papers.<br>After the 1st paper, Jorge’s H-index score is 1, since he has 1 paper with at least 1 citation.<br>After the 2nd paper, Jorge’s H-index score is still 1.<br>After the 3rd paper, Jorge’s H-index score is 2, since he has 2 papers with at least 2 citations (the 1st and 3rd papers).</p>
<p>In Sample Case #2, Jorge wrote N = 6 papers.<br>After the 1st paper, Jorge’s H-index score is 1, since he has 1 paper with at least 1 citation.<br>After the 2nd paper, Jorge’s H-index score is still 1.<br>After the 3rd paper, Jorge’s H-index score is 2, since he has 2 papers with at least 2 citations (the 2nd and 3rd papers).<br>After the 4th paper, Jorge’s H-index score is still 2.<br>After the 5th paper, Jorge’s H-index score is still 2.<br>After the 6th paper, Jorge’s H-index score is 3, since he has 3 papers with at least 3 citations (the 2nd, 3rd and 6th papers).</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="原始版思路"><a href="#原始版思路" class="headerlink" title="原始版思路"></a>原始版思路</h3><p>因为每次写完一篇文章都要给出一个结果，所以肯定每次有新的文章都要重新计算一次，而H-index的计算方式是说至少有h篇文章，然后每篇文章都至少有h的引用数，所以我就联想到上一轮kickstart的第一题，借鉴到相同思路，我们可以通过建立一个数组，保存对应的引用数目，</p>
<p>比如有N篇文章，那么引用最高为N，方便起见，我们建立一个N+1的数组（全部初始化为0）。0索引位置不再使用。然后每个位置代表有这个引用的文章有多少篇，然后在我寻找h-index的时候，只要当前位置寻找arr[i] &gt;=i的第一个数字即可。</p>
<p>以[5,1,2]为例进行讲解。</p>
<ol>
<li>首先建立一个4(也就是3+1)个元素的数组，[0,0,0,0]</li>
<li>第一个数字为5，那么1到3号索引位置元素都+1，变成[0,1,1,1];<br>这个时候从1号索引位置往前找第一个符合arr[i]&gt;=i的元素，也就是1；</li>
<li>第二个数字为1，那么1号索引位置元素+1，变成[0,2,1,1];<br>这个时候从2号索引位置往前找第一个符合arr[i]&gt;=i的元素，还是1；</li>
<li>第三个数字是2，那么1号到2号索引位置元素+1，变成[0,3,2,1];<br>这个时候从3号索引位置往前找第一个符合arr[i]&gt;=i的元素，此时变成了2；</li>
<li>所以最终的结果也就是[1,1,2]</li>
</ol>
<p>算法复杂度是O(n^2)，可以通过小case。</p>
<h3 id="升级版思路"><a href="#升级版思路" class="headerlink" title="升级版思路"></a>升级版思路</h3><p>这个思路就会比较好，构造了一个multiset来存储元素，这里的一个好处就是他会对插入的元素进行自动排序，默认是从小到大的顺序，底层是用红黑树实现的，插入删除查找的复杂度都是lg(n)级别的。然后我们每次将读入的数字插入到multiset中，然后判断头元素（实际就是所有元素中最小的元素）是否小于容器内元素个数。如果小于，那么删除头元素。最后我们想要的h-index其实就是每一轮之后的容器内元素个数。</p>
<p>还是以[5,1,2]为例进行讲解。</p>
<ol>
<li>开始插入5，此时s={5},然后5大于当前元素个数1，所以s保持不变s={5},所以第一轮结果为1；</li>
<li>然后插入1，此时s={1,5}, 此时1是小于当前元素个数2，所以要删除第一个元素，s变成{5},所以第二轮结果为1；</li>
<li>然后插入2，此时s={2,5},然后2要等于当前元素个数，所以s保持不变，s= {2,5},所以第三轮返回结果为2.</li>
<li>所以最终结果也就是[1,1,2]</li>
</ol>
<p>算法的复杂度为O(nlgn)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    string res;</span><br><span class="line">    for (int t = 1; t &lt;= T; ++t) &#123;</span><br><span class="line">        int M;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;M);</span><br><span class="line">        vector&lt;int&gt; arr(M+1,0);</span><br><span class="line">  </span><br><span class="line">        int x;</span><br><span class="line">        arr[0] = 0;</span><br><span class="line">        res =&quot;&quot;;</span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">             scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">             for(int j = 1; j &lt;= x &amp;&amp; j&lt;=M ; j++)&#123;</span><br><span class="line">                  arr[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">             int k = i;</span><br><span class="line">             while(k&gt;0)&#123;</span><br><span class="line">                 if(arr[k] &gt;= k)&#123;</span><br><span class="line">                     res  += &quot; &quot;+to_string(k);</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 k--;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Case #%d: %s \n&quot;, t, res.c_str());</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="升级版"><a href="#升级版" class="headerlink" title="升级版"></a>升级版</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    string res;</span><br><span class="line">    for (int t = 1; t &lt;= T; ++t) &#123;</span><br><span class="line">        int M;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;M);</span><br><span class="line">        int x;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        multiset&lt;int&gt; aset;</span><br><span class="line">        for(int i = 0;i&lt;M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">            aset.insert(x);</span><br><span class="line">            int b = *aset.begin();</span><br><span class="line">            if(b &lt; aset.size())&#123;</span><br><span class="line">                aset.erase(aset.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            res += &quot; &quot;+to_string(aset.size());</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %s \n&quot;, t, res.c_str());</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ol>
<li>想了一下这个题目和之前G轮的第一题<a href="http://kingwen.cn/2019/10/22/kickstart-2019-G-T1-BookReading/" target="_blank" rel="noopener">BookReading</a>有什么不同，结论是对于bookreading来说，首先是把所有的结果都统计一遍之后，然后所有的测试用例都只需要访问之前的结果就可以了（用一个数组来表示每页书的情况，然后读取对应因子的倍数得到相应的结果，其实就是上面链接中的动态规划第一版）从而可以节省大量的时间。但是本题目并不是这样子，本题目对于每次的有一个新的数值输入，都会进行新一轮的结果运算，所以如果我们再依次的去保存每一个位置的结果，尤其是通过对数组中元素依次加1的方式实现，复杂度必然会很高，现在想想的话，其实就比每次都完全的遍历一遍（每一次都从index开始找，看看paper数组中元素个数有没有大于index，找到第一个复合条件的即可,总的时间复杂度为O(n^3)）好那么一点。然后考虑到我们其实想要的结果是数量，所以就可以非常巧妙的利用一些数据结构，上面的测试用例用的是multiset，其实用最小堆，用unordered_map都可以实现，重点是保证内部元素有序，从而可以利用容器中的数量来变相的表示我们想要的结果。</li>
<li>以后要注意很多有用的数据结构的使用方法，比如本次使用的就是multiset这个数据结构，有机会再去看看其内部实现，首先要知道才能在真正要使用的时候想到它。</li>
<li>题目做的还是太少了，见识太少了，以后还是要坚持刷题啊，见多识广才能见怪不怪。</li>
<li>看人家的好的解题思路真的是赏心悦目，倍感舒适啊。</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
        <tag>multiset</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-861-ScoreAfterFlippingMatrix</title>
    <url>/2019/11/13/leetcode-861-ScoreAfterFlippingMatrix/</url>
    <content><![CDATA[<p>本题目和之前的kickstart的G轮的第二题有一点类似。<br>为了保证最后的数值最大，在保证最高位是1的基础上，保证之后的每一列尽可能有更多的1，非常巧妙也非常实用。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>We have a two dimensional matrix A where each value is 0 or 1.</p>
<p>A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.</p>
<p>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.</p>
<p>Return the highest possible score.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class="line">Output: 39</span><br></pre></td></tr></table></figure>
<p>Explanation:<br>Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].<br>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</p>
<p>Note:<br>1 &lt;= A.length &lt;= 20<br>1 &lt;= A[0].length &lt;= 20<br>A[i][j] is 0 or 1.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法</p>
<h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><p>我们会发现，在二进制串中，即使从次高位到最低位全部都是1也比最高位是1要小，所以为了保证最后形成的二进制串最大，必然每一行的第一位一定是1，然后对于从第二列开始之后的每一列，要尽可能有更多的1。</p>
<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><ol>
<li><p>为了保证最后形成的二进制的数字最大，我们要保证最高位是1， </p>
</li>
<li><p>非常巧妙的用了移位来进行二进制的乘法运算，比如说</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&lt;&lt;2</span><br></pre></td></tr></table></figure>
<p>实际上就变成了0b100(二进制的100)，也就是从1变成了4，相当于乘上了2的2次方。</p>
</li>
<li><p>在统计每一列0和1数目的时候也没有真的将数字进行一一遍历进行计算，而是通过是否和第一位数字相同来进行判断，原因是进行行变化之后，其实每个数字和本行的第一个数字的相同与否并没有发生变化，而我们为了让最终数值最大所以保证了每行的第一个数字都必须是1，从而通过与1的相同与否我们判定出每一列的0和1的个数，进而让多的数是1可以保证本列最后的数值也会是最大的。 </p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int matrixScore(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;</span><br><span class="line">        int m = A.size();</span><br><span class="line">        int n = A[0].size();</span><br><span class="line">        int res = m*(1&lt;&lt;(n-1));</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; m;j++)&#123;</span><br><span class="line">                 cnt += (A[j][0]==A[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res += max(cnt,m-cnt)*(1&lt;&lt;(n-1-i));</span><br><span class="line">            cnt = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-765-CouplesHoldingHands</title>
    <url>/2019/11/13/leetcode-765-CouplesHoldingHands/</url>
    <content><![CDATA[<p>情侣换座位手牵手的题目。<br>思想有点像打气球那个题目：处理好当下的问题，慢慢往后遍历，以后的问题也会变得很顺利，回头还会发现这其实就是最好的方法。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.</p>
<p>The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).</p>
<p>The couples’ initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: row = [0, 2, 1, 3]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Explanation: We only need to swap the second (row[1]) and third (row[2]) person.</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: row = [3, 2, 0, 1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>Explanation: All couples are already seated side by side.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法。</p>
<h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><p>如果我们仔细看就会发现，其实我们在判断的时候只要确定了两个数中的一个，那么另外一个数是多少其实就是已经确定好了的，然后我们将这个数本身所在的位置替换掉就可以了。比如说下面的例子，第一个元素是5，那么第二个元素必然是6，我们只要找到6，然后将6本身所在的位置的数字替换成第二个元素本身的元素4就可以了。<br>以题目中的某个用例来进行说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始数组：[5,6,4,0,2,1,9,3,8,7,10,11]</span><br><span class="line">i= 0: 5 4   6   0   2   1   9   3   8   7   10  11  </span><br><span class="line">i= 2: 5 4   6   7   2   1   9   3   8   0   10  11  </span><br><span class="line">i= 4: 5 4   6   7   2   3   9   1   8   0   10  11  </span><br><span class="line">i= 6: 5 4   6   7   2   3   9   8   1   0   10  11  </span><br><span class="line">i= 8: 5 4   6   7   2   3   9   8   1   0   10  11  </span><br><span class="line">i=10: 5 4   6   7   2   3   9   8   1   0   10  11</span><br></pre></td></tr></table></figure>
<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><ol>
<li>大道至简，大智若愚。从头开始，每次都做好当前元素的判断，那么后面的元素都会依次的处理好。</li>
<li>对于当前位置要进行奇偶判断，因为不确定配偶的左右情况，所以要自行判断。</li>
<li>要会使用stl中的各种比较巧妙的方法，比如本题目中用到的find和distance。</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSwapsCouples(vector&lt;int&gt;&amp; row) &#123;</span><br><span class="line">        if(row.size() &lt;=  2) return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0; i &lt; row.size(); i += 2)&#123;</span><br><span class="line">            if(row[i]%2 == 0)&#123;</span><br><span class="line">                if(row[i+1] == row[i]+1)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    auto a = find(row.begin(),row.end(),row[i]+1);</span><br><span class="line">                    int index = distance(row.begin(),a);</span><br><span class="line">                    row[index] = row[i+1];</span><br><span class="line">                    row[i+1] = row[i]+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(row[i+1] == row[i]-1)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    auto a = find(row.begin(),row.end(),row[i]-1);</span><br><span class="line">                    int index = distance(row.begin(),a);</span><br><span class="line">                    row[index] = row[i+1];</span><br><span class="line">                    row[i+1] = row[i]-1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-452-MinimumNumberOfArrowsToBurstBalloons</title>
    <url>/2019/11/12/leetcode-452-MinimumNumberOfArrowsToBurstBalloons/</url>
    <content><![CDATA[<p>射箭，问射穿所有气球最少射几箭。<br>抽象出来之后，其实也是区间类型的题目。只是这次的排序方式相比与之前发生了点变化。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.</p>
<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>Explanation:<br>One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法</p>
<h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><p>射气球，总的来看，其实第一支箭一定会射在第一个气球的范围之内，比如说[1,6]，而第二支箭一定是要射在第一个[1,6]覆盖不到的第一个气球的区间之内的。所以当我们按照他们的区间后端进行排序之后，就会很容易找到第一个不重合的气球，每次遇到一个与之前不重合的气球，就射一箭，从而可以实现最优解。</p>
<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><ol>
<li>之前的排序其实都是按照有序对的第一个元素进行排序，然后本题目是按照第二个元素排序，就可以使得题目变得非常的简单有效。</li>
<li>复习之前的lambda表达式的用法。<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        if(points.empty()) return 0;</span><br><span class="line">        sort(points.begin(), points.end(),[](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">            return (a[1] &lt; b[1]);</span><br><span class="line">        &#125;);</span><br><span class="line">        int res = 1;</span><br><span class="line">        int end = points[0][1];</span><br><span class="line">        for(int i = 1; i &lt;  points.size(); i++)&#123;</span><br><span class="line">            if(points[i][0] &gt; end)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                end = points[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-435-Non-overlapping-Intervals</title>
    <url>/2019/11/12/leetcode-435-Non-overlapping-Intervals/</url>
    <content><![CDATA[<p>非重复区间的一个题目，思路比较清晰,感觉和406题有点异曲同工之妙。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,2],[1,2],[1,2]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.</p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,2],[2,3]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>Explanation: You don’t need to remove any of the intervals since they’re already non-overlapping.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法</p>
<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><p>要记得按照从小到大的顺序进行排序,然后看后一个区间的头是否在前一个区间内，如果没有，那么不用删，如果在，那么肯定要删一个。要么删除前面那个区间，要么删除后面那个区间。比如说[1,3]和[2,4],那么因为2在[1,3]内，所以这个时候肯定要删除[2,4],因为[2,4]在[1,3]更加靠后的位置。但是如果前面是[1,10],然后后面有[2,3]和[4,5]这种情况最好是删除第一个[1,10]，因为[1,10]包含的区间更加靠后。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if(intervals.empty()) return 0;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">       </span><br><span class="line">        int res = 0;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        for(auto p : intervals)&#123;</span><br><span class="line">            if( temp.empty() || p[0] &gt;= temp[1])&#123;</span><br><span class="line">                temp = p; </span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res++;</span><br><span class="line">                temp = p[1] &lt; temp[1]? p:temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-406-QueueReconstructionbyHeight</title>
    <url>/2019/11/11/leetcode-406-QueueReconstructionbyHeight/</url>
    <content><![CDATA[<p>这道题目不是很难，但是思路也很好玩.<br>通过这道题，我们还可以顺便掌握c++11中刚刚引入的lambda表达式，非常棒！</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.</p>
<p>Note:<br>The number of people is less than 1,100.</p>
<h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><p>Input:<br>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</p>
<p>Output:<br>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法。</p>
<h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><p>最开始先排序，按照如下规则进行排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果第一个元素不等，那么大的在前。</span><br><span class="line">如果第一个元素相等，那么第二个元素小的在前。</span><br></pre></td></tr></table></figure>
<p>所以变化如下。</p>
<ol>
<li>初始状态：[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</li>
<li>排序之后：[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</li>
</ol>
<p>接下来从第二个元素开始插入，按照如下规则进行排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将两个数构成的数组插入到数组中第二个数的位置。</span><br><span class="line">如将[6,1]插入到1号位置，将[5,2]插入到2号位置，注意这个地方要从前往后一次的进行插入。</span><br></pre></td></tr></table></figure>
<p>插入之后的变化依次如下,这里可以从第二个元素开始进行判断</p>
<ol start="3">
<li>插入[7,1]元素：[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</li>
<li>插入[6,1]元素：[[7,0], [6,1], [7,1], [5,0], [5,2], [4,4]]</li>
<li>插入[5,0]元素：[[5,0], [7,0], [6,1], [7,1], [5,2], [4,4]]</li>
<li>插入[5,2]元素：[[5,0], [7,0], [5,2], [6,1], [7,1], [4,4]]</li>
<li>插入[4,4]元素：[[5,0], [7,0], [5,2], [6,1], [4,4]，[7,1]]<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2></li>
<li>要学会使用lambda表达式，也就是如下的代码。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort(people.begin(), people.end(),[](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">                 return ((a[0] &gt; b[0]) ||(a[0] == b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
如果不使用lambda表达式那么就需要写成如下模样。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt; b)&#123;</span><br><span class="line">    return ((a[0] &gt; b[0]) ||(a[0] == b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">&#125;</span><br><span class="line"># 然后调用的时候如下</span><br><span class="line">sort(people.begin(),people.end(),cmp);</span><br></pre></td></tr></table></figure></li>
<li>发现排序之后整个vector可以插入的位置刚刚好是vector中第二个元素的位置。</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(),</span><br><span class="line">             [](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">                 return ((a[0] &gt; b[0]) ||(a[0] == b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">             &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; people.size(); i++ )&#123;</span><br><span class="line">            auto p = people[i]; </span><br><span class="line">            if(p[1] != i)&#123;</span><br><span class="line">                people.erase(people.begin()+i);</span><br><span class="line">                people.insert(people.begin() + p[1],p);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return people;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="升级代码"><a href="#升级代码" class="headerlink" title="升级代码"></a>升级代码</h3><p>上面的那种方法速度比较满，原因在于是在原数组上进行插入同时还要进行删除操作，而如果我们直接新建一个vector来保存结果，那么就只需要插入就可以了，然后速度会有很大的提升。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">        return (a[0] &gt; b[0] ||(a[0]==b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(),cmp);</span><br><span class="line">        </span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; ans;</span><br><span class="line">        for(int i = 0; i &lt; people.size(); i++ )&#123;</span><br><span class="line">            auto p = people[i]; </span><br><span class="line">            ans.insert(ans.begin()+p[1],p);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="再次升级代码"><a href="#再次升级代码" class="headerlink" title="再次升级代码"></a>再次升级代码</h3><p>为了代码好看，可以再次升级代码，使用增强的for循环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">        return (a[0] &gt; b[0] ||(a[0]==b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(),cmp);</span><br><span class="line">        </span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; ans;</span><br><span class="line">        for(auto p:people)&#123;</span><br><span class="line">            ans.insert(ans.begin()+p[1],p);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束。</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>how-to-save-pdf-images</title>
    <url>/2019/11/11/how-to-save-pdf-images/</url>
    <content><![CDATA[<p>本来想查一下如何写程序来提取pdf中的图片来着，然后发现可以用ps来实现，然后就先记录一下。</p>
<a id="more"></a>
<h2 id="通过PhotoShop进行保存"><a href="#通过PhotoShop进行保存" class="headerlink" title="通过PhotoShop进行保存"></a>通过PhotoShop进行保存</h2><ol>
<li>打开ps</li>
<li>选择ps的菜单选项 <strong>文件</strong>-&gt;<strong>打开</strong>（或者直接快捷键ctrl+o）打开想打开的pdf文件</li>
<li>在打开pdf选项页面的时候，注意选择<strong>图像</strong>，然后选择要打开的图片（可以通过按住shift进行多选），然后点击确定即可。如下图所示。<br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191111135210.png" alt=""></li>
<li>在图片页面进行保存操作，(也可以使用快捷键ctrl+s)，注意保存格式选择jpeg，重命名，选择保存地址，然后确定即可。<h2 id="截图保存"><a href="#截图保存" class="headerlink" title="截图保存"></a>截图保存</h2></li>
<li>平时的微信和QQ都是有默认的截图功能的，可以直接截图保存，以微信来举例，通过查看设置中的快捷键选项可以查看如何进行快速截图。<br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191111135655.png" alt=""><br>啊，这篇文章好水啊，哗哗哗～</li>
</ol>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>PDF</tag>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-330-PatchingArray</title>
    <url>/2019/11/09/leetcode-330-PatchingArray/</url>
    <content><![CDATA[<p>今天周六，好好做个题，明天就可以心安理得的出去玩啦！<br>然后就碰见了这个解题方法特别让人觉得奇妙的题目，算法这个东西实在是太神奇了。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p>Input: nums = [1,3], n = 6<br>Output: 1<br>Explanation:<br>Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.<br>Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].<br>Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].<br>So we only need 1 patch.</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><p>Input: nums = [1,5,10], n = 20<br>Output: 2<br>Explanation: The two patches can be [2, 4].</p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><p>Input: nums = [1,2,2], n = 5<br>Output: 0</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心</p>
<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><p>构造了一个miss缺失值，表示不能覆盖的最小值。最开始表示为1，表示此时不能表示范围为[0,1),然后去依次找数组中的值（要注意数组中的数据是排好序的，所以才可以这么用！），如果缺失值小于数组中的值，那么肯定要添加数，如果缺失值要是大于数组中的值，那么那么最小缺失值可以得到更新。最后如果最小缺失值大于n，那么就说明已经完成要求了。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>以sample2也就是nums = [1,5,10], n=20举例来讲</p>
<ol>
<li>初始化的时候，数组索引index = 0，最小缺失值miss为1，res为0；</li>
<li>此时miss&lt;=20成立，没有覆盖到[1,n]的范围，所以进入循环判断，此时nums[0] = 1&lt;=miss 而且index没有超出数组范围，所以miss会更新，加上当前数组索引位置，也就是说miss = 2，表示此时可以表示范围为[0,2)啦。</li>
<li>然后miss此时仍然不能表示n，继续往后走，此时nums[1] = 5, 是大于miss的，也就是说此时我们最多表示到1，但是你突然来了个5，那我[2,4]的数据怎么办，就只能自己往里添加啦，所以此时为了尽可能表示的数字变得更大，所以此时加上miss本身这个数，从而就可以表示  [0，miss+miss)的数字了，所以此时添加一个2，res在原来的基础上+1变为1，miss也就变成了4；</li>
<li>[0,4)依然不能表示[0,n],所以还是要继续判断，此时miss仍然小于nums[1],所以我仍然不能用nums中的数字来表示4这个数，所以继续向数组中添加4,然后此时可表示范围变成了[0,8),res+1变成2，添加了4这个数字。</li>
<li>[0,8)仍然表示不了[0,n],所以仍然没有结束，此时的miss大于nums[1],也就是miss&gt;5成立，所以此时nums到索引1然后再加上添加的元素可以表示数的范围就变成了[0,13).</li>
<li>[0.13)仍然表示不了[0,20]，所以继续，此时miss大于nums[2],所以如果nums中从0到索引2的所有数字加上之前添加的数字可以表示的数字范围就变成了[0,23).</li>
<li>[0.23)是可以表示[0,20]的，所以结束，最终结果需要添加两个数，一个2，一个4即可。<br>太神奇了。<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:    </span><br><span class="line">    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;</span><br><span class="line">        int res  = 0;</span><br><span class="line">        long miss = 1, i = 0;</span><br><span class="line">        while(miss &lt;= n)&#123;</span><br><span class="line">            if(i&lt;nums.size() &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">                miss += nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                miss += miss;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>create-my-leetcode-artical-template</title>
    <url>/2019/11/09/create-my-leetcode-artical-template/</url>
    <content><![CDATA[<p>在我每次写leetcode解题文章的时候，经常需要搞排版信息，一次两次还好，但是次数多了就会比较烦。那么我们能不能自定义一个属于自己的leetcode文章模版呢？当然可以！于是就有了本篇文章。</p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="从创建文章说起"><a href="#从创建文章说起" class="headerlink" title="从创建文章说起"></a>从创建文章说起</h3><p>我们在使用如下命令创建文章的时候，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new title</span><br></pre></td></tr></table></figure>
<p>实际上我们使用的是如下的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post title</span><br></pre></td></tr></table></figure>
<p>上面的命令是这个命令的缩写形式而已，因为一般搭建都不太会创建草稿（draft）或者页面（page），大家都是创建文章，它太常用了，所以就被设置成了默认选项。</p>
<h3 id="真实的创建命令"><a href="#真实的创建命令" class="headerlink" title="真实的创建命令"></a>真实的创建命令</h3><p>那么真实使用的创建命令是什么呢？其实是下面这个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>根据<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">官方文档</a>显示，hexo默认的layout有三种，分别是post，draft，page，他们都有自己的默认样式，他们文件本身都在scaffolds目录下面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog ls -l scaffolds </span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 liqingwen  staff  33 10 18 21:52 draft.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  44 10 18 21:52 page.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  76 10 21 16:48 post.md</span><br></pre></td></tr></table></figure>
<p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，所以我们要想创建自己的模版，只要在这里面创建一个leetcode模板即可，然后以后就可以通过如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new leetcode leetcode-number-nanme</span><br></pre></td></tr></table></figure>
<p>来创建符合对应布局的文章啦。</p>
<h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><ol>
<li><p>先查看模版中的文件有哪些</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog ls -l scaffolds </span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 liqingwen  staff  33 10 18 21:52 draft.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  44 10 18 21:52 page.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  76 10 21 16:48 post.md</span><br></pre></td></tr></table></figure></li>
<li><p>查看我们常用的post模板中的内容，然后我们照着这个改写就可以啦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 查看模版中内容</span><br><span class="line">➜  blog cat scaffolds/post.md </span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- tag1</span><br><span class="line">categories:</span><br><span class="line">- cat1</span><br></pre></td></tr></table></figure></li>
<li><p>复制一份post，重命名为leetcode，然后将我们想要的东西都加进去，然后保存即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog cd scaffolds </span><br><span class="line">➜  scaffolds cp post.md leetcode.md</span><br><span class="line">➜  scaffolds ls</span><br><span class="line">draft.md    leetcode.md page.md     post.md</span><br><span class="line"></span><br><span class="line"># 注意这里我使用的是sublime编辑器，然后在文档中添加的内容已经通过后面的cat输出了，大家可以直接赋值。</span><br><span class="line">➜  scaffolds subl leetcode.md </span><br><span class="line"></span><br><span class="line">➜  scaffolds ls</span><br><span class="line">draft.md    leetcode.md page.md     post.md</span><br><span class="line">➜  scaffolds cat leetcode.md </span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- leetcode</span><br><span class="line">- hard,medium,easy</span><br><span class="line">- Greedy, DP, String </span><br><span class="line">categories:</span><br><span class="line">- 算法训练</span><br><span class="line">---</span><br><span class="line">摘要内容</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line">### sample1</span><br><span class="line">## 解题思路</span><br><span class="line">## 巧妙之处</span><br><span class="line">## 解题代码</span><br></pre></td></tr></table></figure></li>
<li><p>尝试使用leetcode模版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  scaffolds cd ..</span><br><span class="line">➜  blog hexo new leetcode &quot;leetcode-406-QueueReconstructionbyHeight&quot;   </span><br><span class="line">INFO  Created: ~/workplace/blog/source/_posts/leetcode-406-QueueReconstructionbyHeight.md</span><br><span class="line">➜  blog subl  source/_posts/leetcode-406-QueueReconstructionbyHeight.md</span><br></pre></td></tr></table></figure>
<p>大功告成，于是就可以可以很开心的写文章啦。</p>
</li>
<li><p>2019-11-12更新</p>
<ol>
<li>为了更加的解释算法过程，特地添加了详细解释部分。</li>
<li>为了更好的体现算法的演进，特地添加了算法升级部分。<br>升级之后结果如下。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- leetcode</span><br><span class="line">- hard</span><br><span class="line">- medium</span><br><span class="line">- easy</span><br><span class="line">- Greedy;</span><br><span class="line">- DP</span><br><span class="line">- String </span><br><span class="line">categories:</span><br><span class="line">- 算法训练</span><br><span class="line">---</span><br><span class="line">摘要内容</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line">### Sample</span><br><span class="line">## 解题思路</span><br><span class="line">## 详细解释</span><br><span class="line">## 巧妙之处</span><br><span class="line">## 解题代码</span><br><span class="line">### 原始代码</span><br><span class="line">### 升级代码</span><br><span class="line">以上，本题结束！</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-67-AddBinary</title>
    <url>/2019/11/08/leetcode-67-AddBinary/</url>
    <content><![CDATA[<p>今天晚上总结了一下c++中string的常用的属性和方法，一时手痒，所以就找了个题目练练手，记录一下。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both non-empty and contains only characters 1 or 0.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p>Input: a = “11”, b = “1”<br>Output: “100”</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p>Input: a = “1010”, b = “1011”<br>Output: “10101”</p>
<h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>第一反应其实和两个数相加的那个题目类似，只是这里需要反向遍历即可。<br>这里的一个比较好的技巧就是学会补零。比如说1和1001进行相加，很明显，结果是1010。计算结果可以将1补充为0001，这样就可以数据对齐，然后就可以方便计算而不容易出现空指针了。</p>
<h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addBinary(string a, string b) &#123;</span><br><span class="line">        int alen = a.size();</span><br><span class="line">        int blen = b.size();</span><br><span class="line">        int mlen = max(alen, blen);</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        for(int i = 0; i &lt; mlen; i++)&#123;</span><br><span class="line">            int tempa = alen&gt;i?a[alen-i-1]-&apos;0&apos;:0;</span><br><span class="line">            int tempb = blen&gt;i?b[blen-i-1]-&apos;0&apos;:0;</span><br><span class="line">            int tres = tempa+tempb+carry;</span><br><span class="line">            if(tres == 0)&#123;</span><br><span class="line">                res.insert(0,1,&apos;0&apos;);</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else if(tres == 1)&#123;</span><br><span class="line">                res.insert(0,1,&apos;1&apos;);</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else if(tres == 2)&#123;</span><br><span class="line">                res.insert(0,1,&apos;0&apos;);</span><br><span class="line">                carry = 1;</span><br><span class="line">            &#125;else if(tres == 3)&#123;</span><br><span class="line">                res.insert(0,1,&apos;1&apos;);</span><br><span class="line">                carry = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry == 1)&#123;</span><br><span class="line">            res.insert(0,1,&apos;1&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-72-EditDistance</title>
    <url>/2019/10/24/leetcode-72-EditDistance/</url>
    <content><![CDATA[<p>编辑距离是一个非常经典的动态规划的题目，之前搞懂过，但是总是会忘，所以又搞了一遍，顺便做个笔记。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">题目描述</a></h2><p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following 3 operations permitted on a word:</p>
<ol>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>
<h2 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a>题目解读</h2><p>就是求两个字符串的最小编辑距离，也就是计算word1最少可以经过多少次变化(插入，删除，替换)可以变成word2。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="动态规划的具体思路"><a href="#动态规划的具体思路" class="headerlink" title="动态规划的具体思路"></a>动态规划的具体思路</h3><ol>
<li>dp[i][j]表示word1的[0,i)变成word2的[0,j)位需要多少次变化。</li>
<li>对于第0行，dp[0][i] = i for 0&lt;= i &lt;= len2; (len2是word2的字符串长度)</li>
<li>对于第0列，dp[i][0] = i for 0=&lt; i &lt;= len1; (len1是word1的字符串长度)</li>
<li>如果最后一位相同，则arr[i][j] = arr[i-1][j-1]</li>
<li>若是判断的最后一位不同，则arr[i][j] = min(arr[i-1][j]+1, arr[i][j-1]+1 ,arr[i-1][j-1]+1)</li>
<li>最后返回arr[len1][len2]</li>
</ol>
<h3 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h3><p>这里解释一下第4步，也是看了好久才明白的。</p>
<p>下面以word1=”abb”,word2=”ac”为例。</p>
<ol>
<li>首先明确一下问题：我们现在要求的是abb需要多少步会变到ac，而假设我们已经知道了ab变ac，abb变a，ab变a三种情况，我们只需要现在的情况变到之前已知的情况就解决了。</li>
<li>假设abb-&gt;ac是从ab-&gt;ac变过来的，那么我们只要将abb去掉最后一个b就可以，剩下的就是要考虑ab如何变成ac了。也就是arr[i][j]=arr[i-1][j]+1;</li>
<li>假设abb-&gt;ac是从abb-&gt;a变过来的，那么我们只要在abb后面插入一个c就可以实现最后一位的匹配，剩下的就是考虑abb如何变成a了。也就是arr[i][j] = arr[i][j-1]+1;</li>
<li>假设abb-&gt;ac是从ab-&gt;a变过来的，那么我们只要将abb的最后一位变成c，剩下的就是考虑如何将ab变成a了。也就是arr[i][j]=arr[i-1][j-1]+1;</li>
<li>最后我们选一个从三种方式中修改次数最小的一个就可以了</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        int len1 = word1.length();</span><br><span class="line">        int len2 = word2.length();</span><br><span class="line">        </span><br><span class="line">        int arr[len1+1][len2+1];</span><br><span class="line">        memset(arr,0,sizeof arr);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;= len1; i++)&#123;</span><br><span class="line">            arr[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;= len2; i++)&#123;</span><br><span class="line">            arr[0][i] = i;</span><br><span class="line">        &#125;      </span><br><span class="line">         for(int i = 1; i &lt;= len1; i++)&#123;</span><br><span class="line">             for(int j = 1;j &lt;= len2; j++)&#123;</span><br><span class="line">                 if(word1[i-1]==word2[j-1])&#123;</span><br><span class="line">                     arr[i][j] = arr[i-1][j-1];</span><br><span class="line">                 &#125;else&#123;</span><br><span class="line">                     arr[i][j] = min(min(arr[i-1][j],arr[i][j-1]),arr[i-1][j-1])+1;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        // for(int i = 0; i &lt;= len1; i++)&#123;</span><br><span class="line">        //      for(int j = 0;j &lt;= len2; j++)&#123;</span><br><span class="line">        //         cout&lt;&lt;arr[i][j]&lt;&lt;&apos;\t&apos;;         </span><br><span class="line">        //      &#125;</span><br><span class="line">        //     cout&lt;&lt;endl;</span><br><span class="line">        // &#125;</span><br><span class="line">        </span><br><span class="line">        return arr[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>build-image-hosting-service-with-github-and-PicGo</title>
    <url>/2019/10/23/build-image-hosting-service-with-github-and-PicGo/</url>
    <content><![CDATA[<p>图床，就是用来存放图片的地方。</p>
<p>目前各个网站为了保证自己的图片不会被其他人盗用，几乎都设置了访问条件验证（比如通过网站登录所保存的cookie等），这样的话其他人可能就访问不到你的图片了，而我写博客就是想给别人看的呀，所以搭建一个自己的图床就迫在眉睫。</p>
<a id="more"></a>

<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol>
<li>github账号</li>
<li>良好的网络条件</li>
<li>耐心</li>
</ol>
<h2 id="具体做法参考"><a href="#具体做法参考" class="headerlink" title="具体做法参考"></a>具体做法参考</h2><ol>
<li><a href="https://juejin.im/entry/5c4ec5aaf265da614420689f" target="_blank" rel="noopener">掘金-PicGo+GitHub图床，让Markdown飞</a></li>
</ol>
<p>按照这个流程就可以完美搭建起来了，我就是照着这个做的。</p>
<ol start="2">
<li><a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo github下载地址</a></li>
</ol>
<p>这个是PicGo的下载地址，选择最新版本的进行下载即可。mac下载dmg格式，win下载exe格式即可。</p>
<ol start="3">
<li><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E9%A2%84%E8%A7%88" target="_blank" rel="noopener">PicGo 官方文档</a></li>
</ol>
<p>之所以把这个放上，是因为这个PicGo其实有很多扩展或者其他的功能，包括设置各种快捷键，各种图床的支持（包括七牛，阿里，github，腾讯云，又拍云等等。话说微博图床现在放盗链了，不建议使用），各种代理等的支持，大家可以进行私人定制，将这个软件做成自己喜欢的样子。</p>
<h2 id="本文感受"><a href="#本文感受" class="headerlink" title="本文感受"></a>本文感受</h2><ol>
<li>github是个好地方，开源的力量极其伟大。</li>
</ol>
<p>本来享用iPic来进行图片上传来着，但是它默认只给你微博图床，而现在不能用了。然后如果要开启其他图床支持，是要花钱的，难过的是我都要准备花钱了，网络问题，付费一直不成功，所以就找到了PicGo，完美。</p>
<ol start="2">
<li>有机会还是要花钱买服务</li>
</ol>
<p>github尽管免费，但是说实话，访问是有延迟的，七牛云我也注册了，但是实名认证需要时间，所以我就先直接用github来搭建图床了。等到博客访问量大了的时候到时候再付费买七牛云存储吧，嘿嘿。</p>
<ol start="3">
<li>好的教程感觉一份就够了</li>
</ol>
<p>所以对于自己感觉比较好的教程我就直接放链接了，如果有补充的话我再专门写文章来介绍一下。</p>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>FigureBed</tag>
        <tag>Github</tag>
        <tag>PicGo</tag>
      </tags>
  </entry>
  <entry>
    <title>kickstart-2019-G-T2-TheEquation</title>
    <url>/2019/10/22/kickstart-2019-G-T2-TheEquation/</url>
    <content><![CDATA[<p>还是上周和同学一起尝试的kickstart第G轮比赛，这个是第二题的思路和解法。<br>在经历各种报错，各种思路修正之后终于搞定了！快写下来！</p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e02/000000000018fe36" target="_blank" rel="noopener">题目描述</a></h1><p><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/kickstart-2019-g-t2-description.jpg" alt=""><br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/kickstart-2019-g-t2-sample.jpg" alt=""></p>
<h1 id="题目理解"><a href="#题目理解" class="headerlink" title="题目理解"></a>题目理解</h1><p>就是找一个最大的K，使得K和每个元素进行亦或运算的和小于某个值。</p>
<h1 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h1><h2 id="Test-set1-暴力求解"><a href="#Test-set1-暴力求解" class="headerlink" title="Test set1 暴力求解"></a>Test set1 暴力求解</h2><p>下面的代码仅仅适应于小测试集。而之所以设置从127开始找，是因为看到了他给的测试集的范围。<br>对于Test set1中的每个元素而言，0&lt;=Ai&lt;=100,所以可以用6位表示。M也是可以用6位来表示，如果K的最高位不是第6位，而是第7位甚至更高，那么取亦或之后必然会大于128也就大于M，所以对于这个测试集来说，只要从127往下找到第一个符合条件的数字即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">// typedef long long ll;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">void solve(int case_num)&#123;</span><br><span class="line">    int N,M;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    int res = 0;</span><br><span class="line">    int temp = 0 ;</span><br><span class="line">    vector&lt;int&gt; arr;</span><br><span class="line">    bool find = false;</span><br><span class="line">    for(int i =0;i&lt;N;i++)&#123;</span><br><span class="line">        int mi;</span><br><span class="line">        cin &gt;&gt; mi;</span><br><span class="line">        arr.emplace_back(mi);</span><br><span class="line">    &#125;</span><br><span class="line">      for(int i = 127;i&gt;=0;i--)&#123;</span><br><span class="line">          for(int j=0;j&lt;N;j++)&#123;</span><br><span class="line">              temp += arr[j]^i;</span><br><span class="line">          &#125;</span><br><span class="line">          if(temp &lt;= M)&#123;</span><br><span class="line">              find = true;</span><br><span class="line">              res = i;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">          temp = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      res = find?res:-1;</span><br><span class="line">     cout &lt;&lt; &quot;Case #&quot; &lt;&lt; case_num &lt;&lt; &quot;: &quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">    solve(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="贪心-位运算巧妙运用"><a href="#贪心-位运算巧妙运用" class="headerlink" title="贪心+位运算巧妙运用"></a>贪心+位运算巧妙运用</h2><p>按照上面的方法，我们可以发现这个大样例的0&lt;=Ai&lt;=pow(10,15),对应M也是这个范围。我们可以发现要用49位来表示，也就是说从pow(2,50)开始往下找到第一个符合条件的即可。但是这个数太大了。<br>然后我们发现原来式子的值可以这么改。<br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191023095812.png" alt=""><br>这样我们就通过位运算来找最大的K值了。<br>怎么找呢。我们找K的时候也是按照比特位从高位开始找，尽可能让高位取1，注意这里要保证当我这个位置取1之后加上后面的所有值的最小值不会超过M，那么才可以取。如果取不了1，那就试一下可不可以取0，同理如果这个位置取0，也要看加上后面所有位所形成的最小值会不会超过K，若是没有超过，则可以取，如果超过，那么说明这个数不存在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int maxn = 50;</span><br><span class="line">LL pre[maxn], zeros[maxn], ones[maxn], minc[maxn], vis[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    for (int t = 1; t &lt;= T; ++t) &#123;</span><br><span class="line">        LL N, M;</span><br><span class="line">        </span><br><span class="line">        scanf(&quot;%lld %lld&quot;,&amp;N, &amp;M);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0;i&lt;maxn;i++)&#123;</span><br><span class="line">              vis[i] = 0;</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;N; i++)&#123;</span><br><span class="line">            LL temp;</span><br><span class="line">            scanf(&quot;%lld&quot;, &amp;temp);</span><br><span class="line">            for(int j = maxn - 1; j &gt;= 0; j--)&#123;</span><br><span class="line">                if((temp&gt;&gt;j)&amp;1)&#123;</span><br><span class="line">                    vis[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = maxn-1; i &gt;= 0; i--)&#123;</span><br><span class="line">            LL a = vis[i] * (1LL&lt;&lt;i);</span><br><span class="line">            LL b = (N-vis[i]) * (1LL&lt;&lt;i);</span><br><span class="line">            ones[i] = a;</span><br><span class="line">            zeros[i] = b;</span><br><span class="line">            minc[i] = min(a,b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre[0] = 0;</span><br><span class="line">        for(int i = 1;i &lt; maxn; i++)&#123;</span><br><span class="line">            pre[i] = pre[i-1]+minc[i-1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL res = 0;</span><br><span class="line">        LL temp = 0;</span><br><span class="line">        for(LL i = maxn - 1; i &gt;=0; i--)&#123;</span><br><span class="line">            if((zeros[i]+temp+pre[i])&lt;=M)&#123;</span><br><span class="line">                temp += zeros[i];</span><br><span class="line">                res += (1LL&lt;&lt;i);</span><br><span class="line">            &#125;else if(temp+ones[i]+pre[i]&lt;=M)&#123;</span><br><span class="line">                temp += ones[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res = -1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld \n&quot;, t, res);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方一定需要搞清楚的是，从最高位开始找的时候，并不是取1就可以，因为后面所有的位的0和1的情况会形成一个数字的范围，而不是0.一定要注意。</p>
<h1 id="本题收获"><a href="#本题收获" class="headerlink" title="本题收获"></a>本题收获</h1><ol>
<li>要注意看测试集的测试用例的条件，尤其是大小，直接会决定我们的数据类型是int或者long long或者其他。</li>
<li>要注意题目隐含的条件，这个条件并不是单纯的从最高位到最低位的贪心，而是有后续隐含条件的贪心，所以一定要注意。</li>
<li>对于位运算，一定要学会使用移位运算符以及对应的位运算操作，有时候可能会有巧妙的作用。</li>
<li>因为c++的灵活性，可以通过地址进行操作，所以在使用数组的时候一定要注意不要越界，在进行相关条件判断的时候一定要小心。当报错说运行时错误的时候，多半就是for循环的条件写错了或者数组越界了。还有当你发现在本地跑的和在kickstart上跑同一份代码，但是结果不一样的时候，多半也是地址错了，以后要注意！</li>
<li>做出来这个题目的感觉很爽啊，继续加油～</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title>kickstart-2019-G-T1-BookReading</title>
    <url>/2019/10/22/kickstart-2019-G-T1-BookReading/</url>
    <content><![CDATA[<p>上周六和同学一起尝试了一下Google Kickstart的题目，开了开眼，涨了涨见识！<br>本文是G轮第一题BookReading的思路以及代码，留个纪念。</p>
<a id="more"></a>

<h2 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e02/000000000018fd0d" target="_blank" rel="noopener">题目详情</a></h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>Supervin is a librarian handling an ancient book with N pages, numbered from 1 to N. Since the book is too old, unfortunately M pages are torn out: page number P1, P2, …, PM.</p>
<p>Today, there are Q lazy readers who are interested in reading the ancient book. Since they are lazy, each reader will not necessarily read all the pages. Instead, the i-th reader will only read the pages that are numbered multiples of Ri and not torn out. Supervin would like to know the sum of the number of pages read by each reader.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, M, and Q, the number of pages in the book, the number of torn out pages in the book, and the number of readers, respectively. The second line contains M integers, the i-th of which is Pi. The third line contains Q integers, the i-th of which is Ri.</p>
<h3 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h3><p>Time limit: 40 seconds per test set.<br>Memory limit: 1GB.<br>1 ≤ T ≤ 100.<br>1 ≤ P1 &lt; P2 &lt; … &lt; PM ≤ N.<br>1 ≤ Ri ≤ N, for all i.</p>
<p>Test set 1 (Visible)<br>1 ≤ M ≤ N ≤ 1000.<br>1 ≤ Q ≤ 1000.</p>
<p>Test set 2 (Hidden)<br>1 ≤ M ≤ N ≤ 105.<br>1 ≤ Q ≤ 105.</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191023100352.png" alt=""></p>
<h2 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h2><p>图书管理员想知道大家一共读了多少页书，需要我们统计。<br>已知情况是书的总页数N，坏了的页数M，有Q个读者。<br>然后知道坏的M分别是那些页，知道读者每个人都要读那些页（实际上知道的是基数，这个读者会读这个基数的整数倍）。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果大家想看最终结果，可以直接翻到最后，然后前面的代码写的比较乱，后来经过王博指点，有了很大的改善。好的代码习惯还是要保持的。</p>
<h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>一看题目很简单，对于每个人来说，如果书籍不坏，那么他可以读页数/基数页，然后看看坏了的页数中有几个是基数的倍数，减去就可以。然后我们最终的结果就是每个人的结果加和。<br>代码如下，写的很乱，而且第二个样例不出意外的超时了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solve(int case_num)&#123;</span><br><span class="line">    int N,M,Q;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;Q;</span><br><span class="line">    vector&lt;int&gt; torn;</span><br><span class="line">    int res =0;</span><br><span class="line">    //vector&lt;int&gt; reader;</span><br><span class="line">    for(int i = 0;i&lt;M;i++)&#123;</span><br><span class="line">        int mi;</span><br><span class="line">        cin &gt;&gt; mi;</span><br><span class="line">        torn.emplace_back(mi);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i =0;i&lt;Q;i++)&#123;</span><br><span class="line">        int ri;</span><br><span class="line">        cin &gt;&gt; ri;</span><br><span class="line">        int num = N/ri;</span><br><span class="line">        int sortnum =0;</span><br><span class="line">        for(int j = 0;j&lt;M;j++)&#123;</span><br><span class="line">            if(torn[j]%ri==0)&#123;</span><br><span class="line">                sortnum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += (num - sortnum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Case #&quot; &lt;&lt; case_num &lt;&lt; &quot;: &quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">    solve(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划求解"><a href="#动态规划求解" class="headerlink" title="动态规划求解"></a>动态规划求解</h3><p>仔细想想，其实我们上面暴力的时间复杂度是O（M<em>Q），当破坏的页数很多的时候，很多判断是无效的，没有意义的，比如某位读者只读2的倍数，那么我其实只要判断2，4，6，2</em>n&lt;=N这些页就可以。其他的页数完全可以不用判断，所以这个地方可以简化。于是是不是可以把每个基数对应的结果都算出来，然后当读读者的基数的时候，直接将其求和就可以呢？当然可以！于是就有了下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int a[MAXN],ans[MAXN];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t,x;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">        int N,M,Q;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;Q);</span><br><span class="line"></span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            a[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            a[x] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i&lt;=N; i++)&#123;</span><br><span class="line">            for(int j =i; j &lt;= N; j+=i)&#123;</span><br><span class="line">                 ans[i] += a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LL res =0;</span><br><span class="line">        for( int i = 1; i &lt;= Q; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            res += ans[x];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,res);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0;i&lt;=N;i++)&#123;</span><br><span class="line">            ans[i] = 0;</span><br><span class="line">            a[i] =0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进一步动态规划"><a href="#进一步动态规划" class="headerlink" title="进一步动态规划"></a>进一步动态规划</h3><p>上面的方法把所有的基数对应的结果都算出来了，但是其实中间的很多结果我们是用不到的，比如我们就两个读者，分别读2的倍数和3的倍数，而上面那个方法将1-N的所有结果都算出来了，最后只用了2和3对应的结果而已，这样就造成了浪费。所以我们是不是可以将结果进行保存，下次来了一个读者，看看之前有没有算过，如果算过，就直接用之前保存的结果，如果没有算过，那么就计算一下，然后保存起来呢？当然可以！于是就有了下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int getPage(int N,int i,int arr[])&#123;</span><br><span class="line">    int res =0;</span><br><span class="line">    for(int j = i; j&lt;=N; j+=i)&#123;</span><br><span class="line">        res += arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a[MAXN],ans[MAXN];</span><br><span class="line">int N,M,Q;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t,x;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;Q);</span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            a[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            a[x] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(ans, 0, sizeof ans);</span><br><span class="line">      </span><br><span class="line">        LL res =0;</span><br><span class="line">        for( int i = 1; i &lt;= Q; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            if(ans[x]==0)&#123;</span><br><span class="line">                ans[x] = getPage(N, x,a);</span><br><span class="line">            &#125;</span><br><span class="line">            res += ans[x];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,res);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本题收获"><a href="#本题收获" class="headerlink" title="本题收获"></a>本题收获</h2><ol>
<li>了解到了比较好的编码规范，以后会应用到实践中。</li>
<li>锻炼了自己分析问题的能力，提高算法的效率很重要，而其中的意识要逐渐培养。</li>
<li>认识到了c++灵活但是有时候太灵活，以后需要好好注意如何使用。</li>
<li>知道了kickstart的难度以及自己的水平。刷题路漫漫，以后请加油。</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>终端工具tmux资料分享</title>
    <url>/2019/10/21/tmux-reference/</url>
    <content><![CDATA[<ol>
<li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html" target="_blank" rel="noopener">阮一峰-Tmux 使用教程</a><br>从浅入深，娓娓道来，非常棒。</li>
<li><a href="https://louiszhai.github.io/2017/09/30/tmux/#Tmux%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener">路易斯-Tmux使用手册</a><br>大牛无疑，介绍的非常干练，私人定制部分写的特别好。</li>
<li><a href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7#file-tmux-cheatsheet-markdown" target="_blank" rel="noopener">GitHub-Tmux 快捷键 &amp; 速查表 &amp; 简明教程</a><br>方便大家使用。</li>
</ol>
]]></content>
      <categories>
        <category>工具推荐</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>喜大普奔，庆文又搭博客了。</title>
    <url>/2019/10/18/hello-world-1/</url>
    <content><![CDATA[<p>最近看到一句话，</p>
<pre><code>有了自己的博客，就仿佛自己在互联网中留下了自己的脚印.</code></pre><p>还挺有诗意的，所以我就把这个博客搭建起来了。</p>
<a id="more"></a>

<h1 id="博客写点啥呢"><a href="#博客写点啥呢" class="headerlink" title="博客写点啥呢"></a>博客写点啥呢</h1><h2 id="可能会帮到别人的东西"><a href="#可能会帮到别人的东西" class="headerlink" title="可能会帮到别人的东西"></a>可能会帮到别人的东西</h2><p>本部分包含但不限于代码的bug解决办法，代码规范，leetcode题解。</p>
<h2 id="自己觉得需要整理的东西"><a href="#自己觉得需要整理的东西" class="headerlink" title="自己觉得需要整理的东西"></a>自己觉得需要整理的东西</h2><p>本部分包含但不限于对于某个问题的求解过程。</p>
<h2 id="也许写点乱七八糟的推荐"><a href="#也许写点乱七八糟的推荐" class="headerlink" title="也许写点乱七八糟的推荐"></a>也许写点乱七八糟的推荐</h2><p>本部分包含但是不限于对于书籍电影动漫等的推荐。</p>
<p>目标就是等我回忆青春的时候，再来这个博客瞅瞅，让我能够感慨一句，我当年也干了很多事情呀。</p>
<h1 id="博客搭建参考"><a href="#博客搭建参考" class="headerlink" title="博客搭建参考"></a>博客搭建参考</h1><ol>
<li><a href="https://cuiqingcai.com/7625.html" target="_blank" rel="noopener">崔庆才-利用 GitHub + Hexo + Next 从零搭建一个博客</a></li>
<li><a href="https://juejin.im/post/5a308ae551882540f363879a" target="_blank" rel="noopener">为你的hexo博客配置个性域名</a></li>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo-中文文档</a></li>
</ol>
]]></content>
      <categories>
        <category>文言文语</category>
      </categories>
      <tags>
        <tag>杂事</tag>
      </tags>
  </entry>
</search>
