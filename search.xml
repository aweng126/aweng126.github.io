<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>kickstart-2019-H-T1-HIndex</title>
    <url>/2019/11/17/kickstart-2019-H-T1-HIndex/</url>
    <content><![CDATA[<p>2019年kickstart最后一轮，下午1点到4点。<br>真心感慨，自己要学的东西还有很多啊，<br>本文是第一题H-index，计算科研人员影响因子的一道题目。</p>
<a id="more"></a>

<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edd/00000000001a274e" target="_blank" rel="noopener">Problem</a></h2><p>It is important for researchers to write many high quality academic papers. Jorge has recently discovered a way to measure how impactful a researcher’s papers are: the H-index.</p>
<p>The H-index score of a researcher is the largest integer h such that the researcher has h papers with at least h citations each.</p>
<p>Jorge has written N papers in his lifetime. The i-th paper has Ai citations. The number of citations that each paper has will never change after it is written. Please help Jorge determine his H-index score after each paper he wrote.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing N, the number of papers Jorge wrote.</p>
<p>The second line contains N integers. The i-th integer is Ai, the number of citations the i-th paper has.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is a space-separated list of integers. The i-th integer is the H-index score after Jorge wrote his i-th paper.</p>
<h2 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h2><p>Time limit: 50 seconds per test set.<br>Memory limit: 1GB.<br>1 ≤ T ≤ 100.<br>1 ≤ Ai ≤ 105.</p>
<h2 id="Test-set"><a href="#Test-set" class="headerlink" title="Test set"></a>Test set</h2><h3 id="Test-set-1-Visible"><a href="#Test-set-1-Visible" class="headerlink" title="Test set 1 (Visible)"></a>Test set 1 (Visible)</h3><p>1 ≤ N ≤ 1000.</p>
<h3 id="Test-set-2-Hidden"><a href="#Test-set-2-Hidden" class="headerlink" title="Test set 2 (Hidden)"></a>Test set 2 (Hidden)</h3><p>1 ≤ N ≤ 105.</p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Input</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5 1 2</span><br><span class="line">6</span><br><span class="line">1 3 3 2 2 15</span><br><span class="line"></span><br><span class="line">//Output</span><br><span class="line">Case #1: 1 1 2</span><br><span class="line">Case #2: 1 1 2 2 2 3</span><br></pre></td></tr></table></figure>

<p>In Sample Case #1, Jorge wrote N = 3 papers.<br>After the 1st paper, Jorge’s H-index score is 1, since he has 1 paper with at least 1 citation.<br>After the 2nd paper, Jorge’s H-index score is still 1.<br>After the 3rd paper, Jorge’s H-index score is 2, since he has 2 papers with at least 2 citations (the 1st and 3rd papers).</p>
<p>In Sample Case #2, Jorge wrote N = 6 papers.<br>After the 1st paper, Jorge’s H-index score is 1, since he has 1 paper with at least 1 citation.<br>After the 2nd paper, Jorge’s H-index score is still 1.<br>After the 3rd paper, Jorge’s H-index score is 2, since he has 2 papers with at least 2 citations (the 2nd and 3rd papers).<br>After the 4th paper, Jorge’s H-index score is still 2.<br>After the 5th paper, Jorge’s H-index score is still 2.<br>After the 6th paper, Jorge’s H-index score is 3, since he has 3 papers with at least 3 citations (the 2nd, 3rd and 6th papers).</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="原始版思路"><a href="#原始版思路" class="headerlink" title="原始版思路"></a>原始版思路</h3><p>因为每次写完一篇文章都要给出一个结果，所以肯定每次有新的文章都要重新计算一次，而H-index的计算方式是说至少有h篇文章，然后每篇文章都至少有h的引用数，所以我就联想到上一轮kickstart的第一题，借鉴到相同思路，我们可以通过建立一个数组，保存对应的引用数目，</p>
<p>比如有N篇文章，那么引用最高为N，方便起见，我们建立一个N+1的数组（全部初始化为0）。0索引位置不再使用。然后每个位置代表有这个引用的文章有多少篇，然后在我寻找h-index的时候，只要当前位置寻找arr[i] &gt;=i的第一个数字即可。</p>
<p>以[5,1,2]为例进行讲解。</p>
<ol>
<li>首先建立一个4(也就是3+1)个元素的数组，[0,0,0,0]</li>
<li>第一个数字为5，那么1到3号索引位置元素都+1，变成[0,1,1,1];<br>这个时候从1号索引位置往前找第一个符合arr[i]&gt;=i的元素，也就是1；</li>
<li>第二个数字为1，那么1号索引位置元素+1，变成[0,2,1,1];<br>这个时候从2号索引位置往前找第一个符合arr[i]&gt;=i的元素，还是1；</li>
<li>第三个数字是2，那么1号到2号索引位置元素+1，变成[0,3,2,1];<br>这个时候从3号索引位置往前找第一个符合arr[i]&gt;=i的元素，此时变成了2；</li>
<li>所以最终的结果也就是[1,1,2]</li>
</ol>
<p>算法复杂度是O(n^2)，可以通过小case。</p>
<h3 id="升级版思路"><a href="#升级版思路" class="headerlink" title="升级版思路"></a>升级版思路</h3><p>这个思路就会比较好，构造了一个multiset来存储元素，这里的一个好处就是他会对插入的元素进行自动排序，默认是从小到大的顺序，底层是用红黑树实现的，插入删除查找的复杂度都是lg(n)级别的。然后我们每次将读入的数字插入到multiset中，然后判断头元素（实际就是所有元素中最小的元素）是否小于容器内元素个数。如果小于，那么删除头元素。最后我们想要的h-index其实就是每一轮之后的容器内元素个数。</p>
<p>还是以[5,1,2]为例进行讲解。</p>
<ol>
<li>开始插入5，此时s={5},然后5大于当前元素个数1，所以s保持不变s={5},所以第一轮结果为1；</li>
<li>然后插入1，此时s={1,5}, 此时1是小于当前元素个数2，所以要删除第一个元素，s变成{5},所以第二轮结果为1；</li>
<li>然后插入2，此时s={2,5},然后2要等于当前元素个数，所以s保持不变，s= {2,5},所以第三轮返回结果为2.</li>
<li>所以最终结果也就是[1,1,2]</li>
</ol>
<p>算法的复杂度为O(nlgn)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    string res;</span><br><span class="line">    for (int t = 1; t &lt;= T; ++t) &#123;</span><br><span class="line">        int M;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;M);</span><br><span class="line">        vector&lt;int&gt; arr(M+1,0);</span><br><span class="line">  </span><br><span class="line">        int x;</span><br><span class="line">        arr[0] = 0;</span><br><span class="line">        res =&quot;&quot;;</span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">             scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">             for(int j = 1; j &lt;= x &amp;&amp; j&lt;=M ; j++)&#123;</span><br><span class="line">                  arr[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">             int k = i;</span><br><span class="line">             while(k&gt;0)&#123;</span><br><span class="line">                 if(arr[k] &gt;= k)&#123;</span><br><span class="line">                     res  += &quot; &quot;+to_string(k);</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 k--;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Case #%d: %s \n&quot;, t, res.c_str());</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="升级版"><a href="#升级版" class="headerlink" title="升级版"></a>升级版</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    string res;</span><br><span class="line">    for (int t = 1; t &lt;= T; ++t) &#123;</span><br><span class="line">        int M;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;M);</span><br><span class="line">        int x;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        multiset&lt;int&gt; aset;</span><br><span class="line">        for(int i = 0;i&lt;M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">            aset.insert(x);</span><br><span class="line">            int b = *aset.begin();</span><br><span class="line">            if(b &lt; aset.size())&#123;</span><br><span class="line">                aset.erase(aset.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            res += &quot; &quot;+to_string(aset.size());</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %s \n&quot;, t, res.c_str());</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ol>
<li>想了一下这个题目和之前G轮的第一题<a href="http://kingwen.cn/2019/10/22/kickstart-2019-G-T1-BookReading/" target="_blank" rel="noopener">BookReading</a>有什么不同，结论是对于bookreading来说，首先是把所有的结果都统计一遍之后，然后所有的测试用例都只需要访问之前的结果就可以了（用一个数组来表示每页书的情况，然后读取对应因子的倍数得到相应的结果，其实就是上面链接中的动态规划第一版）从而可以节省大量的时间。但是本题目并不是这样子，本题目对于每次的有一个新的数值输入，都会进行新一轮的结果运算，所以如果我们再依次的去保存每一个位置的结果，尤其是通过对数组中元素依次加1的方式实现，复杂度必然会很高，现在想想的话，其实就比每次都完全的遍历一遍（每一次都从index开始找，看看paper数组中元素个数有没有大于index，找到第一个复合条件的即可,总的时间复杂度为O(n^3)）好那么一点。然后考虑到我们其实想要的结果是数量，所以就可以非常巧妙的利用一些数据结构，上面的测试用例用的是multiset，其实用最小堆，用unordered_map都可以实现，重点是保证内部元素有序，从而可以利用容器中的数量来变相的表示我们想要的结果。</li>
<li>以后要注意很多有用的数据结构的使用方法，比如本次使用的就是multiset这个数据结构，有机会再去看看其内部实现，首先要知道才能在真正要使用的时候想到它。</li>
<li>题目做的还是太少了，见识太少了，以后还是要坚持刷题啊，见多识广才能见怪不怪。</li>
<li>看人家的好的解题思路真的是赏心悦目，倍感舒适啊。</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
        <tag>multiset</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-861-ScoreAfterFlippingMatrix</title>
    <url>/2019/11/13/leetcode-861-ScoreAfterFlippingMatrix/</url>
    <content><![CDATA[<p>本题目和之前的kickstart的G轮的第二题有一点类似。<br>为了保证最后的数值最大，在保证最高位是1的基础上，保证之后的每一列尽可能有更多的1，非常巧妙也非常实用。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>We have a two dimensional matrix A where each value is 0 or 1.</p>
<p>A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.</p>
<p>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.</p>
<p>Return the highest possible score.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class="line">Output: 39</span><br></pre></td></tr></table></figure>
<p>Explanation:<br>Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].<br>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</p>
<p>Note:<br>1 &lt;= A.length &lt;= 20<br>1 &lt;= A[0].length &lt;= 20<br>A[i][j] is 0 or 1.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法</p>
<h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><p>我们会发现，在二进制串中，即使从次高位到最低位全部都是1也比最高位是1要小，所以为了保证最后形成的二进制串最大，必然每一行的第一位一定是1，然后对于从第二列开始之后的每一列，要尽可能有更多的1。</p>
<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><ol>
<li><p>为了保证最后形成的二进制的数字最大，我们要保证最高位是1， </p>
</li>
<li><p>非常巧妙的用了移位来进行二进制的乘法运算，比如说</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&lt;&lt;2</span><br></pre></td></tr></table></figure>
<p>实际上就变成了0b100(二进制的100)，也就是从1变成了4，相当于乘上了2的2次方。</p>
</li>
<li><p>在统计每一列0和1数目的时候也没有真的将数字进行一一遍历进行计算，而是通过是否和第一位数字相同来进行判断，原因是进行行变化之后，其实每个数字和本行的第一个数字的相同与否并没有发生变化，而我们为了让最终数值最大所以保证了每行的第一个数字都必须是1，从而通过与1的相同与否我们判定出每一列的0和1的个数，进而让多的数是1可以保证本列最后的数值也会是最大的。 </p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int matrixScore(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;</span><br><span class="line">        int m = A.size();</span><br><span class="line">        int n = A[0].size();</span><br><span class="line">        int res = m*(1&lt;&lt;(n-1));</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; m;j++)&#123;</span><br><span class="line">                 cnt += (A[j][0]==A[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res += max(cnt,m-cnt)*(1&lt;&lt;(n-1-i));</span><br><span class="line">            cnt = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-765-CouplesHoldingHands</title>
    <url>/2019/11/13/leetcode-765-CouplesHoldingHands/</url>
    <content><![CDATA[<p>情侣换座位手牵手的题目。<br>思想有点像打气球那个题目：处理好当下的问题，慢慢往后遍历，以后的问题也会变得很顺利，回头还会发现这其实就是最好的方法。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.</p>
<p>The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).</p>
<p>The couples’ initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: row = [0, 2, 1, 3]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Explanation: We only need to swap the second (row[1]) and third (row[2]) person.</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: row = [3, 2, 0, 1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>Explanation: All couples are already seated side by side.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法。</p>
<h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><p>如果我们仔细看就会发现，其实我们在判断的时候只要确定了两个数中的一个，那么另外一个数是多少其实就是已经确定好了的，然后我们将这个数本身所在的位置替换掉就可以了。比如说下面的例子，第一个元素是5，那么第二个元素必然是6，我们只要找到6，然后将6本身所在的位置的数字替换成第二个元素本身的元素4就可以了。<br>以题目中的某个用例来进行说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始数组：[5,6,4,0,2,1,9,3,8,7,10,11]</span><br><span class="line">i= 0: 5 4   6   0   2   1   9   3   8   7   10  11  </span><br><span class="line">i= 2: 5 4   6   7   2   1   9   3   8   0   10  11  </span><br><span class="line">i= 4: 5 4   6   7   2   3   9   1   8   0   10  11  </span><br><span class="line">i= 6: 5 4   6   7   2   3   9   8   1   0   10  11  </span><br><span class="line">i= 8: 5 4   6   7   2   3   9   8   1   0   10  11  </span><br><span class="line">i=10: 5 4   6   7   2   3   9   8   1   0   10  11</span><br></pre></td></tr></table></figure>
<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><ol>
<li>大道至简，大智若愚。从头开始，每次都做好当前元素的判断，那么后面的元素都会依次的处理好。</li>
<li>对于当前位置要进行奇偶判断，因为不确定配偶的左右情况，所以要自行判断。</li>
<li>要会使用stl中的各种比较巧妙的方法，比如本题目中用到的find和distance。</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSwapsCouples(vector&lt;int&gt;&amp; row) &#123;</span><br><span class="line">        if(row.size() &lt;=  2) return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0; i &lt; row.size(); i += 2)&#123;</span><br><span class="line">            if(row[i]%2 == 0)&#123;</span><br><span class="line">                if(row[i+1] == row[i]+1)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    auto a = find(row.begin(),row.end(),row[i]+1);</span><br><span class="line">                    int index = distance(row.begin(),a);</span><br><span class="line">                    row[index] = row[i+1];</span><br><span class="line">                    row[i+1] = row[i]+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(row[i+1] == row[i]-1)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    auto a = find(row.begin(),row.end(),row[i]-1);</span><br><span class="line">                    int index = distance(row.begin(),a);</span><br><span class="line">                    row[index] = row[i+1];</span><br><span class="line">                    row[i+1] = row[i]-1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-452-MinimumNumberOfArrowsToBurstBalloons</title>
    <url>/2019/11/12/leetcode-452-MinimumNumberOfArrowsToBurstBalloons/</url>
    <content><![CDATA[<p>射箭，问射穿所有气球最少射几箭。<br>抽象出来之后，其实也是区间类型的题目。只是这次的排序方式相比与之前发生了点变化。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.</p>
<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>Explanation:<br>One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法</p>
<h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><p>射气球，总的来看，其实第一支箭一定会射在第一个气球的范围之内，比如说[1,6]，而第二支箭一定是要射在第一个[1,6]覆盖不到的第一个气球的区间之内的。所以当我们按照他们的区间后端进行排序之后，就会很容易找到第一个不重合的气球，每次遇到一个与之前不重合的气球，就射一箭，从而可以实现最优解。</p>
<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><ol>
<li>之前的排序其实都是按照有序对的第一个元素进行排序，然后本题目是按照第二个元素排序，就可以使得题目变得非常的简单有效。</li>
<li>复习之前的lambda表达式的用法。<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">        if(points.empty()) return 0;</span><br><span class="line">        sort(points.begin(), points.end(),[](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">            return (a[1] &lt; b[1]);</span><br><span class="line">        &#125;);</span><br><span class="line">        int res = 1;</span><br><span class="line">        int end = points[0][1];</span><br><span class="line">        for(int i = 1; i &lt;  points.size(); i++)&#123;</span><br><span class="line">            if(points[i][0] &gt; end)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                end = points[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-435-Non-overlapping-Intervals</title>
    <url>/2019/11/12/leetcode-435-Non-overlapping-Intervals/</url>
    <content><![CDATA[<p>非重复区间的一个题目，思路比较清晰,感觉和406题有点异曲同工之妙。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,2],[1,2],[1,2]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.</p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [[1,2],[2,3]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>Explanation: You don’t need to remove any of the intervals since they’re already non-overlapping.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法</p>
<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><p>要记得按照从小到大的顺序进行排序,然后看后一个区间的头是否在前一个区间内，如果没有，那么不用删，如果在，那么肯定要删一个。要么删除前面那个区间，要么删除后面那个区间。比如说[1,3]和[2,4],那么因为2在[1,3]内，所以这个时候肯定要删除[2,4],因为[2,4]在[1,3]更加靠后的位置。但是如果前面是[1,10],然后后面有[2,3]和[4,5]这种情况最好是删除第一个[1,10]，因为[1,10]包含的区间更加靠后。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if(intervals.empty()) return 0;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">       </span><br><span class="line">        int res = 0;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        for(auto p : intervals)&#123;</span><br><span class="line">            if( temp.empty() || p[0] &gt;= temp[1])&#123;</span><br><span class="line">                temp = p; </span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res++;</span><br><span class="line">                temp = p[1] &lt; temp[1]? p:temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束！</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-406-QueueReconstructionbyHeight</title>
    <url>/2019/11/11/leetcode-406-QueueReconstructionbyHeight/</url>
    <content><![CDATA[<p>这道题目不是很难，但是思路也很好玩.<br>通过这道题，我们还可以顺便掌握c++11中刚刚引入的lambda表达式，非常棒！</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.</p>
<p>Note:<br>The number of people is less than 1,100.</p>
<h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><p>Input:<br>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</p>
<p>Output:<br>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法。</p>
<h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><p>最开始先排序，按照如下规则进行排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果第一个元素不等，那么大的在前。</span><br><span class="line">如果第一个元素相等，那么第二个元素小的在前。</span><br></pre></td></tr></table></figure>
<p>所以变化如下。</p>
<ol>
<li>初始状态：[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</li>
<li>排序之后：[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</li>
</ol>
<p>接下来从第二个元素开始插入，按照如下规则进行排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将两个数构成的数组插入到数组中第二个数的位置。</span><br><span class="line">如将[6,1]插入到1号位置，将[5,2]插入到2号位置，注意这个地方要从前往后一次的进行插入。</span><br></pre></td></tr></table></figure>
<p>插入之后的变化依次如下,这里可以从第二个元素开始进行判断</p>
<ol start="3">
<li>插入[7,1]元素：[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</li>
<li>插入[6,1]元素：[[7,0], [6,1], [7,1], [5,0], [5,2], [4,4]]</li>
<li>插入[5,0]元素：[[5,0], [7,0], [6,1], [7,1], [5,2], [4,4]]</li>
<li>插入[5,2]元素：[[5,0], [7,0], [5,2], [6,1], [7,1], [4,4]]</li>
<li>插入[4,4]元素：[[5,0], [7,0], [5,2], [6,1], [4,4]，[7,1]]<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2></li>
<li>要学会使用lambda表达式，也就是如下的代码。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort(people.begin(), people.end(),[](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">                 return ((a[0] &gt; b[0]) ||(a[0] == b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
如果不使用lambda表达式那么就需要写成如下模样。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt; b)&#123;</span><br><span class="line">    return ((a[0] &gt; b[0]) ||(a[0] == b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">&#125;</span><br><span class="line"># 然后调用的时候如下</span><br><span class="line">sort(people.begin(),people.end(),cmp);</span><br></pre></td></tr></table></figure></li>
<li>发现排序之后整个vector可以插入的位置刚刚好是vector中第二个元素的位置。</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(),</span><br><span class="line">             [](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">                 return ((a[0] &gt; b[0]) ||(a[0] == b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">             &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; people.size(); i++ )&#123;</span><br><span class="line">            auto p = people[i]; </span><br><span class="line">            if(p[1] != i)&#123;</span><br><span class="line">                people.erase(people.begin()+i);</span><br><span class="line">                people.insert(people.begin() + p[1],p);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return people;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="升级代码"><a href="#升级代码" class="headerlink" title="升级代码"></a>升级代码</h3><p>上面的那种方法速度比较满，原因在于是在原数组上进行插入同时还要进行删除操作，而如果我们直接新建一个vector来保存结果，那么就只需要插入就可以了，然后速度会有很大的提升。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">        return (a[0] &gt; b[0] ||(a[0]==b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(),cmp);</span><br><span class="line">        </span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; ans;</span><br><span class="line">        for(int i = 0; i &lt; people.size(); i++ )&#123;</span><br><span class="line">            auto p = people[i]; </span><br><span class="line">            ans.insert(ans.begin()+p[1],p);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="再次升级代码"><a href="#再次升级代码" class="headerlink" title="再次升级代码"></a>再次升级代码</h3><p>为了代码好看，可以再次升级代码，使用增强的for循环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">        return (a[0] &gt; b[0] ||(a[0]==b[0] &amp;&amp; a[1] &lt; b[1]));</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(people.begin(), people.end(),cmp);</span><br><span class="line">        </span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; ans;</span><br><span class="line">        for(auto p:people)&#123;</span><br><span class="line">            ans.insert(ans.begin()+p[1],p);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上，本题结束。</p>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>how-to-save-pdf-images</title>
    <url>/2019/11/11/how-to-save-pdf-images/</url>
    <content><![CDATA[<p>本来想查一下如何写程序来提取pdf中的图片来着，然后发现可以用ps来实现，然后就先记录一下。</p>
<a id="more"></a>
<h2 id="通过PhotoShop进行保存"><a href="#通过PhotoShop进行保存" class="headerlink" title="通过PhotoShop进行保存"></a>通过PhotoShop进行保存</h2><ol>
<li>打开ps</li>
<li>选择ps的菜单选项 <strong>文件</strong>-&gt;<strong>打开</strong>（或者直接快捷键ctrl+o）打开想打开的pdf文件</li>
<li>在打开pdf选项页面的时候，注意选择<strong>图像</strong>，然后选择要打开的图片（可以通过按住shift进行多选），然后点击确定即可。如下图所示。<br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191111135210.png" alt=""></li>
<li>在图片页面进行保存操作，(也可以使用快捷键ctrl+s)，注意保存格式选择jpeg，重命名，选择保存地址，然后确定即可。<h2 id="截图保存"><a href="#截图保存" class="headerlink" title="截图保存"></a>截图保存</h2></li>
<li>平时的微信和QQ都是有默认的截图功能的，可以直接截图保存，以微信来举例，通过查看设置中的快捷键选项可以查看如何进行快速截图。<br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191111135655.png" alt=""><br>啊，这篇文章好水啊，哗哗哗～</li>
</ol>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>PDF</tag>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-330-PatchingArray</title>
    <url>/2019/11/09/leetcode-330-PatchingArray/</url>
    <content><![CDATA[<p>今天周六，好好做个题，明天就可以心安理得的出去玩啦！<br>然后就碰见了这个解题方法特别让人觉得奇妙的题目，算法这个东西实在是太神奇了。</p>
<a id="more"></a>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p>Input: nums = [1,3], n = 6<br>Output: 1<br>Explanation:<br>Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.<br>Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].<br>Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].<br>So we only need 1 patch.</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><p>Input: nums = [1,5,10], n = 20<br>Output: 2<br>Explanation: The two patches can be [2, 4].</p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><p>Input: nums = [1,2,2], n = 5<br>Output: 0</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心</p>
<h2 id="巧妙之处"><a href="#巧妙之处" class="headerlink" title="巧妙之处"></a>巧妙之处</h2><p>构造了一个miss缺失值，表示不能覆盖的最小值。最开始表示为1，表示此时不能表示范围为[0,1),然后去依次找数组中的值（要注意数组中的数据是排好序的，所以才可以这么用！），如果缺失值小于数组中的值，那么肯定要添加数，如果缺失值要是大于数组中的值，那么那么最小缺失值可以得到更新。最后如果最小缺失值大于n，那么就说明已经完成要求了。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>以sample2也就是nums = [1,5,10], n=20举例来讲</p>
<ol>
<li>初始化的时候，数组索引index = 0，最小缺失值miss为1，res为0；</li>
<li>此时miss&lt;=20成立，没有覆盖到[1,n]的范围，所以进入循环判断，此时nums[0] = 1&lt;=miss 而且index没有超出数组范围，所以miss会更新，加上当前数组索引位置，也就是说miss = 2，表示此时可以表示范围为[0,2)啦。</li>
<li>然后miss此时仍然不能表示n，继续往后走，此时nums[1] = 5, 是大于miss的，也就是说此时我们最多表示到1，但是你突然来了个5，那我[2,4]的数据怎么办，就只能自己往里添加啦，所以此时为了尽可能表示的数字变得更大，所以此时加上miss本身这个数，从而就可以表示  [0，miss+miss)的数字了，所以此时添加一个2，res在原来的基础上+1变为1，miss也就变成了4；</li>
<li>[0,4)依然不能表示[0,n],所以还是要继续判断，此时miss仍然小于nums[1],所以我仍然不能用nums中的数字来表示4这个数，所以继续向数组中添加4,然后此时可表示范围变成了[0,8),res+1变成2，添加了4这个数字。</li>
<li>[0,8)仍然表示不了[0,n],所以仍然没有结束，此时的miss大于nums[1],也就是miss&gt;5成立，所以此时nums到索引1然后再加上添加的元素可以表示数的范围就变成了[0,13).</li>
<li>[0.13)仍然表示不了[0,20]，所以继续，此时miss大于nums[2],所以如果nums中从0到索引2的所有数字加上之前添加的数字可以表示的数字范围就变成了[0,23).</li>
<li>[0.23)是可以表示[0,20]的，所以结束，最终结果需要添加两个数，一个2，一个4即可。<br>太神奇了。<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:    </span><br><span class="line">    int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123;</span><br><span class="line">        int res  = 0;</span><br><span class="line">        long miss = 1, i = 0;</span><br><span class="line">        while(miss &lt;= n)&#123;</span><br><span class="line">            if(i&lt;nums.size() &amp;&amp; nums[i] &lt;= miss)&#123;</span><br><span class="line">                miss += nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                miss += miss;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>create-my-leetcode-artical-template</title>
    <url>/2019/11/09/create-my-leetcode-artical-template/</url>
    <content><![CDATA[<p>在我每次写leetcode解题文章的时候，经常需要搞排版信息，一次两次还好，但是次数多了就会比较烦。那么我们能不能自定义一个属于自己的leetcode文章模版呢？当然可以！于是就有了本篇文章。</p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="从创建文章说起"><a href="#从创建文章说起" class="headerlink" title="从创建文章说起"></a>从创建文章说起</h3><p>我们在使用如下命令创建文章的时候，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new title</span><br></pre></td></tr></table></figure>
<p>实际上我们使用的是如下的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post title</span><br></pre></td></tr></table></figure>
<p>上面的命令是这个命令的缩写形式而已，因为一般搭建都不太会创建草稿（draft）或者页面（page），大家都是创建文章，它太常用了，所以就被设置成了默认选项。</p>
<h3 id="真实的创建命令"><a href="#真实的创建命令" class="headerlink" title="真实的创建命令"></a>真实的创建命令</h3><p>那么真实使用的创建命令是什么呢？其实是下面这个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>根据<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">官方文档</a>显示，hexo默认的layout有三种，分别是post，draft，page，他们都有自己的默认样式，他们文件本身都在scaffolds目录下面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog ls -l scaffolds </span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 liqingwen  staff  33 10 18 21:52 draft.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  44 10 18 21:52 page.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  76 10 21 16:48 post.md</span><br></pre></td></tr></table></figure>
<p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，所以我们要想创建自己的模版，只要在这里面创建一个leetcode模板即可，然后以后就可以通过如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new leetcode leetcode-number-nanme</span><br></pre></td></tr></table></figure>
<p>来创建符合对应布局的文章啦。</p>
<h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><ol>
<li><p>先查看模版中的文件有哪些</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog ls -l scaffolds </span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 liqingwen  staff  33 10 18 21:52 draft.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  44 10 18 21:52 page.md</span><br><span class="line">-rw-r--r--  1 liqingwen  staff  76 10 21 16:48 post.md</span><br></pre></td></tr></table></figure></li>
<li><p>查看我们常用的post模板中的内容，然后我们照着这个改写就可以啦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 查看模版中内容</span><br><span class="line">➜  blog cat scaffolds/post.md </span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- tag1</span><br><span class="line">categories:</span><br><span class="line">- cat1</span><br></pre></td></tr></table></figure></li>
<li><p>复制一份post，重命名为leetcode，然后将我们想要的东西都加进去，然后保存即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog cd scaffolds </span><br><span class="line">➜  scaffolds cp post.md leetcode.md</span><br><span class="line">➜  scaffolds ls</span><br><span class="line">draft.md    leetcode.md page.md     post.md</span><br><span class="line"></span><br><span class="line"># 注意这里我使用的是sublime编辑器，然后在文档中添加的内容已经通过后面的cat输出了，大家可以直接赋值。</span><br><span class="line">➜  scaffolds subl leetcode.md </span><br><span class="line"></span><br><span class="line">➜  scaffolds ls</span><br><span class="line">draft.md    leetcode.md page.md     post.md</span><br><span class="line">➜  scaffolds cat leetcode.md </span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- leetcode</span><br><span class="line">- hard,medium,easy</span><br><span class="line">- Greedy, DP, String </span><br><span class="line">categories:</span><br><span class="line">- 算法训练</span><br><span class="line">---</span><br><span class="line">摘要内容</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line">### sample1</span><br><span class="line">## 解题思路</span><br><span class="line">## 巧妙之处</span><br><span class="line">## 解题代码</span><br></pre></td></tr></table></figure></li>
<li><p>尝试使用leetcode模版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  scaffolds cd ..</span><br><span class="line">➜  blog hexo new leetcode &quot;leetcode-406-QueueReconstructionbyHeight&quot;   </span><br><span class="line">INFO  Created: ~/workplace/blog/source/_posts/leetcode-406-QueueReconstructionbyHeight.md</span><br><span class="line">➜  blog subl  source/_posts/leetcode-406-QueueReconstructionbyHeight.md</span><br></pre></td></tr></table></figure>
<p>大功告成，于是就可以可以很开心的写文章啦。</p>
</li>
<li><p>2019-11-12更新</p>
<ol>
<li>为了更加的解释算法过程，特地添加了详细解释部分。</li>
<li>为了更好的体现算法的演进，特地添加了算法升级部分。<br>升级之后结果如下。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">- leetcode</span><br><span class="line">- hard</span><br><span class="line">- medium</span><br><span class="line">- easy</span><br><span class="line">- Greedy;</span><br><span class="line">- DP</span><br><span class="line">- String </span><br><span class="line">categories:</span><br><span class="line">- 算法训练</span><br><span class="line">---</span><br><span class="line">摘要内容</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line">### Sample</span><br><span class="line">## 解题思路</span><br><span class="line">## 详细解释</span><br><span class="line">## 巧妙之处</span><br><span class="line">## 解题代码</span><br><span class="line">### 原始代码</span><br><span class="line">### 升级代码</span><br><span class="line">以上，本题结束！</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-67-AddBinary</title>
    <url>/2019/11/08/leetcode-67-AddBinary/</url>
    <content><![CDATA[<p>今天晚上总结了一下c++中string的常用的属性和方法，一时手痒，所以就找了个题目练练手，记录一下。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both non-empty and contains only characters 1 or 0.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p>Input: a = “11”, b = “1”<br>Output: “100”</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p>Input: a = “1010”, b = “1011”<br>Output: “10101”</p>
<h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>第一反应其实和两个数相加的那个题目类似，只是这里需要反向遍历即可。<br>这里的一个比较好的技巧就是学会补零。比如说1和1001进行相加，很明显，结果是1010。计算结果可以将1补充为0001，这样就可以数据对齐，然后就可以方便计算而不容易出现空指针了。</p>
<h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addBinary(string a, string b) &#123;</span><br><span class="line">        int alen = a.size();</span><br><span class="line">        int blen = b.size();</span><br><span class="line">        int mlen = max(alen, blen);</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        for(int i = 0; i &lt; mlen; i++)&#123;</span><br><span class="line">            int tempa = alen&gt;i?a[alen-i-1]-&apos;0&apos;:0;</span><br><span class="line">            int tempb = blen&gt;i?b[blen-i-1]-&apos;0&apos;:0;</span><br><span class="line">            int tres = tempa+tempb+carry;</span><br><span class="line">            if(tres == 0)&#123;</span><br><span class="line">                res.insert(0,1,&apos;0&apos;);</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else if(tres == 1)&#123;</span><br><span class="line">                res.insert(0,1,&apos;1&apos;);</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else if(tres == 2)&#123;</span><br><span class="line">                res.insert(0,1,&apos;0&apos;);</span><br><span class="line">                carry = 1;</span><br><span class="line">            &#125;else if(tres == 3)&#123;</span><br><span class="line">                res.insert(0,1,&apos;1&apos;);</span><br><span class="line">                carry = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry == 1)&#123;</span><br><span class="line">            res.insert(0,1,&apos;1&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-72-EditDistance</title>
    <url>/2019/10/24/leetcode-72-EditDistance/</url>
    <content><![CDATA[<p>编辑距离是一个非常经典的动态规划的题目，之前搞懂过，但是总是会忘，所以又搞了一遍，顺便做个笔记。</p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">题目描述</a></h2><p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following 3 operations permitted on a word:</p>
<ol>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>
<h2 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a>题目解读</h2><p>就是求两个字符串的最小编辑距离，也就是计算word1最少可以经过多少次变化(插入，删除，替换)可以变成word2。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="动态规划的具体思路"><a href="#动态规划的具体思路" class="headerlink" title="动态规划的具体思路"></a>动态规划的具体思路</h3><ol>
<li>dp[i][j]表示word1的[0,i)变成word2的[0,j)位需要多少次变化。</li>
<li>对于第0行，dp[0][i] = i for 0&lt;= i &lt;= len2; (len2是word2的字符串长度)</li>
<li>对于第0列，dp[i][0] = i for 0=&lt; i &lt;= len1; (len1是word1的字符串长度)</li>
<li>如果最后一位相同，则arr[i][j] = arr[i-1][j-1]</li>
<li>若是判断的最后一位不同，则arr[i][j] = min(arr[i-1][j]+1, arr[i][j-1]+1 ,arr[i-1][j-1]+1)</li>
<li>最后返回arr[len1][len2]</li>
</ol>
<h3 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h3><p>这里解释一下第4步，也是看了好久才明白的。</p>
<p>下面以word1=”abb”,word2=”ac”为例。</p>
<ol>
<li>首先明确一下问题：我们现在要求的是abb需要多少步会变到ac，而假设我们已经知道了ab变ac，abb变a，ab变a三种情况，我们只需要现在的情况变到之前已知的情况就解决了。</li>
<li>假设abb-&gt;ac是从ab-&gt;ac变过来的，那么我们只要将abb去掉最后一个b就可以，剩下的就是要考虑ab如何变成ac了。也就是arr[i][j]=arr[i-1][j]+1;</li>
<li>假设abb-&gt;ac是从abb-&gt;a变过来的，那么我们只要在abb后面插入一个c就可以实现最后一位的匹配，剩下的就是考虑abb如何变成a了。也就是arr[i][j] = arr[i][j-1]+1;</li>
<li>假设abb-&gt;ac是从ab-&gt;a变过来的，那么我们只要将abb的最后一位变成c，剩下的就是考虑如何将ab变成a了。也就是arr[i][j]=arr[i-1][j-1]+1;</li>
<li>最后我们选一个从三种方式中修改次数最小的一个就可以了</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        int len1 = word1.length();</span><br><span class="line">        int len2 = word2.length();</span><br><span class="line">        </span><br><span class="line">        int arr[len1+1][len2+1];</span><br><span class="line">        memset(arr,0,sizeof arr);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;= len1; i++)&#123;</span><br><span class="line">            arr[i][0] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;= len2; i++)&#123;</span><br><span class="line">            arr[0][i] = i;</span><br><span class="line">        &#125;      </span><br><span class="line">         for(int i = 1; i &lt;= len1; i++)&#123;</span><br><span class="line">             for(int j = 1;j &lt;= len2; j++)&#123;</span><br><span class="line">                 if(word1[i-1]==word2[j-1])&#123;</span><br><span class="line">                     arr[i][j] = arr[i-1][j-1];</span><br><span class="line">                 &#125;else&#123;</span><br><span class="line">                     arr[i][j] = min(min(arr[i-1][j],arr[i][j-1]),arr[i-1][j-1])+1;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        // for(int i = 0; i &lt;= len1; i++)&#123;</span><br><span class="line">        //      for(int j = 0;j &lt;= len2; j++)&#123;</span><br><span class="line">        //         cout&lt;&lt;arr[i][j]&lt;&lt;&apos;\t&apos;;         </span><br><span class="line">        //      &#125;</span><br><span class="line">        //     cout&lt;&lt;endl;</span><br><span class="line">        // &#125;</span><br><span class="line">        </span><br><span class="line">        return arr[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title>build-image-hosting-service-with-github-and-PicGo</title>
    <url>/2019/10/23/build-image-hosting-service-with-github-and-PicGo/</url>
    <content><![CDATA[<p>图床，就是用来存放图片的地方。</p>
<p>目前各个网站为了保证自己的图片不会被其他人盗用，几乎都设置了访问条件验证（比如通过网站登录所保存的cookie等），这样的话其他人可能就访问不到你的图片了，而我写博客就是想给别人看的呀，所以搭建一个自己的图床就迫在眉睫。</p>
<a id="more"></a>

<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol>
<li>github账号</li>
<li>良好的网络条件</li>
<li>耐心</li>
</ol>
<h2 id="具体做法参考"><a href="#具体做法参考" class="headerlink" title="具体做法参考"></a>具体做法参考</h2><ol>
<li><a href="https://juejin.im/entry/5c4ec5aaf265da614420689f" target="_blank" rel="noopener">掘金-PicGo+GitHub图床，让Markdown飞</a></li>
</ol>
<p>按照这个流程就可以完美搭建起来了，我就是照着这个做的。</p>
<ol start="2">
<li><a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo github下载地址</a></li>
</ol>
<p>这个是PicGo的下载地址，选择最新版本的进行下载即可。mac下载dmg格式，win下载exe格式即可。</p>
<ol start="3">
<li><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E9%A2%84%E8%A7%88" target="_blank" rel="noopener">PicGo 官方文档</a></li>
</ol>
<p>之所以把这个放上，是因为这个PicGo其实有很多扩展或者其他的功能，包括设置各种快捷键，各种图床的支持（包括七牛，阿里，github，腾讯云，又拍云等等。话说微博图床现在放盗链了，不建议使用），各种代理等的支持，大家可以进行私人定制，将这个软件做成自己喜欢的样子。</p>
<h2 id="本文感受"><a href="#本文感受" class="headerlink" title="本文感受"></a>本文感受</h2><ol>
<li>github是个好地方，开源的力量极其伟大。</li>
</ol>
<p>本来享用iPic来进行图片上传来着，但是它默认只给你微博图床，而现在不能用了。然后如果要开启其他图床支持，是要花钱的，难过的是我都要准备花钱了，网络问题，付费一直不成功，所以就找到了PicGo，完美。</p>
<ol start="2">
<li>有机会还是要花钱买服务</li>
</ol>
<p>github尽管免费，但是说实话，访问是有延迟的，七牛云我也注册了，但是实名认证需要时间，所以我就先直接用github来搭建图床了。等到博客访问量大了的时候到时候再付费买七牛云存储吧，嘿嘿。</p>
<ol start="3">
<li>好的教程感觉一份就够了</li>
</ol>
<p>所以对于自己感觉比较好的教程我就直接放链接了，如果有补充的话我再专门写文章来介绍一下。</p>
]]></content>
      <categories>
        <category>实用技能</category>
      </categories>
      <tags>
        <tag>FigureBed</tag>
        <tag>Github</tag>
        <tag>PicGo</tag>
      </tags>
  </entry>
  <entry>
    <title>kickstart-2019-G-T2-TheEquation</title>
    <url>/2019/10/22/kickstart-2019-G-T2-TheEquation/</url>
    <content><![CDATA[<p>还是上周和同学一起尝试的kickstart第G轮比赛，这个是第二题的思路和解法。<br>在经历各种报错，各种思路修正之后终于搞定了！快写下来！</p>
<a id="more"></a>

<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e02/000000000018fe36" target="_blank" rel="noopener">题目描述</a></h1><p><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/kickstart-2019-g-t2-description.jpg" alt=""><br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/kickstart-2019-g-t2-sample.jpg" alt=""></p>
<h1 id="题目理解"><a href="#题目理解" class="headerlink" title="题目理解"></a>题目理解</h1><p>就是找一个最大的K，使得K和每个元素进行亦或运算的和小于某个值。</p>
<h1 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h1><h2 id="Test-set1-暴力求解"><a href="#Test-set1-暴力求解" class="headerlink" title="Test set1 暴力求解"></a>Test set1 暴力求解</h2><p>下面的代码仅仅适应于小测试集。而之所以设置从127开始找，是因为看到了他给的测试集的范围。<br>对于Test set1中的每个元素而言，0&lt;=Ai&lt;=100,所以可以用6位表示。M也是可以用6位来表示，如果K的最高位不是第6位，而是第7位甚至更高，那么取亦或之后必然会大于128也就大于M，所以对于这个测试集来说，只要从127往下找到第一个符合条件的数字即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">// typedef long long ll;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">void solve(int case_num)&#123;</span><br><span class="line">    int N,M;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    int res = 0;</span><br><span class="line">    int temp = 0 ;</span><br><span class="line">    vector&lt;int&gt; arr;</span><br><span class="line">    bool find = false;</span><br><span class="line">    for(int i =0;i&lt;N;i++)&#123;</span><br><span class="line">        int mi;</span><br><span class="line">        cin &gt;&gt; mi;</span><br><span class="line">        arr.emplace_back(mi);</span><br><span class="line">    &#125;</span><br><span class="line">      for(int i = 127;i&gt;=0;i--)&#123;</span><br><span class="line">          for(int j=0;j&lt;N;j++)&#123;</span><br><span class="line">              temp += arr[j]^i;</span><br><span class="line">          &#125;</span><br><span class="line">          if(temp &lt;= M)&#123;</span><br><span class="line">              find = true;</span><br><span class="line">              res = i;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">          temp = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      res = find?res:-1;</span><br><span class="line">     cout &lt;&lt; &quot;Case #&quot; &lt;&lt; case_num &lt;&lt; &quot;: &quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">    solve(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="贪心-位运算巧妙运用"><a href="#贪心-位运算巧妙运用" class="headerlink" title="贪心+位运算巧妙运用"></a>贪心+位运算巧妙运用</h2><p>按照上面的方法，我们可以发现这个大样例的0&lt;=Ai&lt;=pow(10,15),对应M也是这个范围。我们可以发现要用49位来表示，也就是说从pow(2,50)开始往下找到第一个符合条件的即可。但是这个数太大了。<br>然后我们发现原来式子的值可以这么改。<br><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191023095812.png" alt=""><br>这样我们就通过位运算来找最大的K值了。<br>怎么找呢。我们找K的时候也是按照比特位从高位开始找，尽可能让高位取1，注意这里要保证当我这个位置取1之后加上后面的所有值的最小值不会超过M，那么才可以取。如果取不了1，那就试一下可不可以取0，同理如果这个位置取0，也要看加上后面所有位所形成的最小值会不会超过K，若是没有超过，则可以取，如果超过，那么说明这个数不存在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int maxn = 50;</span><br><span class="line">LL pre[maxn], zeros[maxn], ones[maxn], minc[maxn], vis[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    for (int t = 1; t &lt;= T; ++t) &#123;</span><br><span class="line">        LL N, M;</span><br><span class="line">        </span><br><span class="line">        scanf(&quot;%lld %lld&quot;,&amp;N, &amp;M);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0;i&lt;maxn;i++)&#123;</span><br><span class="line">              vis[i] = 0;</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;N; i++)&#123;</span><br><span class="line">            LL temp;</span><br><span class="line">            scanf(&quot;%lld&quot;, &amp;temp);</span><br><span class="line">            for(int j = maxn - 1; j &gt;= 0; j--)&#123;</span><br><span class="line">                if((temp&gt;&gt;j)&amp;1)&#123;</span><br><span class="line">                    vis[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = maxn-1; i &gt;= 0; i--)&#123;</span><br><span class="line">            LL a = vis[i] * (1LL&lt;&lt;i);</span><br><span class="line">            LL b = (N-vis[i]) * (1LL&lt;&lt;i);</span><br><span class="line">            ones[i] = a;</span><br><span class="line">            zeros[i] = b;</span><br><span class="line">            minc[i] = min(a,b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre[0] = 0;</span><br><span class="line">        for(int i = 1;i &lt; maxn; i++)&#123;</span><br><span class="line">            pre[i] = pre[i-1]+minc[i-1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL res = 0;</span><br><span class="line">        LL temp = 0;</span><br><span class="line">        for(LL i = maxn - 1; i &gt;=0; i--)&#123;</span><br><span class="line">            if((zeros[i]+temp+pre[i])&lt;=M)&#123;</span><br><span class="line">                temp += zeros[i];</span><br><span class="line">                res += (1LL&lt;&lt;i);</span><br><span class="line">            &#125;else if(temp+ones[i]+pre[i]&lt;=M)&#123;</span><br><span class="line">                temp += ones[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res = -1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld \n&quot;, t, res);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方一定需要搞清楚的是，从最高位开始找的时候，并不是取1就可以，因为后面所有的位的0和1的情况会形成一个数字的范围，而不是0.一定要注意。</p>
<h1 id="本题收获"><a href="#本题收获" class="headerlink" title="本题收获"></a>本题收获</h1><ol>
<li>要注意看测试集的测试用例的条件，尤其是大小，直接会决定我们的数据类型是int或者long long或者其他。</li>
<li>要注意题目隐含的条件，这个条件并不是单纯的从最高位到最低位的贪心，而是有后续隐含条件的贪心，所以一定要注意。</li>
<li>对于位运算，一定要学会使用移位运算符以及对应的位运算操作，有时候可能会有巧妙的作用。</li>
<li>因为c++的灵活性，可以通过地址进行操作，所以在使用数组的时候一定要注意不要越界，在进行相关条件判断的时候一定要小心。当报错说运行时错误的时候，多半就是for循环的条件写错了或者数组越界了。还有当你发现在本地跑的和在kickstart上跑同一份代码，但是结果不一样的时候，多半也是地址错了，以后要注意！</li>
<li>做出来这个题目的感觉很爽啊，继续加油～</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title>kickstart-2019-G-T1-BookReading</title>
    <url>/2019/10/22/kickstart-2019-G-T1-BookReading/</url>
    <content><![CDATA[<p>上周六和同学一起尝试了一下Google Kickstart的题目，开了开眼，涨了涨见识！<br>本文是G轮第一题BookReading的思路以及代码，留个纪念。</p>
<a id="more"></a>

<h2 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e02/000000000018fd0d" target="_blank" rel="noopener">题目详情</a></h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>Supervin is a librarian handling an ancient book with N pages, numbered from 1 to N. Since the book is too old, unfortunately M pages are torn out: page number P1, P2, …, PM.</p>
<p>Today, there are Q lazy readers who are interested in reading the ancient book. Since they are lazy, each reader will not necessarily read all the pages. Instead, the i-th reader will only read the pages that are numbered multiples of Ri and not torn out. Supervin would like to know the sum of the number of pages read by each reader.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the three integers N, M, and Q, the number of pages in the book, the number of torn out pages in the book, and the number of readers, respectively. The second line contains M integers, the i-th of which is Pi. The third line contains Q integers, the i-th of which is Ri.</p>
<h3 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h3><p>Time limit: 40 seconds per test set.<br>Memory limit: 1GB.<br>1 ≤ T ≤ 100.<br>1 ≤ P1 &lt; P2 &lt; … &lt; PM ≤ N.<br>1 ≤ Ri ≤ N, for all i.</p>
<p>Test set 1 (Visible)<br>1 ≤ M ≤ N ≤ 1000.<br>1 ≤ Q ≤ 1000.</p>
<p>Test set 2 (Hidden)<br>1 ≤ M ≤ N ≤ 105.<br>1 ≤ Q ≤ 105.</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p><img src="https://raw.githubusercontent.com/aweng126/FigureBed/master/img/20191023100352.png" alt=""></p>
<h2 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h2><p>图书管理员想知道大家一共读了多少页书，需要我们统计。<br>已知情况是书的总页数N，坏了的页数M，有Q个读者。<br>然后知道坏的M分别是那些页，知道读者每个人都要读那些页（实际上知道的是基数，这个读者会读这个基数的整数倍）。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果大家想看最终结果，可以直接翻到最后，然后前面的代码写的比较乱，后来经过王博指点，有了很大的改善。好的代码习惯还是要保持的。</p>
<h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>一看题目很简单，对于每个人来说，如果书籍不坏，那么他可以读页数/基数页，然后看看坏了的页数中有几个是基数的倍数，减去就可以。然后我们最终的结果就是每个人的结果加和。<br>代码如下，写的很乱，而且第二个样例不出意外的超时了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solve(int case_num)&#123;</span><br><span class="line">    int N,M,Q;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M&gt;&gt;Q;</span><br><span class="line">    vector&lt;int&gt; torn;</span><br><span class="line">    int res =0;</span><br><span class="line">    //vector&lt;int&gt; reader;</span><br><span class="line">    for(int i = 0;i&lt;M;i++)&#123;</span><br><span class="line">        int mi;</span><br><span class="line">        cin &gt;&gt; mi;</span><br><span class="line">        torn.emplace_back(mi);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i =0;i&lt;Q;i++)&#123;</span><br><span class="line">        int ri;</span><br><span class="line">        cin &gt;&gt; ri;</span><br><span class="line">        int num = N/ri;</span><br><span class="line">        int sortnum =0;</span><br><span class="line">        for(int j = 0;j&lt;M;j++)&#123;</span><br><span class="line">            if(torn[j]%ri==0)&#123;</span><br><span class="line">                sortnum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += (num - sortnum);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Case #&quot; &lt;&lt; case_num &lt;&lt; &quot;: &quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">    solve(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划求解"><a href="#动态规划求解" class="headerlink" title="动态规划求解"></a>动态规划求解</h3><p>仔细想想，其实我们上面暴力的时间复杂度是O（M<em>Q），当破坏的页数很多的时候，很多判断是无效的，没有意义的，比如某位读者只读2的倍数，那么我其实只要判断2，4，6，2</em>n&lt;=N这些页就可以。其他的页数完全可以不用判断，所以这个地方可以简化。于是是不是可以把每个基数对应的结果都算出来，然后当读读者的基数的时候，直接将其求和就可以呢？当然可以！于是就有了下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int a[MAXN],ans[MAXN];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t,x;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">        int N,M,Q;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;Q);</span><br><span class="line"></span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            a[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            a[x] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i&lt;=N; i++)&#123;</span><br><span class="line">            for(int j =i; j &lt;= N; j+=i)&#123;</span><br><span class="line">                 ans[i] += a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LL res =0;</span><br><span class="line">        for( int i = 1; i &lt;= Q; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            res += ans[x];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,res);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0;i&lt;=N;i++)&#123;</span><br><span class="line">            ans[i] = 0;</span><br><span class="line">            a[i] =0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进一步动态规划"><a href="#进一步动态规划" class="headerlink" title="进一步动态规划"></a>进一步动态规划</h3><p>上面的方法把所有的基数对应的结果都算出来了，但是其实中间的很多结果我们是用不到的，比如我们就两个读者，分别读2的倍数和3的倍数，而上面那个方法将1-N的所有结果都算出来了，最后只用了2和3对应的结果而已，这样就造成了浪费。所以我们是不是可以将结果进行保存，下次来了一个读者，看看之前有没有算过，如果算过，就直接用之前保存的结果，如果没有算过，那么就计算一下，然后保存起来呢？当然可以！于是就有了下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int MAXN = 1e5+10;</span><br><span class="line"></span><br><span class="line">int getPage(int N,int i,int arr[])&#123;</span><br><span class="line">    int res =0;</span><br><span class="line">    for(int j = i; j&lt;=N; j+=i)&#123;</span><br><span class="line">        res += arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a[MAXN],ans[MAXN];</span><br><span class="line">int N,M,Q;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int t,x;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">  for (int i = 1; i &lt;= t; ++i) &#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;,&amp;N,&amp;M,&amp;Q);</span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            a[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        for(int i = 1;i&lt;=M;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            a[x] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(ans, 0, sizeof ans);</span><br><span class="line">      </span><br><span class="line">        LL res =0;</span><br><span class="line">        for( int i = 1; i &lt;= Q; i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            if(ans[x]==0)&#123;</span><br><span class="line">                ans[x] = getPage(N, x,a);</span><br><span class="line">            &#125;</span><br><span class="line">            res += ans[x];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,res);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本题收获"><a href="#本题收获" class="headerlink" title="本题收获"></a>本题收获</h2><ol>
<li>了解到了比较好的编码规范，以后会应用到实践中。</li>
<li>锻炼了自己分析问题的能力，提高算法的效率很重要，而其中的意识要逐渐培养。</li>
<li>认识到了c++灵活但是有时候太灵活，以后需要好好注意如何使用。</li>
<li>知道了kickstart的难度以及自己的水平。刷题路漫漫，以后请加油。</li>
</ol>
]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>终端工具tmux资料分享</title>
    <url>/2019/10/21/tmux-reference/</url>
    <content><![CDATA[<ol>
<li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html" target="_blank" rel="noopener">阮一峰-Tmux 使用教程</a><br>从浅入深，娓娓道来，非常棒。</li>
<li><a href="https://louiszhai.github.io/2017/09/30/tmux/#Tmux%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener">路易斯-Tmux使用手册</a><br>大牛无疑，介绍的非常干练，私人定制部分写的特别好。</li>
<li><a href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7#file-tmux-cheatsheet-markdown" target="_blank" rel="noopener">GitHub-Tmux 快捷键 &amp; 速查表 &amp; 简明教程</a><br>方便大家使用。</li>
</ol>
]]></content>
      <categories>
        <category>工具推荐</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>喜大普奔，庆文又搭博客了。</title>
    <url>/2019/10/18/hello-world-1/</url>
    <content><![CDATA[<p>最近看到一句话，</p>
<pre><code>有了自己的博客，就仿佛自己在互联网中留下了自己的脚印.</code></pre><p>还挺有诗意的，所以我就把这个博客搭建起来了。</p>
<a id="more"></a>

<h1 id="博客写点啥呢"><a href="#博客写点啥呢" class="headerlink" title="博客写点啥呢"></a>博客写点啥呢</h1><h2 id="可能会帮到别人的东西"><a href="#可能会帮到别人的东西" class="headerlink" title="可能会帮到别人的东西"></a>可能会帮到别人的东西</h2><p>本部分包含但不限于代码的bug解决办法，代码规范，leetcode题解。</p>
<h2 id="自己觉得需要整理的东西"><a href="#自己觉得需要整理的东西" class="headerlink" title="自己觉得需要整理的东西"></a>自己觉得需要整理的东西</h2><p>本部分包含但不限于对于某个问题的求解过程。</p>
<h2 id="也许写点乱七八糟的推荐"><a href="#也许写点乱七八糟的推荐" class="headerlink" title="也许写点乱七八糟的推荐"></a>也许写点乱七八糟的推荐</h2><p>本部分包含但是不限于对于书籍电影动漫等的推荐。</p>
<p>目标就是等我回忆青春的时候，再来这个博客瞅瞅，让我能够感慨一句，我当年也干了很多事情呀。</p>
<h1 id="博客搭建参考"><a href="#博客搭建参考" class="headerlink" title="博客搭建参考"></a>博客搭建参考</h1><ol>
<li><a href="https://cuiqingcai.com/7625.html" target="_blank" rel="noopener">崔庆才-利用 GitHub + Hexo + Next 从零搭建一个博客</a></li>
<li><a href="https://juejin.im/post/5a308ae551882540f363879a" target="_blank" rel="noopener">为你的hexo博客配置个性域名</a></li>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo-中文文档</a></li>
</ol>
]]></content>
      <categories>
        <category>文言文语</category>
      </categories>
      <tags>
        <tag>杂事</tag>
      </tags>
  </entry>
</search>
